<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
<meta name="google-site-verification" content="mHoeZbiieuN238tsyMA7DAU6UTZSrTBkXmCT6RO_jAw" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo_apple-touch-icon-wechat.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo_favicon-32x32-wechat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo_favicon-16x16-wechat.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="mHoeZbiieuN238tsyMA7DAU6UTZSrTBkXmCT6RO_jAw">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hiyongz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"giteement","storage":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="容器简单来说是一种沙盒技术，将应用“装”进沙盒中，像集装箱一样，把应用封装起来，使得应用之间不会相互干扰，而放进沙盒中的应用也方便“搬家”。本文基于docker来介绍容器相关核心技术。">
<meta property="og:type" content="article">
<meta property="og:title" content="容器技术介绍之docker核心技术概述">
<meta property="og:url" content="https://hiyongz.github.io/posts/container-docker-architecture-introduction/index.html">
<meta property="og:site_name" content="HiYong">
<meta property="og:description" content="容器简单来说是一种沙盒技术，将应用“装”进沙盒中，像集装箱一样，把应用封装起来，使得应用之间不会相互干扰，而放进沙盒中的应用也方便“搬家”。本文基于docker来介绍容器相关核心技术。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hiyongz.github.io/posts/container-docker-architecture-introduction/saas-vs-paas-vs-iaas2.png">
<meta property="og:image" content="https://hiyongz.github.io/posts/container-docker-architecture-introduction/docker-architecture.png">
<meta property="og:image" content="https://hiyongz.github.io/posts/container-docker-architecture-introduction/overlay_constructs.jpg">
<meta property="og:image" content="https://hiyongz.github.io/posts/container-docker-architecture-introduction/types-of-mounts.png">
<meta property="og:image" content="https://hiyongz.github.io/posts/container-docker-architecture-introduction/docker-vs-vm.png">
<meta property="og:image" content="https://hiyongz.github.io/posts/container-docker-architecture-introduction/flask-docker-demo.png">
<meta property="article:published_time" content="2022-01-30T12:16:00.000Z">
<meta property="article:modified_time" content="2023-08-13T23:43:43.675Z">
<meta property="article:author" content="HiYo">
<meta property="article:tag" content="容器">
<meta property="article:tag" content="docker">
<meta property="article:tag" content="PaaS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hiyongz.github.io/posts/container-docker-architecture-introduction/saas-vs-paas-vs-iaas2.png">

<link rel="canonical" href="https://hiyongz.github.io/posts/container-docker-architecture-introduction/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>容器技术介绍之docker核心技术概述 | HiYong</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script src="/live2d-widget/autoload.js"></script>
<link rel="alternate" href="/atom.xml" title="HiYong" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HiYong</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">此时 此地 此身</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书单</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fa fa-gavel fa-fw"></i>工具</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/hiyongz/DevTest-Notes" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hiyongz.github.io/posts/container-docker-architecture-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/logo_android-chrome-192x192-wechat.png">
      <meta itemprop="name" content="HiYo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HiYong">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          容器技术介绍之docker核心技术概述
        </h1>

        <div class="post-meta">
          
          

            <span class="post-time">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-30 12:16:00" itemprop="dateCreated datePublished" datetime="2022-01-30T12:16:00+00:00">2022-01-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">测试开发</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">容器技术</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/container-docker-architecture-introduction/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/container-docker-architecture-introduction/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>容器简单来说是一种沙盒技术，将应用“装”进沙盒中，像集装箱一样，把应用封装起来，使得应用之间不会相互干扰，而放进沙盒中的应用也方便“搬家”。本文基于docker来介绍容器相关核心技术。</p>
<a id="more"></a>
<h1 id="容器技术发展简介"><a href="#容器技术发展简介" class="headerlink" title="容器技术发展简介"></a>容器技术发展简介</h1><h2 id="IaaS、PaaS-和-SaaS"><a href="#IaaS、PaaS-和-SaaS" class="headerlink" title="IaaS、PaaS 和 SaaS"></a>IaaS、PaaS 和 SaaS</h2><p>一切皆服务（X as a service，XaaS）是目前的大趋势，2022年1月12日，国务院发布的《“十四五”数字经济发展规划》强调要推动企业上云，推进云网协同与算网融合。很多企业将自己的服务部署到云端。常见的云服务模型包括三种：</p>
<ul>
<li>基础设施即服务 (Infrastructure as a Service, IaaS)</li>
<li>平台即服务 (Platform as a Service, PaaS) </li>
<li>软件即服务 (Software as a Service, SaaS) </li>
</ul>
<p>这三种云服务模型提供了不同级别的控制和管理，</p>
<ul>
<li>IaaS 为云服务提供硬件，包括服务器、网络和存储。由于它只提供底层资源，客户需要自己管理操作系统 、数据库、应用程序等，所以灵活性更高。常见的有阿里云，亚马逊 AWS、微软 Azure等，据国际权威机构Gartner 2021年12月15日发布的最新报告，阿里云IaaS基础设施在计算、存储、网络、安全四项核心评比中均斩获最高分，拿下全球第一。</li>
<li>PaaS 除了提供 IaaS 可提供的硬件之外，还提供操作系统、中间件、数据库等。比如服务器平台，开发、部署环境。开发人员可以在其基础上开发或自定义基于云的应用程序，只负责应用程序、功能和数据，不需要关注底层，可以大大减少编码时间。PaaS平台一般支持应用程序的完整生命周期：生成、测试、部署、管理和更新，可以有效管理应用程序的生命周期。比如Google App Engine，上传应用程序到上面后就可以为用户提供服务。</li>
<li>SaaS 提供了最多的支持，为用户提供除其数据之外的所有服务。比如百度云、阿里云等存储服务，电子邮件，QQ、微信等社交服务都属于SaaS。</li>
</ul>
<p>这三种云服务模型特征可总结为下图：</p>
<p><img src="saas-vs-paas-vs-iaas2.png" width="80%" height="80%" /></p>
<center><font size="2">图片来源：https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/</font></center>

<h2 id="Cloud-Foundry"><a href="#Cloud-Foundry" class="headerlink" title="Cloud Foundry"></a>Cloud Foundry</h2><p>很多用户通常是在本地开发环境开发好应用后将其部署到云上，而部署过程通常会碰到云端虚拟机和本地环境不一致的问题，前面介绍了PaaS 项目具有“<strong>应用托管</strong>”的能力，一些PaaS 项目可以有效解决这种环境问题，比如Cloud Foundry，开发人员只要执行一条命令（应用打包和分发）就能把本地的应用部署到云上。</p>
<p>Cloud Foundry需要启动不同用户上传的应用，如何做到相互不冲突呢？其实它调用了操作系统的 Cgroups 和 Namespace 机制为每一个应用单独创建一个称作“沙盒”的隔离环境，也就是“容器”。然后在容器中运行应用，实现多个应用互不干涉地在虚拟机中运行，后来出现的Docker 项目其实也是使用的这种思路。</p>
<h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>Cloud Foundry虽然部署方便，但是部署之前的准备，也就是打包比较麻烦，需要做很多的修改和配置。Docker也使用了Cloud Foundry容器使用的Cgroups 和 Namespace 机制来创建隔离环境，区别在于打包方式不一样，Docker使用Docker 镜像技术实现应用打包，直接使用 <code>docker build</code> 命令创建镜像，这也是docker流行的原因。</p>
<p>Docker 镜像包括了完整的操作系统文件和目录，包含了应用运行所需要的所有依赖，不需要进行进行任何配置或者修改，跟你本地开发和测试环境用的操作系统完全一样，本地环境和云端环境的高度一致。镜像制作完成后，在云端执行  <code>docker run 镜像名称</code> 就可以运行应用。</p>
<blockquote>
<p>Docker不能完全取代PaaS，因为它不能完成大规模应用部署。</p>
</blockquote>
<h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p>容器编排（Container Orchestration）是对容器的一系列定义、配置和创建动作的管理，实现对多个容器进行管理。Docker Compose可用来管理单个主机上的多个容器，Docker Swarm 是一款用来管理多主机上的Docker容器的工具，管理容器集群。</p>
<p>2014 年 6 月Google 公司推出了 Kubernetes 项目，构建出了一个与docker不同的容器编排与管理的生态，采用 Pod、Sidecar 等功能和设计模式，由于其先进的理念以及来自Google在容器化基础设施领域的多年实践经验，加上 Kubernetes 项目覆盖了足够多的场景，Docker Swarm 项目逐渐失势，Docker 公司选择逐步放弃开源社区而专注于自己的商业化转型。2017 年 10 月，Docker 公司在Docker 企业版中内置 Kubernetes 项目，标志着在容器编排中Kubernetes 取得全面胜利。</p>
<h1 id="容器核心技术"><a href="#容器核心技术" class="headerlink" title="容器核心技术"></a>容器核心技术</h1><p>下面以docker为例介绍容器是如何实现应用隔离以及资源限制的，了解Linux 容器的核心实现原理。</p>
<h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>名称空间（Namespace） 是容器用来实现隔离的技术，先来看个例子。</p>
<p>运行容器busybox，执行 <code>ps</code> 命令查看容器内进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it busybox /bin/sh</span><br><span class="line">/ <span class="comment"># ps</span></span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 /bin/sh</span><br><span class="line">   11 root      0:00 ps</span><br></pre></td></tr></table></figure>
<p><code>-it</code> 一般一起使用，实现和docker容器进行交互。<code>-i</code> 表示以交互模式运行容器，<code>-t</code> 表示为容器分配一个伪输入终端。<code>/bin/sh</code> 是要在 Docker 容器里运行的程序。</p>
<p>容器内<code>/bin/sh</code>命令的进程ID为1，这表明容器里执行的<code>/bin/sh</code> 已经和宿主机”隔离”了，而在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，这就是Namespace 技术产生的效果，它只是修改了进程视图，容器内只能“看到”某些指定的进程。而对宿主机来说，这个<code>/bin/sh</code> 和其它进程没什么区别，我们可以在宿主机中查看这个<code>/bin/sh</code>进程的ID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps | grep busybox</span><br><span class="line">ef0b47c6f9bb   busybox             <span class="string">&quot;/bin/sh&quot;</span>                16 minutes ago   Up 16 minutes             hungry_booth</span><br><span class="line">$ </span><br><span class="line">$ docker top ef0b47c6f9bb</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                8786                8768                0                   11:20               pts/0               00:00:00            /bin/sh</span><br><span class="line">$ </span><br><span class="line">$ ps ajx | grep /bin/sh | grep -v grep</span><br><span class="line">  2453   2584   2584   2584 ?            -1 Ss       0   0:00 /usr/bin/ssh-agent /bin/sh -c <span class="built_in">exec</span> -l /bin/bash -c <span class="string">&quot;env GNOME_SHELL_SESSION_MODE=classic gnome-session --session gnome-classic&quot;</span></span><br><span class="line">  8367   8750   8750   8367 pts/3      8750 Sl+      0   0:00 docker run -it busybox /bin/sh</span><br><span class="line">  8768   8786   8786   8786 pts/0      8786 Ss+      0   0:00 /bin/sh</span><br></pre></td></tr></table></figure>
<p>可以发现，容器中“看到”的<code>/bin/sh</code>进程在宿主机中的PID为8786。</p>
<p>Namespace 技术可以确保不同容器之间的网络、进程等相互隔离，使互相无法通信，无法感知。比如我再启动另外一个容器执行<code>/bin/sh</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -it rethinkdb /bin/sh</span><br><span class="line"><span class="comment"># ps</span></span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">     1 pts/0    00:00:00 sh</span><br><span class="line">     7 pts/0    00:00:00 ps</span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>可以发现它的PID还是1，也就是说既看不到宿主机里真正的进程空间，也看不到其他 Namespace 里的具体情况。</p>
<p>在宿主机查看它们的PID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps ajx | grep /bin/sh | grep -v grep</span><br><span class="line">  8367   8750   8750   8367 pts/3      8750 Sl+      0   0:00 docker run -it busybox /bin/sh</span><br><span class="line">  8768   8786   8786   8786 pts/0      8786 Ss+      0   0:00 /bin/sh</span><br><span class="line">  8986   9189   9189   8986 pts/1      9189 Sl+      0   0:00 docker run -it rethinkdb /bin/sh</span><br><span class="line">  9207   9226   9226   9226 pts/0      9226 Ss+      0   0:00 /bin/sh</span><br></pre></td></tr></table></figure>
<p>上面介绍了进程名称空间（PID Namespace），还有其他类型的名称空间：Mount、UTS、IPC、Network 、User等名称空间。Network Namespace用于实现网络隔离，而有时候容器之间是需要通信的，比如连接数据库。不同Namespace之间的通信是通过Veth 设备对和网桥来实现的，比如你查看安装了docker 的服务器的网络设备会发现叫做 docker0 的网桥和很多随机名称的 veth 设备。</p>
<p>接下来介绍容器是如何解决限制问题的。</p>
<h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>使用Namespace技术之后，为什么还需要进行资源限制呢？</p>
<p>以前面介绍的<code>/bin/sh</code>进程为例，虽然进行了进程隔离，而在宿主机中，PID为8786的进程与其他所有进程之间依然是平等的竞争关系，也就是说，容器中进程使用的资源（CPU、内存等）可能随时被宿主机上的其他进程（或者其他容器的进程）占用。为了保证服务正常运行，需要进行资源限制。</p>
<p>容器使用 Cgroups 来限制一个进程能够使用的资源，Linux Cgroups （Linux Control Group）可以实现资源调度（资源限制、优先级控制等），限制进程可以使用的资源上限，比如CPU、memory、IO、网络带宽等。</p>
<p>cgroups 以文件的方式提供应用接口，Cgroups的默认挂载点在<code>/sys/fs/cgroup</code> 路径下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br></pre></td></tr></table></figure>
<p>可以看到cgroups的各种子系统（Subsystem）：</p>
<ul>
<li><strong>blkio</strong>：限制块设备的 IO 速度</li>
<li><strong>cpu</strong>：限制 CPU 时间片的分配</li>
<li><strong>cpuacct</strong>：统计CPU使用率，生成 cgroup 中的任务占用 CPU 资源的报告</li>
<li><strong>cpuset</strong>：给 cgroup 中的任务分配独立的 CPU(多处理器系统) 和内存节点。</li>
<li><strong>devices</strong>：限制cgroup创建(mknod)和访问设备的权限。</li>
<li><strong>freezer</strong>：暂停/恢复 cgroup 中的任务（进程 ）。</li>
<li><strong>hugetlb</strong>：限制使用的内存页数量。              </li>
<li><strong>memory</strong>：对 cgroup 中的任务的可用内存进行限制，并自动生成资源占用报告。包括process memory, kernel memory, 和swap。</li>
<li><strong>net_cls</strong>：使用等级识别符（classid）标记网络数据包，这让 Linux 流量控制器（tc 指令）可以识别来自特定 cgroup 任务的数据包，并进行网络限制。</li>
<li><strong>net_prio</strong>：允许基于 cgroup 设置网络流量(netowork traffic)的优先级。</li>
<li><strong>perf_event</strong>：允许使用 perf 工具来对 cgroup进行性能监控</li>
<li><strong>pids</strong>：限制任务的数量（进程数）。</li>
</ul>
<p>可以通过修改配置文件对子系统对应的资源进行限制，以CPU为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls /sys/fs/cgroup/cpu</span><br><span class="line">cgroup.clone_children  cgroup.sane_behavior  cpuacct.usage_percpu  cpu.rt_period_us   cpu.stat       notify_on_release  tasks</span><br><span class="line">cgroup.event_control   cpuacct.stat          cpu.cfs_period_us     cpu.rt_runtime_us  docker         release_agent      user.slice</span><br><span class="line">cgroup.procs           cpuacct.usage         cpu.cfs_quota_us      cpu.shares         machine.slice  system.slice</span><br></pre></td></tr></table></figure>
<p>cpu.cfs_period_us 和 cpu.cfs_quota_us可用来限制在period期间内，用户组的CPU限额为quota的 CPU 时间，当超过这个值的时候，用户组将会被限制运行，等到下一个周期开始被解除限制。</p>
<p>举个例子来看如何配置cgroup来限制CPU，在<code>/sys/fs/cgroup/cpu</code> 目录下创建一个控制组test_cpu，目录下会自动生成对应的资源限制文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /sys/fs/cgroup/cpu  </span><br><span class="line">$ mkdir test_cpu</span><br><span class="line">$ <span class="built_in">cd</span> test_cpu</span><br><span class="line">$ ls</span><br><span class="line">cgroup.clone_children  cgroup.procs  cpuacct.usage         cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release</span><br><span class="line">cgroup.event_control   cpuacct.stat  cpuacct.usage_percpu  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<p>tasks文件用于存放需要使用此控制组进行资源限制的PID。</p>
<p>把 CPU quota值限制为总量的十分之一：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 100000 &gt; cpu.cfs_period_us </span><br><span class="line">$ <span class="built_in">echo</span> 10000 &gt; cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>
<p>创建一个 CPU 密集型的程序cputime.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, end;</span><br><span class="line"></span><br><span class="line">    end = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; end; )</span><br><span class="line">    &#123;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行：不限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc cputime.c -o cputime</span><br><span class="line">$ time ./cputime</span><br><span class="line"></span><br><span class="line">real    0m2.641s</span><br><span class="line">user    0m2.610s</span><br><span class="line">sys     0m0.002s</span><br></pre></td></tr></table></figure>
<p>CPU限制后的执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ time cgexec -g cpu:test_cpu ./cputime</span><br><span class="line"></span><br><span class="line">real    0m25.233s</span><br><span class="line">user    0m2.538s</span><br><span class="line">sys     0m0.006s</span><br></pre></td></tr></table></figure>
<p>可以看到CPU限制生效了，其它子系统资源限制类似。</p>
<p>对容器的资源限制一样，在对应的子系统下为每个容器创建一个控制组，启动容器进程后，将进程PID填写到tasks文件中就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ls /sys/fs/cgroup/cpu</span><br><span class="line">cgroup.clone_children  cgroup.sane_behavior  cpuacct.usage_percpu  cpu.rt_period_us   cpu.stat       notify_on_release  tasks</span><br><span class="line">cgroup.event_control   cpuacct.stat          cpu.cfs_period_us     cpu.rt_runtime_us  docker         release_agent      user.slice</span><br><span class="line">cgroup.procs           cpuacct.usage         cpu.cfs_quota_us      cpu.shares         machine.slice  system.slice</span><br><span class="line">$ <span class="built_in">cd</span> docker</span><br><span class="line">$ ls</span><br><span class="line">0cafa91c7d00e21a5b17c77984cc2442b6baeb68bdaa4196040526221b6c5a23  cpuacct.usage         cpu.shares</span><br><span class="line">aaa5ff963322b0d53b7b973944631a8bfffc594a9a0433ea1ca239b1c3a589ea  cpuacct.usage_percpu  cpu.stat</span><br><span class="line">cgroup.clone_children                                             cpu.cfs_period_us     ef0b47c6f9bbb91cf2c2aece8328de27d5e32d4c4baf2c4cea66111793962687</span><br><span class="line">cgroup.event_control                                              cpu.cfs_quota_us      f65309644ef13f56fb9767494be85b6e110018804f05e75be1f239c07ea59529</span><br><span class="line">cgroup.procs                                                      cpu.rt_period_us      notify_on_release</span><br><span class="line">cpuacct.stat                                                      cpu.rt_runtime_us     tasks</span><br></pre></td></tr></table></figure>
<p>目录<code>ef0b47c6f9bbb91cf2c2aece8328de27d5e32d4c4baf2c4cea66111793962687</code> 是我启动的busybox容器的cpu控制组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ef0b47c6f9bbb91cf2c2aece8328de27d5e32d4c4baf2c4cea66111793962687</span><br><span class="line">$ cat tasks</span><br><span class="line">8786</span><br></pre></td></tr></table></figure>
<p>可以看到，busybox容器中启动的<code>/bin/sh</code>进程（PID=8786）被加入了CPU控制组中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line">$ cat cpu.cfs_quota_us</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>发现cfs_quota没有被限制。</p>
<p>控制组中资源配置文件的值可以在启动容器时指定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpu-period=100000 --cpu-quota=10000 busybox /bin/bash</span><br></pre></td></tr></table></figure>
<p>看一下是否生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/fs/cgroup/cpu/docker/a3b36d2f70ef42bddfaaa8cc4a88d472a7c1f3173731af7ccb8d710b44cbb89b/cpu.cfs_period_us </span><br><span class="line">100000</span><br><span class="line">$ cat /sys/fs/cgroup/cpu/docker/a3b36d2f70ef42bddfaaa8cc4a88d472a7c1f3173731af7ccb8d710b44cbb89b/cpu.cfs_quota_us</span><br><span class="line">10000</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>注意：容器ID变化的原因是我重新运行了busybox容器。</p>
<p>其它子系统资源限制类似，比如memory子系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /sys/fs/cgroup/memory/docker</span><br><span class="line">$ ls</span><br><span class="line">0cafa91c7d00e21a5b17c77984cc2442b6baeb68bdaa4196040526221b6c5a23  memory.kmem.failcnt                 memory.limit_in_bytes            memory.pressure_level</span><br><span class="line">a3b36d2f70ef42bddfaaa8cc4a88d472a7c1f3173731af7ccb8d710b44cbb89b  memory.kmem.limit_in_bytes          memory.max_usage_in_bytes        memory.soft_limit_in_bytes</span><br><span class="line">aaa5ff963322b0d53b7b973944631a8bfffc594a9a0433ea1ca239b1c3a589ea  memory.kmem.max_usage_in_bytes      memory.memsw.failcnt             memory.stat</span><br><span class="line">cgroup.clone_children                                             memory.kmem.slabinfo                memory.memsw.limit_in_bytes      memory.swappiness</span><br><span class="line">cgroup.event_control                                              memory.kmem.tcp.failcnt             memory.memsw.max_usage_in_bytes  memory.usage_in_bytes</span><br><span class="line">cgroup.procs                                                      memory.kmem.tcp.limit_in_bytes      memory.memsw.usage_in_bytes      memory.use_hierarchy</span><br><span class="line">f65309644ef13f56fb9767494be85b6e110018804f05e75be1f239c07ea59529  memory.kmem.tcp.max_usage_in_bytes  memory.move_charge_at_immigrate  notify_on_release</span><br><span class="line">memory.failcnt                                                    memory.kmem.tcp.usage_in_bytes      memory.numa_stat                 tasks</span><br><span class="line">memory.force_empty                                                memory.kmem.usage_in_bytes          memory.oom_control</span><br></pre></td></tr></table></figure>
<h2 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h2><p>Docker镜像技术是docker的重要创新，其核心就是联合文件系统，大大简化了应用的更新和部署。</p>
<p><img src="docker-architecture.png" width="80%" height="80%" /></p>
<h3 id="bootfs和rootfs"><a href="#bootfs和rootfs" class="headerlink" title="bootfs和rootfs"></a>bootfs和rootfs</h3><p>一个典型的 Linux 系统至少需要包含bootfs（boot file system）和rootfs（root file system）两个文件系统：</p>
<ul>
<li>bootfs包含 boot loader 和 kernel，也就是说相同内核的不同的 Linux 发行版本的bootfs 相同，而rootfs 不同。</li>
<li>rootfs（根文件系统）是一个操作系统的所有文件和目录，包含典型的目录结构，比如/dev, /proc, /bin, /etc, /lib, /usr等。</li>
</ul>
<p>在docker容器技术中，宿主机上的所有容器共享主机系统的 bootfs，也就是共享宿主机的内核。换句话说，如果你配置了内核参数，该机器上的所有容器都会受到影响，这也是容器相比于虚拟机的主要缺陷之一。</p>
<p>每个容器有自己的 rootfs，也就是容器镜像，它是挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统。</p>
<p>下面进入Jenkins容器中看看有哪些目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it -u root jenkins bash</span><br><span class="line">root@ce93d1eab3c2:/<span class="comment"># </span></span><br><span class="line">root@ce93d1eab3c2:/<span class="comment"># </span></span><br><span class="line">root@ce93d1eab3c2:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
<p>可以看到容器的根目录挂载了一个完整操作系统的文件系统，因此在打包时将应用，以及应用运行所需要的所有依赖都封装在了一起，这保证了容器的“一致性”，部署非常便利。</p>
<p>结合使用 Mount Namespace 和 rootfs，容器就能够为进程构建出一个完善的文件系统隔离环境。在 rootfs 的基础上，Docker 提出了多个增量 rootfs 联合挂载一个完整 rootfs 的方案，这就是容器镜像中“层”的概念，下面介绍docker的镜像分层系统。</p>
<h3 id="联合文件系统-1"><a href="#联合文件系统-1" class="headerlink" title="联合文件系统"></a>联合文件系统</h3><p>通常情况下，我们会对已有的镜像进行修改，比如应用升级。Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs，而修改时不会修改下层镜像（只读层），修改产生的内容会以增量的方式出现在可读写层中，这一层会存放你增、删、改rootfs 后产生的增量。也就是说可读写层只记录对只读层的更改，这样镜像会一层一层的重叠起来。</p>
<p>这种对容器镜像进行增量式的操作，大大减少了容器镜像占用的空间，比较轻量级，加上它的“一致性”特性，使得docker成为热点项目，Docker 公司在 2014~2016 年间迅猛发展。</p>
<p>docker 的这种镜像分层思想是通过联合文件系统来实现的，目前docker支持多种联合文件系统，包括AuFS，device mapper，overlayFS，overlayFS2等。</p>
<ul>
<li><p>AuFS是最早支持的文件系统， 据说是因为AuFS的代码写的实在太烂，Linus Torvalds（Linux 之父）一直不让把 AuFS 添加到Linux 内核主干，所以我们只能在 Ubuntu 和 Debian 这些发行版上使用它。要使用它需要手动配置</p>
</li>
<li><p>device mapper是RedHat公司和Docker团队开发的文件系统，性能不是很好，但通过它可以在 centos 上安装并使用 docker。 </p>
</li>
<li><p>overlayFS是AuFS的升级版，并且成功进入了 linux 内核主干，它使用硬链接的方式指向深层的镜像。</p>
</li>
<li><p>overlayFS2在架构上进行了优化，128 层以上才会使用硬链接，128层以下使用像 AuFS 的联合文件视图的方式。centos和Ubuntu 的Docker Engine默认使用overlayFS2。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /var/lib/docker</span><br><span class="line">buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes</span><br></pre></td></tr></table></figure>
<h3 id="AuFS配置"><a href="#AuFS配置" class="headerlink" title="AuFS配置"></a>AuFS配置</h3><p>docker使用的联合文件系统（Advance Union File System, AuFS）来源于Union File System (UnionFS)，是对 Linux 原生 UnionFS 的重写和改进，UnionFS的主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。</p>
<p>如果你是Ubuntu或者 Debian 系统，可以手动配置AUFS 模式，步骤如下：Ubuntu-20.04.3，Docker version 20.10.12。</p>
<p>查看系统是否支持 AuFS：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep aufs /proc/filesystems</span><br><span class="line">nodev   aufs</span><br></pre></td></tr></table></figure>
<p>查看当前docker使用的文件系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker info | grep <span class="string">&quot;Storage Driver&quot;</span></span><br><span class="line"> Storage Driver: overlay2</span><br></pre></td></tr></table></figure>
<p>在 <code>/etc/docker</code> 下新建 daemon.json 文件，写入以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;storage-driver&quot;:</span> <span class="string">&quot;aufs&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启 Docker：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>重启后Docker的文件系统就切换为AuFS了。</p>
<h3 id="docker镜像结构"><a href="#docker镜像结构" class="headerlink" title="docker镜像结构"></a>docker镜像结构</h3><p>下面以centos和Ubuntu 默认使用的overlayFS2为例介绍docker的镜像分层系统。</p>
<p>以jenkins举例，查看jenkins镜像包含的层：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect jenkins/jenkins</span><br><span class="line">.....</span><br><span class="line"><span class="string">&quot;GraphDriver&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/2831aec4f79dce47c65502d44c3ac7943de8cac3673af33734fe96853b3fa72c/diff:/var/lib/docker/overlay2/06a6068894a4b1003642f81a1c9e621f28c3f658375e1736a05e8decfb35fa74/diff:/var/lib/docker/overlay2/cb8b816fcdc3b2d5ae2ad8d5bd96e77dd0cad7b085f115f9a82cceac0fb5cc21/diff:/var/lib/docker/overlay2/d12760a8287d5556fc7fb8eff16cb0a13be008eb5df9eef6740973acd42c4d75/diff:/var/lib/docker/overlay2/f6ed744b1f83c0aec623b67fd7ad4826d87d9cfbe96b7511ffc10538c551d709/diff:/var/lib/docker/overlay2/f98a07ed1507ee0f85d3d15c49bb2f08317090be9538779cc3be077a7f5d26a0/diff:/var/lib/docker/overlay2/3c47c55df47cb76fe6b0affe44a54b3fc282d9cddc6e8e91ee8d37fee153ad32/diff:/var/lib/docker/overlay2/f590962d115ad3a0b9ce29e3813d07f941ebc978955d3f0e878107873286c6ed/diff:/var/lib/docker/overlay2/4fc791fa5d63311f24c26c4ed099bcad5bdfba21878a62ba3b703584624b52ce/diff:/var/lib/docker/overlay2/71182ef801d593dc0515a1a023f7d806128b626d7a70c28ca8e3954c307c9850/diff:/var/lib/docker/overlay2/bc728058a9fd4473b335266c51f9b17fac47b1caba4611ed22ade419b4f8134c/diff:/var/lib/docker/overlay2/4d177d19504db3444f18b8d7210ee8fcbaf8f3a9e308307764a324ef0e11fa07/diff:/var/lib/docker/overlay2/7987d4111412b1918ef9cb1f9783b13266ffad06db4dc468b8d965f20803cb4e/diff:/var/lib/docker/overlay2/e694ab0894df35db1c9ca8e7e24a7026bbcd349954808b16a7cee8fcb57c73d3/diff:/var/lib/docker/overlay2/94800468c0d78d4b5d25fb0fde1308543b5a82266e941c7292244bd40476b907/diff:/var/lib/docker/overlay2/2700dd307c1887eadc091c2e5e4c0f98cf45b10e84a5d8b4774914d718ee2194/diff:/var/lib/docker/overlay2/1775daf31e9234afec3143d5b902cc6a2d298a5e251e26443dacbb3f27267ed8/diff:/var/lib/docker/overlay2/491b963dedf2f9953afeeda5bb16717ef8a9e9b24eb22f01ba30ea6e8e1f56db/diff:/var/lib/docker/overlay2/4d335a15bbfe5484698feba460f84b8635191cb4c30f5048ae4d23c2b7fa64fe/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/cf15ec1cc4c49db1af786f5ddd9a647fe75d14cb9855a045846119b0c1175e98/merged&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/cf15ec1cc4c49db1af786f5ddd9a647fe75d14cb9855a045846119b0c1175e98/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/cf15ec1cc4c49db1af786f5ddd9a647fe75d14cb9855a045846119b0c1175e98/work&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;RootFS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Layers&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:7948c3e5790c6df89fe48041fabd8f1c576d4bb7c869183e03b9e3873a5f33d9&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:4d1ab3827f6b69f4e55bd69cc8abe1dde7d7a7f61bd6e32c665f12e0a8efd1c9&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:69dfa7bd7a92b8ba12a617ff56f22533223007c5ba6b3a191c91b852320f012e&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:01727b1a72df8ba02293a98ab365bb4e8015aefadd661aaf7e6aa76567b706b9&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:e43c0c41b833ec88f51b6fdb7c5faa32c76a32dbefdeb602969b74720ecf47c9&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:bd76253da83ab721c5f9deed421f66db1406d89f720387b799dfe5503b797a90&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:d81d8fa6dfd451a45e0161e76e3475e4e30e87e1cc1e9839509aa7c3ba42b5dd&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:5a61379a8e62960bb62dda930787c7050ff63f195437879bccf9c4c28cdb1291&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:b5fb418b14f96644594140b4252500fc07425fc7fd5bb9e3cd50ddb6bd3afbd8&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:42f827e1a3dded30512b90e3c9a8f8163cabff70a724c4bfa8c79262605cef11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:04b9998735689e24846c57fb5103af52cbebcbe30a0e86bb4457fb980aad39f1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:60863b4a1d35106e2f1eb938a3ce2a895a8e252fadb38b50211d6619cb81c7d6&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:aee815dec61e21b5133837d35ac769c9d3cc1a34d04de50ee13c362abf1c0486&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:2bab4f9da3e7b9c7ee7000c6aed373bc45b90b4f16eb58c6ffbc2743e9416b46&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:c11406ec15d4ad731f734d44863f20915cb373c465a67fa50342f2ea37737e3d&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:dfcc6ab2bd0706f88a044072c94204f4a821afca5109d1195b45d61b2ac4a0d0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:4a90843d8f4555c71f9c63f190b3065b082541cc6912d14faf72e046bbe903ff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:4d016378c3c1bba1d3f01f2bb2267b4676fc6168e9c8c47585aec32ac043787e&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:f1bd73eaefb0e56fb97382339ffa4d1318210bfc93b0cb04cae8b9c30643993a&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:19412a66aaee7b66ea7f49ae2a691afceec0e342a0aa89c9771b8e56ca67773a&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>
<p>查看 <code>RootFS</code> 字段可以看到jenkins镜像包含了20层，Docker 把这些rootfs联合挂载在一个统一的挂载点上</p>
<ul>
<li><strong>LowerDir</strong> 为只读镜像层。可以有多层，可以看到上面的 jenkins 镜像的 <code>LowerDir</code> 一共有19层。</li>
<li><strong>WorkDir</strong> 为工作基础目录，和 <code>Upper</code> 层并列， 充当一个中间层的作用，在对 <code>Upper</code> 层里面的副本进行修改时，会先到 <code>WorkDir</code>，然后再从 <code>WorkDir</code> 移动 <code>Upper</code> 层。</li>
<li><strong>UpperDir</strong> 为可读写层，对容器的更改发生在这一层，包含了对容器的更改，挂载方式为rw，即 read write，采用写时复制（copy-on-write）机制。</li>
<li><strong>MergedDir</strong> 为 <code>WorkDir</code>、<code>UpperDir</code> 和 <code>LowerDir</code> 的联合挂载点，是呈现给用户的统一视图</li>
</ul>
<p>下图显示了OverlayFS架构是如何进行挂载的。</p>
<p><img src="overlay_constructs.jpg" width="80%" height="80%" /></p>
<center><font size="2">图片来源：https://docs.docker.com/storage/storagedriver/overlayfs-driver/</font></center>

<p>容器镜像层的rootfs ID可以在 <code>GraphDriver</code> 的<code>LowerDir</code> 中查看，也可以通过如下方式一步一步找到每层的cache-id。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /var/lib/docker/image/overlay2/distribution/</span><br><span class="line">diffid-by-digest  v2metadata-by-diffid</span><br></pre></td></tr></table></figure>
<p><code>Diffid-by-digest</code> 保存了digest（layerID）-&gt; diffID 的映射关系，<code>v2metadata-by-diffid</code> 保存了diffID -&gt; digest（layerID） 的映射关系。</p>
<p>通过diffID获取layerID，以最底层<code>7948c3e579......</code> 为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/lib/docker/image/overlay2/distribution/v2metadata-by-diffid/sha256</span><br><span class="line">$ cat 7948c3e5790c6df89fe48041fabd8f1c576d4bb7c869183e03b9e3873a5f33d9</span><br><span class="line">[&#123;<span class="string">&quot;Digest&quot;</span>:<span class="string">&quot;sha256:3192219afd04f93d90f0af7f89cb527d1af2a16975ea391ea8517c602ad6ddb6&quot;</span>,<span class="string">&quot;SourceRepository&quot;</span>:<span class="string">&quot;docker.io/jenkins/jenkins&quot;</span>,<span class="string">&quot;HMAC&quot;</span>:<span class="string">&quot;&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>得到 layerID 为 <code>3192219afd04f93......</code></p>
<p>docker的image元数据和layer元数据分别存放在imagedb和layerdb目录下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/lib/docker/image</span><br><span class="line">$ ls</span><br><span class="line">overlay2</span><br><span class="line">$ tree -L 2 overlay2/</span><br><span class="line">overlay2/</span><br><span class="line">├── distribution</span><br><span class="line">│   ├── diffid-by-digest</span><br><span class="line">│   └── v2metadata-by-diffid</span><br><span class="line">├── imagedb</span><br><span class="line">│   ├── content</span><br><span class="line">│   └── metadata</span><br><span class="line">├── layerdb</span><br><span class="line">│   ├── mounts </span><br><span class="line">│   ├── sha256</span><br><span class="line">│   └── tmp</span><br><span class="line">└── repositories.json</span><br><span class="line"></span><br><span class="line">10 directories, 1 file</span><br></pre></td></tr></table></figure></p>
<p><code>docker image</code>命令查看jenkins镜像ID：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls  | grep jenkins</span><br><span class="line">jenkins/jenkins              latest            10fafa8484ea   12 months ago   721MB</span><br></pre></td></tr></table></figure><br>通过镜像ID对应image元数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/lib/docker/image/overlay2/imagedb/content/sha256</span><br><span class="line">$ cat 10fafa8484ea146b66ede5c232021f229e0f5d0282f334bb40114b79d5c493ec</span><br></pre></td></tr></table></figure><br>我这里不展示具体内容了，和 <code>docker image inspect jenkins/jenkins</code> 命令显示的内容一样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/lib/docker/image/overlay2/layerdb/sha256</span><br><span class="line">$ ls</span><br></pre></td></tr></table></figure>
<p>可以看到最底层的layer：<code>7948c3e5790c6......</code>，你会发现没有layerID为<code>4d1ab3827f6b69f4......</code>的第二层，因为docker使用了chainID的方式来保存其它层：chainID=sha256sum(H(chainID) diffid)，也就是说<code>7948c3e5790c6......</code> 的上一层的sha256 id是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;sha256:7948c3e5790c6df89fe48041fabd8f1c576d4bb7c869183e03b9e3873a5f33d9 sha256:4d1ab3827f6b69f4e55bd69cc8abe1dde7d7a7f61bd6e32c665f12e0a8efd1c9&quot;</span> | sha256sum -</span><br><span class="line">72df91e735ae2b70a23f1770aa365b67f4772a545ed0a23d3decc7643b21a4e4  -</span><br></pre></td></tr></table></figure>
<p>你可以在<code>/var/lib/docker/image/overlay2/layerdb/sha256</code> 目录下找到第二层：<code>72df91e735ae2b7......</code> 。</p>
<p>依次类推，可以计算出所有层的layerID的组合。</p>
<p><code>/var/lib/docker/image/overlay2/layerdb</code> 存的只是元数据，每层真实的rootfs在<code>/var/lib/docker/overlay2/</code> 目录下，我们需要找到它的cache-id。</p>
<p>查看<code>/var/lib/docker/image/overlay2/layerdb/sha256/7948c3e5790c6df89fe48041fabd8f1c576d4bb7c869183e03b9e3873a5f33d9/cache-id</code>的值:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat cache-id</span><br><span class="line">4d335a15bbfe5484698feba460f84b8635191cb4c30f5048ae4d23c2b7fa64fe</span><br></pre></td></tr></table></figure>
<p><code>/var/lib/docker/overlay2/4d335a15bbfe5484698feba460f84b8635191cb4c30f5048ae4d23c2b7fa64fe</code> 就是当前层的rootfs。</p>
<p>进入里面可以看到一个完整的系统目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/lib/docker/overlay2/4d335a15bbfe5484698feba460f84b8635191cb4c30f5048ae4d23c2b7fa64fe</span><br><span class="line">$ ls diff/</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
<p>你在 <code>/var/lib/docker/overlay2/</code> 目录下可能会看到以“-init”结尾的目录，它对应docker的Init 层，位于只读层和读写层之间，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。在启动容器时写入的一些指定参数（每台机器环境不一样，比如hostname等）通过这一层进行修改，这些修改往往只对当前容器生效，在 <code>docker commit</code> 提交为镜像时不会将init层提交。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Linux容器包括3个核心技术：名称空间、Cgroups和联合文件系统。</p>
<p>名称空间（Namespace）具有隔离能力，Cgroups 提供限制能力，可以说，容器其实就是一种特殊的进程。</p>
<p>基于 rootfs 的联合文件系统是容器的基础，需要注意的是，容器镜像，也就是rootfs是一个文件系统，它不包含内核。</p>
<h1 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h1><p>默认情况下，在容器内创建的所有文件都存储在可读写容器层，可能会出现以下问题：</p>
<ul>
<li>当容器被删除时，数据不会持久存在，也会跟着被删除。</li>
<li>如果其它容器进程需要此容器的数据，从容器中取数据可能会很困难。</li>
<li>容器的可读写层与容器运行的宿主机紧密耦合，不方便将数据迁移到其他地方。</li>
<li>相比直接写入主机文件系统，在可读写容器层进行文件管理可能会降低性能。</li>
</ul>
<p>Linux系统中，Docker主要提供了3种方式用于容器的文件存储：<code>volumes</code>、 <code>bind mounts</code> 和 <code>tmpfs</code></p>
<p><img src="types-of-mounts.png" width="80%" height="80%" /></p>
<ul>
<li><strong>Volume</strong>（数据卷）存储在主机文件系统，由Docker管理，Linux下目录为<code>/var/lib/docker/volumes/</code>。非docker进程不会修改这个目录。Volume是进行Docker数据持久化的最好方法。</li>
<li><strong>Bind mounts</strong>可以存储在主机系统的任何位置，甚至可能是重要的系统文件或目录。Docker宿主机上的非Docker进程或Docker容器可以随时修改它们。</li>
<li><strong><code>tmpfs</code></strong>挂载只存储在宿主机的内存中，不会写入宿主机的文件系统。</li>
</ul>
<p>我们一般使用Volume机制来进行目录挂载，docker中使用 <code>-v</code> 参数，比如启动jenkins容器时，挂载 <code>/var/jenkins_home</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name=jenkins -d -p 8080:8080 -p 50000:50000 -v jenkins_test:/var/jenkins_home jenkins/jenkins</span><br></pre></td></tr></table></figure>
<p>其中，jenkins_test是使用<code>docker volume create jenkins_test</code> 命令创建的数据卷。具体可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010698107/article/details/113819992">Docker搭建持续集成平台Jenkins</a>。</p>
<p>目录挂载的语法格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -v /var/<span class="built_in">test</span>:/home ...</span><br></pre></td></tr></table></figure>
<p>实现将宿主机目录<code>/var/test</code> 挂载到容器的 <code>/home</code> 目录，在该挂载点 <code>/home</code> 上进行的任何操作，只是发生在被挂载的目录<code>/var/test</code> 上，而原挂载点的内容则会被隐藏起来且不受影响，不会影响容器镜像的内容。</p>
<p>此外，使用 <code>docker commit</code> 命令提交时，不会将宿主机目录提交，这是由于 Mount Namespace 的隔离作用，宿主机并不知道这个绑定挂载的存在。所以，在宿主机看来，容器中可读写层的 <code>/home</code> 目录始终是空的。但是，新产生的镜像里会多出来一个空的 <code>/home</code> 目录。</p>
<h1 id="容器和虚拟机区别"><a href="#容器和虚拟机区别" class="headerlink" title="容器和虚拟机区别"></a>容器和虚拟机区别</h1><p>通过前面对容器核心技术的介绍，你可能已经知道了容器和虚拟机之间的一些区别。最直接的就是容器不会虚拟化内核，容器是共用宿主机的内核的。</p>
<p>先来看下面这张图：</p>
<p><img src="docker-vs-vm.png" width="80%" height="80%" /></p>
<center><font size="2">虚拟机（左）和容器（右）的区别</font></center>

<p>虚拟机（Virtual machine, VM)是对计算机系统的仿真，硬件是虚拟化的，每个虚拟机都有自己的底层操作系统。管理程序(hypervisor)位于硬件和虚拟机之间，通过硬件虚拟化功能模拟硬件资源，比如 CPU、内存、I/O 设备等。然后，在模拟的虚拟硬件上安装了一个新的操作系统，即 Guest OS。</p>
<p>Docker容器也可以说是一种虚拟化技术，它不像虚拟机那样虚拟化操作系统和硬件资源，使用Docker Engine来创建相对隔离的沙盒环境。</p>
<p>总结一下它们的主要区别：</p>
<ul>
<li>容器与容器之间使用名称空间进行隔离隔离，而虚拟机是完全的资源隔离，可能更安全。</li>
<li>容器共享宿主机的内核，而虚拟机使用完全独立的内核，需虚拟化硬件和内核。</li>
<li>虚拟机的启动可能需要几分钟，Docker启动只需几秒钟甚至更短。</li>
<li>容器镜像更加轻量级，可能只有几百M，而虚拟机镜像可能有几十G。</li>
</ul>
<h1 id="Docker镜像制作"><a href="#Docker镜像制作" class="headerlink" title="Docker镜像制作"></a>Docker镜像制作</h1><p>了解了Linux容器3大核心技术之后，来看一下制作docker镜像的步骤。</p>
<h2 id="应用编写"><a href="#应用编写" class="headerlink" title="应用编写"></a>应用编写</h2><p>使用Docker部署一个用Python 编写的 Flask Web 应用 (app.py) 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, escape, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Index Page&lt;/h1&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span>, methods=[<span class="string">&#x27;get&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    name = request.args.get(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;World&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;&lt;h1&gt;Hello, <span class="subst">&#123;escape(name)&#125;</span>!&lt;/h1&gt;&#x27;</span> \</span><br><span class="line">           <span class="string">f&#x27;&lt;p&gt;Method: <span class="subst">&#123;request.method&#125;</span>&lt;/p&gt;&#x27;</span> \</span><br><span class="line">           <span class="string">f&#x27;&lt;p&gt;Url: <span class="subst">&#123;request.path&#125;</span>&lt;/p&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    config = <span class="built_in">dict</span>(</span><br><span class="line">        debug=<span class="literal">True</span>,</span><br><span class="line">        host=<span class="string">&#x27;0.0.0.0&#x27;</span>,</span><br><span class="line">        port=<span class="number">1234</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    app.run(**config)</span><br></pre></td></tr></table></figure>
<p>创建requirements.txt文件，内容为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br></pre></td></tr></table></figure>
<h2 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h2><p>Docker 使用 Dockerfile文件来构建镜像，使用一些标准原语来描述要构建的镜像，Dockerfile语法可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010698107/article/details/114991899">容器技术介绍：Docker Dockerfile语法与指令</a>。</p>
<p>可以到dockerhub选择合适的python镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/_/python">https://hub.docker.com/_/python</a></p>
<p>Dockerfile文件内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于Python开发镜像构建</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>.<span class="number">12</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">&quot;flask_demo&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> APP_VERSION latest</span><br><span class="line"><span class="keyword">ARG</span> workpath=/app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换root用户</span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将工作目录切换为workpath</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$workpath</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录（Dockerfile 所在的目录）下的所有内容复制到/app目录下</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pip命令安装依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --trusted-host pypi.python.org -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射1234端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置ENTRYPOINT参数，容器进程为：python app.py</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p><code>FROM</code>指令指定了构建的基础镜像。</p>
<p><code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>等价于<code>docker run &lt;image&gt; python app.py</code>。默认情况下，Docker 会提供一个隐含的 ENTRYPOINT：<code>/bin/sh -c</code>。实际上运行在容器里的完整进程是：<code>/bin/sh -c &quot;python app.py&quot;</code>，即CMD 的内容就是 ENTRYPOINT 的参数。</p>
<h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><p>准备好上述三个文件后，就可以开始制作镜像了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">app.py  Dockerfile  requirements.txt</span><br></pre></td></tr></table></figure>
<p>当前目录执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t flaskdemo .</span><br></pre></td></tr></table></figure>
<p><code>-t</code> 表示给这个镜像加一个 Tag。执行上述命令后，会按照Dockerfile 文件中的原语顺序执行，每个原语都会都会生成一个对应的镜像层。</p>
<p>生成完成后，使用 <code>docker images</code> 命令查看结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls | grep flaskdemo</span><br><span class="line">flaskdemo            latest        6685add6b4e6   4 minutes ago   131MB</span><br></pre></td></tr></table></figure>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>docker run 命令启动容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 8088:1234 flaskdemo</span><br><span class="line"> * Serving Flask app <span class="string">&#x27;app&#x27;</span> (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: This is a development server. Do not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: on</span><br><span class="line"> * Running on all addresses.</span><br><span class="line">   WARNING: This is a development server. Do not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line"> * Running on http://172.17.0.2:1234/ (Press CTRL+C to quit)</span><br><span class="line"> * Restarting with <span class="built_in">stat</span></span><br><span class="line"> * Debugger is active!</span><br><span class="line"> * Debugger PIN: 417-802-482</span><br></pre></td></tr></table></figure>
<p>由于我的docker安装在虚拟机中，在windows物理机访问虚拟机IP地址：<a target="_blank" rel="noopener" href="http://192.168.20.9:8088/">http://192.168.20.9:8088/</a></p>
<p>访问<a target="_blank" rel="noopener" href="http://192.168.20.9:8088/hello">http://192.168.20.9:8088/hello</a></p>
<p><img src="flask-docker-demo.png" width="80%" height="80%" /></p>
<p>进入容器，查看一下目录文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps | grep flaskdemo</span><br><span class="line">3b75f31e42cd   flaskdemo           <span class="string">&quot;python app.py&quot;</span>          4 minutes ago   Up 4 minutes    0.0.0.0:8088-&gt;1234/tcp, :::8088-&gt;1234/tcp   agitated_moore</span><br><span class="line">$ </span><br><span class="line">$ docker <span class="built_in">exec</span> -it 3b75f31e42cd /bin/sh</span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">Dockerfile  app.py  requirements.txt</span><br><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/app</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">Dockerfile  app.py  requirements.txt</span><br></pre></td></tr></table></figure>
<p><code>docker exec</code> 命令可以进入正在运行中的容器，查看正在运行的 flaskdemo 容器的进程号（PID）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> 3b75f31e42cd</span><br><span class="line">3302</span><br></pre></td></tr></table></figure>
<p>查看宿主机的 proc 文件，可以看到PID=3302 的进程的所有 Namespace 对应的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls -l  /proc/3302/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan 18 15:50 ipc -&gt; ipc:[4026532574]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan 18 15:50 mnt -&gt; mnt:[4026532572]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan 18 15:36 net -&gt; net:[4026532680]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan 18 15:50 pid -&gt; pid:[4026532575]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan 18 15:57 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jan 18 15:50 uts -&gt; uts:[4026532573]</span><br></pre></td></tr></table></figure>
<p><code>docker exec</code> 的实现原理是通过加入到某个进程已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的。</p>
<p>Docker 的<code>--net</code> 参数可以让你启动一个容器并“加入”到另一个容器的 Network Namespace 里，比如在<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010698107/article/details/115273174">搭建Prometheus + Grafana的性能监控系统</a>中，使用如下命令启动Prometheus：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name prometheus --network grafana -p 9090:9090 -v /root/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus:latest --config.file=/etc/prometheus/prometheus.yml</span><br></pre></td></tr></table></figure>
<p>将容器prometheus网络加入到了grafana的网络名称空间里。</p>
<h2 id="Docker-commit"><a href="#Docker-commit" class="headerlink" title="Docker commit"></a>Docker commit</h2><p>Docker commit一般用于从一个运行状态的容器提交为一个新的镜像，一般不建议这样做，原因是这样不方便排查问题，可维护性差，Dockerfile的方式更容易排查问题。</p>
<p>Docker commit构建命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit 容器名 新镜像名:tag</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看到这里，你可能对Docker容器有了一个初步的认识。Docker涉及到大量Linux相关技术，本文只是简要介绍了容器相关核心技术。</p>
<p>容器实际上是一个由名称空间、Cgroups 和 联合文件系统三种技术构建出来的，与宿主机隔离的特殊进程（可通过<code>docker inspect --format &#39;&#123;&#123; .State.Pid &#125;&#125;&#39; 容器ID</code> 命令获取容器进程ID）。</p>
<p>一个正在运行的 Linux 容器可以看成两部分：</p>
<ol>
<li>一个容器镜像，是容器的静态视图；</li>
<li>一个由 Namespace+Cgroups技术构成的隔离环境，称为“容器运行时”（Container Runtime），是容器的动态视图。</li>
</ol>
<p>我们不用关心容器运行时，在开发中，只关注容器镜像就可以了，由于它部署方便，得到广大开发者的青睐。而对于复杂的应用或者服务，通常具有大规模的容器集群，容器技术从“容器”快速发展到“容器云”，在云计算领域占有重要地位。因此，容器编排技术非常重要，最具代表性的容器编排工具有 Docker 公司的 Compose+Swarm 组合，以及 Google 与 RedHat 公司共同主导的 Kubernetes 项目。</p>
<p>推荐参考：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://programmer.help/blogs/docker-disk-space-management.html">https://programmer.help/blogs/docker-disk-space-management.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/aufs-driver/">https://docs.docker.com/storage/storagedriver/aufs-driver/</a></p>
</li>
<li><a target="_blank" rel="noopener" href="https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/">https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/</a></li>
<li><a target="_blank" rel="noopener" href="https://testerhome.com/topics/9522">https://testerhome.com/topics/9522</a></li>
<li><a target="_blank" rel="noopener" href="https://testerhome.com/topics/18471">https://testerhome.com/topics/18471</a></li>
</ol>
<center><b>--THE END--<b></center>

<blockquote>
<p>成事不说，遂事不谏，既往不咎。——《论语·八佾》</p>
</blockquote>


    
    
    
	  
	  <div class="post-tags">              
		  <a href="/tags/%E5%AE%B9%E5%99%A8/" rel="tag"><i class="fa fa-tag"></i> 容器</a>              
		  <a href="/tags/docker/" rel="tag"><i class="fa fa-tag"></i> docker</a>              
		  <a href="/tags/PaaS/" rel="tag"><i class="fa fa-tag"></i> PaaS</a>
	  </div>
      <br/>
      <div>
          
              
<div class="my-post-copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>容器技术介绍之docker核心技术概述</a></p>
  <p><span>文章作者:</span>hiyo</a></p>
  <p><span>文章链接:</span><a href="/posts/container-docker-architecture-introduction/" title="容器技术介绍之docker核心技术概述">https://hiyongz.github.io/posts/container-docker-architecture-introduction/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://hiyongz.github.io/posts/container-docker-architecture-introduction/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span>本博客文章除特别声明外，均采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a> 许可协议。转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>

          
      </div>
      </div>
      <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
        <img id="wechat_subscriber_qcode" src="/uploads/wechat.jpg" style="width: 200px; max-width: 100%;">
        <div>关注微信公众号，及时接收最新技术文章！</div>
      </div>
      <footer class="post-footer">        

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/continuous-integration-jenkins-plugin-for-robotframework/" rel="prev" title="Jenkins集成Robot Framework">
      <i class="fa fa-chevron-left"></i> Jenkins集成Robot Framework
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/python-notes-for-getting-function-attribution/" rel="next" title="获取Python函数信息的方法">
      获取Python函数信息的方法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">容器技术发展简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IaaS%E3%80%81PaaS-%E5%92%8C-SaaS"><span class="nav-number">1.1.</span> <span class="nav-text">IaaS、PaaS 和 SaaS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cloud-Foundry"><span class="nav-number">1.2.</span> <span class="nav-text">Cloud Foundry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-%E9%95%9C%E5%83%8F"><span class="nav-number">1.3.</span> <span class="nav-text">Docker 镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92"><span class="nav-number">1.4.</span> <span class="nav-text">容器编排</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="nav-number">2.</span> <span class="nav-text">容器核心技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="nav-number">2.1.</span> <span class="nav-text">名称空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cgroups"><span class="nav-number">2.2.</span> <span class="nav-text">Cgroups</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.3.</span> <span class="nav-text">联合文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bootfs%E5%92%8Crootfs"><span class="nav-number">2.3.1.</span> <span class="nav-text">bootfs和rootfs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">联合文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AuFS%E9%85%8D%E7%BD%AE"><span class="nav-number">2.3.3.</span> <span class="nav-text">AuFS配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.4.</span> <span class="nav-text">docker镜像结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">3.</span> <span class="nav-text">Docker数据卷</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8C%BA%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">容器和虚拟机区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C"><span class="nav-number">5.</span> <span class="nav-text">Docker镜像制作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%BC%96%E5%86%99"><span class="nav-number">5.1.</span> <span class="nav-text">应用编写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99Dockerfile%E6%96%87%E4%BB%B6"><span class="nav-number">5.2.</span> <span class="nav-text">编写Dockerfile文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C"><span class="nav-number">5.3.</span> <span class="nav-text">镜像制作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">5.4.</span> <span class="nav-text">启动容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-commit"><span class="nav-number">5.5.</span> <span class="nav-text">Docker commit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="HiYo"
      src="/images/logo_android-chrome-192x192-wechat.png">
  <p class="site-author-name" itemprop="name">HiYo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">243</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">193</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hiyongz/DevTest-Notes/" title="GitHub → https://github.com/hiyongz/DevTest-Notes/" rel="noopener" target="_blank"><i class="fa fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → /atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HiYo</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:36</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '8KjyhsA4WPYNq9lsLNhA1R17-gzGzoHsz',
      appKey     : 'DbRgPOSj559JVyisJLRhQ42v',
      placeholder: "欢迎留言！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
