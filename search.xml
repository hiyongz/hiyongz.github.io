<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[通货膨胀]]></title>
    <url>%2Fposts%2F%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2-%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%2F</url>
    <content type="text"><![CDATA[通货膨胀指整体物价水平上升，货币贬值、购买力下降。通货膨胀率一般通过居民消费价格指数CPI来反映，今年三月我国的CPI同比上涨0.4%，由于疫情原因，去年3月CPI上涨达到了4.3%，物价飞涨。 由于人民币在贬值，在投资中，我们的收益率至少要跑赢通货膨胀，也就是跑赢CPI，而CPI仅反映的是“必须消费通货膨胀率”，必须消费是日常生活中最基本的、必要的消费品。如果想要更好的生活质量，我们需要跑赢“可选消费通货膨胀率”，比如优质的教育、医疗等资源，由于它们的稀缺性（人多资源少竞争大，比如学区房），它们的价格增长速度远高于CPI。 这些稀缺资源价格的增长速度跟M2广义货币增速有关，货币供应量增加，市场上的钱就多了，物价就会上涨，货币的流入推高了社会稀缺资源的价格上涨。2008年金融危机以来，世界大多数国家大量超发货币，在2010年左右，我国的货币供应在30%左右，并长期保持在两位数，也就是最近几年保持在8%~9%，去年疫情原因又到了10%，相比美国（25%左右），中国控制得比较好，没有大放水。个人估计中国不会再大放水了，会保持M2增速在10%左右，逐渐放缓。 说到美国，2020年美国印钞折合人民币多印了25万亿，而中国虽然只有10%的增速，也印了20万亿左右，仅次于美国，所以去年股市涨的那么厉害就有这方面的原因。 综上，个人觉得，投资收益率要到10%左右才能跑赢通货膨胀，要想财富增值，一是购买抵抗通货膨胀的资产，比如房地产，股票，基金等，另一个就是努力赚钱了，也就是投资人力资产。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>通货膨胀</tag>
        <tag>投资理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间简史]]></title>
    <url>%2Fposts%2F%E6%97%B6%E9%97%B4%E7%AE%80%E5%8F%B2-%E5%93%88%E5%8B%83%E7%BA%A2%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[《时间简史》 - 哈勃红移 1929 年，埃德温 · 哈勃作出了一个具有里程碑意义的观测：不管你往那个方向看，远处的星系正急速地远离我们而去。换言之，宇宙正在膨胀，这意味着，在早先星体相互之间更加靠近。事实上，似乎在大约100亿至200亿年之前的某一时刻，它们刚好在同一地方，所以那时候宇宙的密度无限大。 哈勃的发现暗示存在一个叫做大爆炸的时刻，当时宇宙的尺度无穷小，而且无限紧密。 哈勃红移是宇宙大爆炸和宇宙膨胀理论的直接证据，表明宇宙中的星系正在离我们远去，而且越远的星球离我们远去的速度越快，宇宙像气球一样在膨胀。 什么是红移？当光源远离观测者运动时，观测者观察到的电磁波谱会发生红移（类似于声波的多普勒效应），光波向红端移动，频率降低，波长变长。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>时间简史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记：命令行参数解析]]></title>
    <url>%2Fposts%2Fpython-notes-for-getopt%2F</url>
    <content type="text"><![CDATA[有些时候我们需要通过命令行将参数传递给脚本，C语言中有个getopt()方法，python中也有个类似的命令行参数解析方法getopt()。python也提供了比getopt()更简洁的argparse方法。另外，sys模块也可以实现简单的参数解析，本文将对这3种命令行参数解析方法简要介绍。 sys.argvsys.argv是传入的参数列表，sys.argv[0]是当前python脚本的名称，sys.argv[1]表示第一个参数，以此类推。 1234import sysprint(sys.argv)print(sys.argv[0]) 命令行运行：123$ python test_sys_argv.py 1 2 3[&#x27;test_sys_argv.py&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]test_sys_argv.py可以看到传入的参数通过sys.argv来获取，它就是一个参数列表。 getopt方法python的getopt与C语言的的getopt()函数类似。相比于sys模块，支持长参数和短参数，并对参数解析赋值。但它需要结合sys模块进行参数解析，语法格式如下：1getopt.getopt(args, options, [long_options])短参数为单个英文字母，如果必须赋值需要在后面加英文冒号(:)，长参数一般为字符串(相比短参数，更能说明参数含义)，如果必须赋值需要在后面加等号(=)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445from scapy.all import *import sysclass ArgParser(): # 预处理输入参数 def usage(self): Usage = &quot;&quot;&quot; Usage: python test_getopt.py [OPTION...]\n \n \ Options:\n \ -f, --field \t\t-- 字段\n \ -Y, --display-filter \t-- 条件\n \ -c, --count \t\t-- 计数\n \ -h, --help \t\t-- 帮助信息\n \n\ &quot;&quot;&quot; print(Usage) def arg_parser(self): try: opts, args = getopt.getopt(sys.argv[1:], &quot;f:Y:c:h&quot;, [&quot;field=&quot;,&quot;display-filter=&quot;, &quot;count=&quot;,&quot;return_flag=&quot;, &quot;help&quot;]) except getopt.GetoptError as e: print(e) self.usage() sys.exit() if opts == []: self.usage() sys.exit() for op, value in opts: if op in (&quot;-f&quot;, &quot;--field&quot;): self.filters = value print(f&quot;field: &#123;value&#125;&quot;) elif op in (&quot;-Y&quot;, &quot;--display-filter&quot;): self.display_filter = value print(f&quot;display-filter: &#123;value&#125;&quot;) elif op in (&quot;-c&quot;, &quot;--count&quot;): self.count = int(value) print(f&quot;count: &#123;value&#125;&quot;) elif op in (&#x27;-h&#x27;, &#x27;--help&#x27;): self.usage() sys.exit()if __name__ == &quot;__main__&quot;: arg = ArgParser() arg.arg_parser() 命令行运行：123$ python test_getopt.py -f test -Y hellofield: testdisplay-filter: hello注意：短参数(options)和长参数(long_options)不需要一一对应，可以任意顺序，也可以只有短参数或者只有长参数。 argparse方法argparse模块提供了很多可以设置的参数，例如参数的默认值，帮助消息，参数的数据类型等。argparse类主要包括ArgumentParser、add_argument和parse_args三个方法。 ArgumentParser用于初始化解析器，可设置脚本名，描述信息，帮助信息等 add_argument用于添加参数 parse_args用于解析参数 下面介绍这三个函数的使用方法。 ArgumentParserargparse默认提供了-h | --help参数：1234import argparseparser = argparse.ArgumentParser(description=&quot;脚本描述信息...&quot;)parser.parse_args()命令行运行：1234567$ python test_argparse.py --helpusage: test_argparse.py [-h]脚本描述信息...optional arguments: -h, --help show this help message and exit add_argument下面列出部分参数： name or flags： 参数 action：对参数执行的动作，比如将多个参数放到列表中：action=&#39;append&#39; nargs：关联不同数目的命令行参数到单一动作 default：参数默认值 type：命令行参数应当被转换成的类型 required：此命令行选项是否必须输入 help： 此选项简单描述 下面来添加参数：1234567891011121314import argparseparser = argparse.ArgumentParser(description=&quot;脚本描述信息...&quot;)# 添加参数parser.add_argument(&quot;-f&quot;, &quot;--field&quot;, help = &quot;字段&quot;, action=&#x27;append&#x27;)parser.add_argument(&quot;-Y&quot;, &quot;--display-filter&quot;, help = &quot;条件&quot;, nargs=&#x27;*&#x27;)parser.add_argument(&quot;-c&quot;, &quot;--count&quot;, help = &quot;计数&quot;, type=int, default=2)args = parser.parse_args()print(args)print(f&quot;field: &#123;args.field&#125;&quot;)print(f&quot;display-filter: &#123;args.display_filter&#125;&quot;)print(f&quot;count: &#123;args.count&#125;&quot;)print(f&quot;type(count): &#123;type(args.count)&#125;&quot;) 命令行运行：123456$ python test_argparse.py -f test -f test2 -Y hello worldNamespace(count=2, display_filter=[&#x27;hello&#x27;, &#x27;world&#x27;], field=[&#x27;test&#x27;, &#x27;test2&#x27;])field: [&#x27;test&#x27;, &#x27;test2&#x27;]display-filter: [&#x27;hello&#x27;, &#x27;world&#x27;]count: 2type(count): &lt;class &#x27;int&#x27;&gt; parse_argsparse_args() 方法用于解析参数，在前面的示例代码中使用parse_args方法来提取参数值，对于无效或者错误的参数会打印错误信息和帮助信息： 命令行运行：1234$ python test_argparse.py -F testusage: test_argparse.py [-h] [-f FIELD] [-Y [DISPLAY_FILTER [DISPLAY_FILTER ...]]] [-c COUNT]test_argparse.py: error: unrecognized arguments: -F test 总结本文介绍了Python的三种命令行参数解析方法sys.argv、getopt和argparse，可以根据自己的需要进行选择，getopt和argparse两种方法相比来说，建议选择argparse，代码量更少更简洁。更详细的使用方法参考官方文档： argparse：https://docs.python.org/zh-cn/3/library/argparse.html getopt：https://docs.python.org/zh-cn/3/library/getopt.html sys.argv：https://docs.python.org/zh-cn/3/library/sys.html --THE END--]]></content>
      <categories>
        <category>编程语言</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>getopt</tag>
        <tag>命令行参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法-LeetCode]]></title>
    <url>%2Fposts%2Falgorithm-notes-for-leetcode%2F</url>
    <content type="text"><![CDATA[b63abfd0cc043585c7f59d942442ea6dd67903cc436cee4a3bf5e12f3b31fc56d6c9df7d9edf86588502a884e34f26ba3db27b444f6f56fdc77648e3415a894da9d3e2843ae7ed05ce3ff224e4c5de263ab17cef0982071033f3f7b8e41f2865530e2f41455f0b350e5107be9ea3194d3c34ef4d07443ea9c98ffb6d659bfe7eea25ba660a80f268d8084d39a655338540944c754a2b56b427214d7898a8e506df71949df0023aedda664f99ff08f87dbb00d0e467d0ad9d6aa0cb92f4f1f8f2d2a3d009bea75b31b9b5a12a0607c41ea0aef862deb7ee59e416c75f0fefcd9132d122edffa249924ddb13c730eb6fe11bf99de192251e769baa38803e701234ff82e92f853bdf0519be19d33634191dad6e2c8fedfeda4cfd3df88a0b1e2eb8cce0caafb1894a205b1ecd51d73d8b68bd76e772df9d684fd81ef7cee007bbc390f3476a229edb51efd008bca4d7aa1861db34aa3f4c894f4acfe284f3ad8e052b44ac3e9073229747f51190a6c94302d26b7806cc3259c0d0d81756e62ae7b182b4e859b8b1c068595312449ef76e34debef558fecc0a26104b1e82de03b39e5770007e0fee7467f43704a440bd1fec4d9724009c0006fa73591ce1e75047e66a9c8672590cc3525a7fd564d9195b895fd18ec34d944602d33132d5114bfbd535ad1e75587b307e4c35d626e14c25f07040e5a13a9693dee2502c905e954e06f2200199af84e830035f9512e2777aac2c6b7fd8718defc0975484687c8b19c5481d2bbca4a8bb4fc563689bf3137f19997edc49eabcb34c62ba8959d9a36f7968ef33b22d1826c75b74b177e5eab44f10df9b21bfc74647f8b13e85f7f2c7fde2b4612c98ef926db31c19fd98f7e9bb627574190f0e8cc406e003686e2bd5c0ff4f70c6b30ae3c3728d44e7855130ad0d7f55a9f9bc019afd289f2558ea45d918582de3edab04ce99a24ba8b646b62e57da98cf61bbca08905216c0e822689c634310a675566ab58f35c138e8ff8be2231df421945e3c654c37f9caff031beb2d4585c98459c4f778598cbb9cc6d2cbdf6d98b2de557c6c7fcbc55d2f7f8dcd141fbfb9c3de7946bcc2f72e55fdab7e7d761cd43c9ee81c46501d5559f85a34e851fc839359fa8eda383e7fcb18abfbcc064fe57ce487eae9a98dc1f007028de7db06d59e63947b96ab445d9f7674325c0bd29a8d4426da601d1b0878981c73d9f26e798275741e67029c4815895fc3bebac3a4a81ac56b594f05bc2bf29918a98e2eede4e397a49452c58097e90fd3a20ac2458029fb1566e2169cb57fda23176aa544ad9beae6a2267840d4f8aedd7f07d295f3c9088fe21fb3895588226cc976eb271d4456b28f93f0270abb9fcec6b24fd792f236e68b155e0b0c99b9fc7c41f99ad97a8bc71f55113a90b96116347f41ed998928501920c882a65d0852202a58cb7c749b7c5778fb6177cec7222f0f252754270ce299f4a65ed0e19adae7b89fd58f8614f75865f60ba70468f694f5074ea639a61c40830b4eb2c6cc8aa64c59aa83d8e1b3f77cf9e25c1124123926247755f935252335ac998694cf9a57cfda28169255a1af3c2f6f5b4c940e645a92520d67219c25ae79deb3aed058df7251f7a20595fb5363f91131d54c7e14925ef15a994637d2ebe967b1496d4c7895bf4f04b121fd3853fe6ff71109bf6730bef38ede9edc01560013ad318e1b4a2d4a44d466382579fff4010a1588df024d5107e8c1429a5df9853aafdf564f7fe4065fcfcb1a6f77105e64a70f30b6a8cccd906ca66ffb49a774aed051c3a0e412c67a4c168ef409923880429d4860b1c584de1677cb2d87f366885091f43f4387306a099f9293489b136620eca7e25452aaf22a9c46d4ece741a0fb61f131a3eb39cab9aa5d977ba041876bf7104938e395c610bbc0d3868a004e882dba468257cec15c75088bcabbb118e949b88e34cb0248f0d1758bf4ce34fa96ceae0dd01edd055f3bd42293f0fb0803dca088d37ae9fb0e7b243955c8f679b8c4769c5b16e400c8cb5a0755490542137c3d009f8fc899ff53d4fc4024c7454efee046cee3d8f9abda91fb5652e1437c8ffe7ca2adafd8b5fce3a617e9d46fb6ea07bac171ee8e9d1b341e3e41177a2913fdcb213eb984f1fbe94e8001d954ce85c0b9ab326727d76e3b27eeff10ac113b0c8dd305e9819716d8aa36f63300567cc42f64e8f19373cb34ab75362c3bdcb9b41c1ca0bdf311326200a61129390ed7733d2dd9942b9c260ac43574860cf3174321a6d5f0ff07564616253d3d84d248f384a7a6f1b52cc87e86ba80e47fa1bc1c7db88856c3291b048822ad01b5e38522ab82500f282b6ad4f4c9737a49f358764080b5313bed8e549455387905e0dcf2310481ee0c8239607a03e9c08519d1809c3933e626db96820096843d5c556bdb40d5d313a866521dd687a11d3dafca5d1116a6c6910f64637907c388aa725bd4038f8c5717f3a2e07c0d873052cf1309cd6556f70283f2210727c7051f0bcb56a0b06f16907ba2cd27576ecf41f1c3b2a7839c4512330c6322c2cbf9b0a433c3090bc647dcd50a755361c8e00f59ef8d89e5bcee553c60dfa8234ae48cb2223e255c98557875c72e2fe323cdffc60c34b32b1892a82bbdb8b1858d82d1f7fc1733637af65d35ca93efe936e9c12b87a9b4a80eee1401ebe0e2418b653d62615e4fa6542e7f7db5b92a9e6b0a21b49eb887b1725ed8bd507335755d29dbcdeebc66744783763d1ac78e93860dca9ef09944186ea714de3dab91e2a2217190a785fb04348ea4656df72cca1aa923416d27b24a8560eaba18861f8c419e69b02ca7227722b25d5696c739f424d14cfef1779359a47933e1127a038e5ccc73cdaa2ed87cc244219d90562d633c1f002599f1ef2c8b9983dd7cd6cde43e3ca26c60d98d2891c96cd072435d7dd5a80987885eb6df5a7110bce43672c8dcab41886df9fa4d0cb1328abc731465b87790e284d4557a328d885c28eec7da5e2a14588e1c54693212cf862eed13e01f36182e2bb478685078a7eab38fb861c1a521faf77cd3016eb433ba83c88d55ff34d3140b71780662cb7126eb0d37e0c745de94056ada4d7e44823280c9aa356005709a8f9cb3e801afbf6302e06b1242bfbee9891d7d89a29631438422cf93e07e7d8ca5eddec1bec608f7a44761ed7ab5428c8d8f39c7dbbd70c013a85bc9a4d225bbc25d8c634c1eb891a866e223981b73d752a7f2a10e2c8c3b07f061e9f38cc2adfdcc8b733bee765fb22728af2374db28f909ceba3292a772ae499dd7b02218bc13f847d364cae3df9d256e5f1e9a0ffdcf55f1967d2093e588c9d38167f4dc00ea5f802b11514454294f42f125c1643235ea2d8cee7310cf047df29c94b56d1d7bb0b2e40e54371360454f3ed6808768d8cf6779c584a246460180ec33273826adc1a4d0a77c6112558e5ecb3eea8e832de6344aacb41d57d1d441036424694f1e64a3212befe99ffa798022f0e205e99c7633b144c304e8b646bb238be65b41a07c5a4a07fd837170e242852df4a9c6fc0a79735610d57f1522a0950f239bedec94efa78985d02e36bd17c5de4c861909929268ccf5c99803086667867ff7fed64ac4e5e7a0522e37229605d9853cde79f7e28561460cf5bffe3cd3408bd165a24fb1db63db967dd6b7ea567e9b11bcec851f141a4a3508fc3d79a6748c6872cff445975be097306502d0130b246c6a21cd05998d638a39e7a343eabeb0a3118a0fb02bae43c18ba592c82b9c4de3b7cce5a69aac370c98beec1bf01ab38f5be309a05dfa2fb4f30703552655be05281040be0222d9f073b5bbd9ba3e9fbe06941aa6fdf2e353ef4ff310a53b08ea28d7b0c14238f8f1bf336f8e41507db448760ff74f95ebd869b1d600e549463dc7b4364aba29c59af74e22c9ab695a3add4ea8e63edfa5915db4130ef27144630baf94293e6731855b5c74dce4925d5d4bb16beb7a03b599d3efd9d1e8f29a3cf0382df99563cba35ae8990b21cfba26e72b311db81e3a701358faf1e91f74ccf0cca096fdad6826bec05a1b48065f3ab781c8e1abec6b7f50d75cd9144a010838f270ade907630d38864b10fd115f46376c5e6f21c674da0b0d0740a5008b8e5d3e49ad40ccc023be1bc5c8f590720c4e940fc5500710fab59a2f7e40c3f740c907ef08d02b3d4b09a547b1198ffd179932f9efafe99595244dfe276a4ee37a84769ee8101f92d40391c3515aaa663d465db40fe25b487c0f5d0c82f7a928c775dc10fc20f2e19612f4470f2fc334c3c1860490096dda177b35616eb78198dad770ffdc52e5b863a016b93b3b3f989720ebfc4787f4b7b8d17ddfd636ef13d1cf2a52834596eac8c725ddccdb663e361bfc93382b6c8947a4da157fd3d1cfa8781ac068c7a8519b268d5efb6e5fb2a75eceb855bdf8d74bf96113e6d1409d5fb98657e8c83faf4218e233ff8923d1724ca1a586ceaf7407e1307faf6ee7377b3dba018c423fa5f8668cba05ffade00f59b735ca48e088b7118e2856fbc4e5d35b0f28fe2cf094b78d8e19ea40afc715f3a853097fc896f99e1941ef30dd857f927622e45305522b3fe14b4bdb9c7c6389c0aa3a6264ee89b5925fd42a6d7e2b1d36abe9c7dd5ace62da968d6a84fe6d8e88c777621b70225120a4f7d9d350ee12d211ff08a3586a6c68c216371140482ff48f31406e0a7340ca5601672d03ec1a95989904e797db8d11a63bfb6644232555e348164f1949e9b9c82a826d7d18f11a9cb4f25146f3c12fedbc1e5fdca7405a4e9952d3b59b726c8388700c4aebf5b6baedc6f014a666f7e79f00d0dd613b64e10763478159337126c79573c794c2f1d8c4e6d5c8e5da2d760f8c942d23a2b4b4890d4b0f15c7065ff53d60eebd329004dd7620f870c2c85a73422d586be6ab64fc479cbde175a3802a0303bc74e018fb9db682de51457d500d3f1c7554a3090ba9038341b19e630d71e2b883e209aca7a817e06fe187cee0918b6c828d658217d475f3c99714fc24924c845fb5a2c1bd41823c2e07cbd97cc83b0e029e762171154f01619c0aa05c74c1d1eea79bb9478fe0c7cc0dea47f861e94421affec0566e3850de48a809d0f04133f82b2f81dcedb5d32e03b894f768c487ce5cff85313ce2bc89288b1658dd41bd071f3b10e8ccd4b8b76a05232810c1d26e8fd8e3ff85aa9077bf59d59982128d9d8834a1271da7276a84fca0ec27e5f8edcc5e47cadb5d62b356f7b1f0434aedeb584482c8afe74bb9783865ad9cfc901357dc8a637085ed88ef86c488beb701dd09ed6ce58f40fca2b46b62a282b35966ea2b382f983e0d74a53ce59c8beabfa2b687d0c9358610156eb6ea811b37761bf1e34c41ac25c666012a272a9ddd4805541ac046306026ec6cd65ecf651ea821a6ab0287afc0a79cb3dfa26b093bfc711b3343c82c47b27bc621a77687dce66b1aa9894adff344b1653c5c7c0cd87a6c8b570d7145991b6b6df4697e841486c473ed8afe6346f90d7c2a25da5727c3064b3f66126521c21c88f8e060fa0f0b7b31ac94de60620c293b606215ea16da771d5c71c0b02162880405894cf2599f0fe561aaaa1edb461b6d0e1a0ca00e66b95f18f5131e71a7c0eb6f46e35b78502d9f5be17426b220cb23dacc4dc34f4577a83ee06029c20eca1c948de9103e8dbd25fde6fef4561071271c1f242f08404831931f99527976aedf9cc7f35cf2152acb3b4e8398e05d290ad06e3ad327d071d27783817c56b4dc6755510740903984f863fcbc55ad59ba978a0ac69b5b71c512d41aa3cb162af1e7d6865328ed80853d578cc9b9caf15fa3af39fddf4d1839b956d7dd83c535d8e494189263c0c26d31aec06f49f02d279268f684de021f8c29364ffb020e0f15acd3dad8415c7d91708ef8d353123b0b3426886c5a83300f9bf3021b0891e3bd674e0995ef6a9cb1cb53c8bdc8b37da6a47a606f1648c1fbcaf6d4dfa4525746c10091f0e47cc05878c12d0966098e2d1575297f61bc0ba1a135138b24599d8edd1655e22a5ef4537b98a1d271c276115c0ab4c8920af8f6d4b2716f16c2bf5dcd14fdae6895b7bbcb44e33b011eb3d524cd031d901a9fa6a1b20d1c4b65badd3da4e4f3936259b1327b43494f5f19dd2475751367d775ca4c96563929aa2c315eda8dcd7c33cb25eea20efdc66b5a536d89e5f2c2fe814d3c0d8a76632dd782ebaa601f45b96d4b005969d4ef486513db5c87e65ca2c2b6b67fc2618723d857fd2dd96ced264c19095a8b703cba5b669d5f81bcdc6eda1e6cd0102c46c583af5c7b225ed37362af330c34dc704f7a75ffd864474d5a3d07dcb5e0946425de79c1b90f91273db2104ae3e02e59faa4c724619b48729507d799160674985a3aed082c1f1bbdc7157aff4b24bc3a023b2b0148dea37090d0cb2fc3879f379ef3b2834699dd9d42a085fe3c0deecd099e9e08d00fd442660558ae3e46a4431ce4a152cbd85014088d9fed2c2d00613e598ba970cfc1f9ea34a6f9e4ee0213d603c83b4aab705b4d798ada9639636438f0e29fed10d544d46ce53f9c4d59a6a85ffb31715544d0c69435d7c45c4f7d6b019a6f23e4b597dc5183817fee34d53683b9c0f0ddb68f379afc274cde124f90c96a7d5aef2dd4e94a5f8ba32869484aec30ac3931f38f1daf70fcda486bdeee7edfa7bf9afd0e268f60ed674348b6c294b22ce3d879f5e65db35047f8f8db71250649558a38427d57a7892c27e34262ca911b351249dafb8053ead7dbb86d0a34572e6e920b74276feb5b5d90277b9274f0bdd325157cae7a5db840f3ffbae18a8b11e23dd31f89fed4b8a1d71f6d354478d3b3e2f79cb8f8b5bd0c7a34501effbab6bdb7ecc25f54e9e134d5f5fe3fec889117aa7245f273b11479cb7ae07bc9f27e3419419e7310bb875d7edb6b6b1b667f94d062d01b0e7018b683808c06d6f44017401bea280a5aece0731ec29973554ca30a6db12a59fc978692cdab1b5c32119f07a8401123e56c2ab3e0c9cd69695f4c1d28859c346ce327b608e25dc84eb6603fc678c0f4ebcee5baa66d18484fa59861652103a2f1de153f671ac10043243b5c3767600f4bc6e4cece958715de844d8e045dc88d124e928eaf0fb2a697a4c03f93f5e60802da2dc34b46f9772d936f414a8a25074c6f4793b79cfab12680fc533d1cbf4266c8e67c5658bab0fb6f783b79bb80524b1a3b2e3f02478b5853235c47c7b422196ebba0a721d6c358dba2da254b5b54d26d56c06d8abaf64b0fca25ca8120a303a7e665f904f1f0eeb4740d112562085aa33539687f29d2c9213a77d15ee03b8aba44b646085d03fa7cd24e175bac137e4141711b76f2c9af3de79f9dcf15a6a44eab5db363d40ea297bc07658b0f16aa34327f908ed46bd7f80ce271f96c90e1ea3d338f5185a06486da3623e2fc374a79e710d98c0c120c5d3d2503150973532522d0904dbe5cdcc1839032e366816c2ab0f7a4b75b30b064cafd0c6740de1adfbea2c19991cb4533f5ae263d9594a3fae1e9d40f267615900df1ee4ffc15dd164eff575c35ffe1eec232af868328184c5f37c4361ecd25299ae52ef6b05c51cb55b817aaed4d5e46a445e928e2368f8391f500f791969222db9a41314337eaa11d277a5429e76df16788c147dc00f4f49599c8167dcd74450aabca50ea87e2ebaf6264f6a696475b8ecceb3c122d9465dfc7985c191266a04fca307e6571ce96e2c9ad33dc5892c29c2c72a6cd0707622acfdfab2bbfc8542447e04d0be2b0ef17ccda821ba293c5032ab551e70bb76f1fee4569a6ed66b987457e56e830549008c30d22382a6fbca43e1e784292d289df31f3cf1e75c450ead5ab322ef47b1ecda0f38ce079e1752682d67eef342864cbaf256231c9069dba4b070686a90cb8ab948772227f46d086448c9a87455cb377605623a52ab0687d8d6664b0263ce312a1cb178abcb57356e2aadc38ac686041159d48d588947d230c8757054dd7b1ccb0bba2dfa513f42f3294419aa33c387ca80d39986ab2942d764fac5a659cae4119fb4448a0bdceee680008a956976420f4a029aeea06ce49bfdf98b855ec42d38f645a0c8422e40b9f615e49dd538588d635a316a4a4cc22681e97041fee867c49c98166eec9c26ed3572cc4b1d4654dda3d83f6f07616fb11e5d1cb3ee80816736c4550a9fff60bef5fcb9786d8839b48e6213030b09861133f18a033734b5c3e3cddc98678f459fcc0d8b0448b5710c64f1785c054bb49444450b4f83d489547871db50afff920e61f8a5fea3d53e6c33d1365db89b7b7a1187c216755c5c6ac0929f38db5df7e9e0da360be784ccffab22ab8cd1939d73c3db0d4c018534239f52fb6b3d157a77bfff2d5fae31f637426fd92e1e663a324d5300699255ee8c9d714b35bedaa214e303f72cceb538e9f0242e85f8b8cb5dcfb8726bade12a0de476e69e15b391b699828122a6abd3481038b0a99f9b5c6671230ca23d1923d4080d753c27d7dbdc2979b51b83d956fca66014c24056bd48de957f275ab8ea0239f199d926e4edcf8e006fde22d2a630fe75042825cd97975431c89d5dfa3a62e8b65fb45f52519180b2d6d933ce57f9769df1e50a16deedb894cff898036e884541d061acde84ed59860e80a100c35359c4a859efd3b05f90081f59e3d4f7c3c5a08ae5f09eea7221855b4bde5a4501fd7688044579170cd5a0d63981ff0240bb4441fc0e8f3a0a78c2f9c42ae27d7cb348d0cafa54ff72e924fd9aa594e9346f69317adf96a8350f6b08cb64f8d3656fca85e493c49e7b182fb88d28c8756c15e7d866145529b6fe84d3c868778ffabc77ddd115ec830d1c5787695fb3d3ef5d3c94b923fa90f31fbd3e77db36a7498813524b0e5b0195446cbcd2a7a0b38e2158fe42d3f9a76b02454409157cae022596a2e24848de8f68a077fa6e40c3622b0a0d5c9e2c9c2c25560c6f73e432492fd23fff0933af8dfe2594ae0e8d9bc791887c88f5e57182dd74adf5f7114cb10f3fe958d93ffbdf81c9bc12a7713a602fbd0cb199882aac5157d5acc0d394a127e5727b2b3aec5f5ede427eaa23bcef54d5f006bbf77e7a8683c4233aaea4309bdc79681dc4660304a1c1c825732248eb5669be8b77c3979922f2bfb96b189320e41b3122f3ac70c381fa70d8880160fac3cd6105f1a86d8db87bd7423751a9388c4d14c1a8c2f7f39ef7dc7e03d9ba460788240f6db992750efbad19c59787c08b926beba7c32ddfff01bb92f707743fdd6c22e7217bb6cd6b1981c6e88cd214afbd726a50c383e81e363e805bd3f8bd627efc3ed2b07b638c2a56679cf3d22eccf0687cc3056178fe677c01e29ee648d49d709648638c9ca561f8e8b8708761177b21d984774b2177dc5a657e16252609433cd2b19cf5531ca953e0ff6d0fdcdfd4f3a200d96cf0c55a5e32fda0d6a4a11eb508f95425bcd40e1aaba238f668ae9ff513080a7b559a522dba202a6fe03b7307737fd4d03c958513b3d63564ca4c2fee956473cbac55dfd17c8d67421862cd3293aea7e7277fa6fecb3fcd55f98fa40b18454ee376767d0b00b48ad107c11f3f565ff969bfbec94e55e77b9d9351b6319a49966b5716a254883062288894741e75b264590f8e72a15b92206718352b961d9fe90afbb6806c6c3c195f4e06b72984e17836c04d1bba9e994cb57d0ff8be496ee906091901a130d9b9435ecd89b61ce69e16648922b08f68364fd5ce104d7f3ffe1da192c1fd133daa5f52b06770029e1cd87fb719d5981bb3aab2b553a1699f7a0bd77c6554f76884e67795ac85af0ba86aa9cdc035d4cc4e428d79b56c9369b78ca6c58d8e1774d3217127e721904276d7b2f87ecd1b01653536bc83b237c1e1cbdb8274a38c4c16bfebc59fcc6a9edd9a2eecf6866c12f9e56cead2612d4950fecb3900819725d046d1343bd5e080278f18b5a10dca049d3469b660483d13560f3f808800d63a4516b8ade10437171ffda05f1f35879f7c8c97177c7d8a6633e0a77d7a85faad1a9f407259e5360bd89621100ff678e56e351bf5edead5b2fa3f7205dd748852f64e01b1075173c19d3003efc686d81ee71087f86a1a568b1a13f352da3fbc8577a7826938e6e0f3ad1a53b70ddce6b74fff8b484777f7d3d3cab569f2b162d14a718742329a6a970a8f1a80ecfaca260ccc5752bd2fe9989df6c00a1e20f50c97ecedeadf8782c7816033f2e0168b3c9e678462cfcc6b5f18e0f59e1d8bec89721a974e122cc014a9db1daaf67256542fc50202d7e5e95e87767546da599f851beeea8b59e2cedbb58d5ef4567c026a5c5acbb08e39329e0c89d76f35cfb58b373960a2db10e3d979c3689320e4d7bf5f69c6c8664fa948c6e1576f17881bdeb2a62ec4274ffbdc504a30bd5f2b0133430f7cf37d27cc3a4901a2562ba01472fddc8515c184dc9d4549c767c58070084b5bb8b60a0b63079cd305cce233599f67e9f8a057fc941f3d92067746f8b4bc629f7adaa58f5a30b9df829c27d01306f08212281af8b41072a07e5287136dd0187c2b1b32ef80d52e3936eaf0fd36bbe2d4606a99b908960c711a0e1ce7d59e03fd3d6eafdd6c1fbd419cfdb821b1aee3e9618b2b85d7b9f7ebbd9b6e2bfc6545fa378fb80d86b40288d3be04622077787cc96c56af54e7ad2465981c544b75ddf6cfc7219399859908f7f1c18ab89873fcfa76aa8d5b9fb4730d9af12380f7eb5240470431a0b9171e09d5d1ead80bcb9a0602a5da0dd8e66f294c19fcee3069367efd0941c163cf399498d8ccd1ee2481829615162a158c9a290088371eb839234bbe20ed213bb5f04f892ae25e2d1a79fc160f45f6a8f222a4d11dfe742a8100ebd795389dadbff0d8177b3bca1426ad9f3a71944dbea7f9e4ce6a2a3a52894b7eb53b16a64f1dd2e878c55214c5f720fc16e608c5e58c507d022961b72f11009fe2741393aa16ec335eeb6a51a9aee384c4a82ee4badb9ee601dcba56c7ec2b6e632f553b4d64def16977283133a6bc0ba9d5cfa28caa92b815859e830b931e37aa487010fc8192832f786a2cf74889524cd9e3699ed74f923d8e34a599f4b8bfdb94b26e2304166f04994705111af064b4f37af2e9fed3f45b3f76fdcad0fa20e6e501f262b8fa086262c59b57625d35d52ce104bfbca65233b4cb6e216b546827e126e5a1984aee5bfe7294a345d6403fa18b97aed921548ddee6eb9e7a58e61849fb243e46eb9bdc4f22028fafbda4b179b91309b854072fd356da0225a7d867f0ad3960ae268c4f7e9e6e2727e704c13cb1ca34ab3d79a295302c4986bad221b26c6d55ca03b3527e15813819b978f8bf7481458987829a1ecffd00ce4f064f4808468aec992fde7262311f6b1fe9159147e877dbc00f724265abd06e4a98c393619f124c4fbdcd1e8e3f289a2f2e9412412b36614b92d5989e8072ae286c38dcb2693401cbf5552f31f1a3bf79febdf053360182be21e1f2ab983e879d9efae616846765bc7aaaa8badaea0d796af6343a87f2d5488df606a283ddab5b5dccedd6240767d742ce194610498aeadcd630c2c399c5c2c8259450aba875353121f228c3bdee149b731b51d5ac14b6318bcb6d25b368c67926942340b32da42a5dc6a7d03878dcefa9c4aad766dded2a3738a2890cb498588dd09eeb04ea7f7adf48f412f5bf6090b544031c121601673f4f3032c00e4545ef3bc9cfb6a3242cef6339a93ca46931ef016690a67352eb973cbabb8b870fd5066f2f2cc96d09fab5dea4afd7428333dd658a208e6b57a8630c28f74cea19d5f3d7a042ce3870f4bf008506924aa2bba88a011508ef0fabeeab4663ff4fdb6ec4306793f1c5e6455ea79475f7de55cb329b71138b80813dbf45f85be89c7838751e54b08dba4bddba0eb442eb37574069b500e05268eb72cbe12a14a26a15cbc09cd1a0f6fb214d912681ef82b5bfef08eec864176c777723d7745926f35064a965f3e79456d4d5d15cb533cf2fc2ebdc1825f854ac64baa0ecfe162c56ffb1952225b7e1a4087fcadb04ff2d72203909db4edebcd9493186338b172650b8e5818264784631abb488659e535b118224c8cb640fb929dc00471340d75fe352f2180d02db2380174283ad864c6c54a42acb85eac02a9af056f045c6d2d5486238b6240c4080acd25f7c686df5761e49ae61fa51d7a647408978ffcf4d55570120d96460659ab0adab2f1124b1df6c851ce023ce1eab2d53c71b2112f1b77da639577bcbcedd006643ffc4d8fe32d0aeba9d263a41aa521553083814738f132bb014d85c314ceceb8eeea07eae9bae1870dfabc59b05e1df086de995c3fcb31786d2472cc949f0f3825e29d13b384cb0e94cd026d4d932f322ddac6752f065338152ea48313aedb78e6a24838d63f6e4fec4beb99b7f33cc7edd0b418ab5824e3575b6514d1ab5267f2c33f06b8c455d6bc85e5f925375d3b00176499b3e77cfe2f9e78b7180df644d5dc933824953d39400935b4a1e9d8878e9500bd9148dbb3eaf610d97685e7629feef802a6391789932b42a141e782f9257bbc873b872381e246540c17b7666bb4068a2abc84501c78b2db2cccce366a8fe8d67ac5ad62b1d61845171c53ceb12021402d58be6e065de823609e01045ce42f934635dccb05c4a0cedf47cda08a2e6f0a1098ad64ee06670eb84f2e6afd7c465c1ae778e916bd76372c2f247514aecb740f6a3701ff2fe57e66a8eb7ddf3e1f090ad5980761252132193b3d8652865a6b8fcf49240e8bd5fb1f81a168737216e7cf14c05f61b1a5307f34c1bb810d930c7c7b71f5681f44f87143cfb505b6eecc65a44546c289615b9db2172f9a6b5c0a0d0f99739d498dd246705ad52be27946b8e6e3e6348d95619ec46b6a3967f3e7862820abc66c291c79f220dbb4043232bc0aef884ef7965f5957c3d70d174d0ea6bfbe8af1f9bd19ddda426ae14232cf51c02d71b101c02fb94adbbd47e30b90291b41cd136cc5a4b2657f02af702467b747b8bb5356ab2cb7b1e7926abee5f05f65a5fe96f729d0661f229ef3365023b3b9293e233495af4744f572985bbe6a83ca3ca55286510040d67a838d788bae939a0eddff4387786534a30b046d8cbf71d40c5fb84ae03c451b43697052966bc0160758a25512f546da75ad5fb7918a0476b84e946f3796d8e3ccc5dd99da459c6ec7bf345dd11d826c876afc521154d9fcdfdf7f29bcb201accbd8b8c07a18c7dc9bcd29c3413e4c791b0292f66922b9d7f29e7a2ff08dd16035fc5994c554fd509843e3ee74a92dfd5a75c0b2006c4f132fc5e70af83866d6bd89bbbd673fa22f226f1fc787ad1196693b7e2fc6611537ab162170675973407170b4b0d089ba6e2b07b8b26fea5720977d2680afe47f9f370cfde58f5c2829889bb5540148e027b9af5c2606da5aad4cf06c827b3cecf3f8f498c74304142793a4afb0c8cc525d632279027858373e94f64ef1cba416645f0aaf0a105cd13da5090e4bcf1a58d116beb120c3e5ec2cf598b4398abc1bcc3addc7eca8d5498a03fe239e430b5b6951ce8dec815ff91438aed857be8d17df9456920bac44eeea5a0c56c4743a3261ce49ac6db2223323d091fa498ecea5d678ec78922b1e4fba2a7aeb9f33567270fdffd7db195568120c25dcdca38d6b489a5eb51747eb308092e9a1346046e287a9fc116c3b310132378ef8cba22291243ece681c164acfe402bb191557b83b71ae027a5c37b77470f0c31fd8956136a65ab07f2f44b92d4686e97eb15c5784348ab086f906fdd499c9a2109b5698658fbff6289735303cc9a7f250dabdebb559c76682d1407241eeba9e26c4c52ad913e7dbeb345e99649a151b7d1d576eae50ace05cbb0e23ccea706067beca2e2e6c54a8ed35c967d50979e26f255f315a09dcdbd2cb451e322e1f33f0e57334203c9ee13e585570b69c477361216f5c49efe713cfb50050951f8185c0d747cb7b08f57f5a0011b2a639e969866d38080af7a20189af5646324ee4cfaca5cf6e93175d39d6fe7da5220ee712e4c4ea17346ca44d2ddda7461dd770690dfbf7d4be2e96437aeb1dc9b5d29b718cc98bcd604e250c963b20aaed3251a6c193c871cd50d1444090c67d47780802869f2f3f45cb776ff96e9d3aec42b7aa71bda1825c78e69d789ffbf888a0483d83914c790aac4e6ab64d6dc4b5ac8079e353dd2b59cbe2ac67d66cc0f1e38cd9a7a37306e96a8ee9209b6a086fbf9d1fdf1a4eff6b225ae8990ba3dd1a14fb0fc23158fee89f8d8e30ad7106036414092c8848835bb7417bcd4a5bfeb61aa94bca95c1e796728e97f03e44ccf1e78a4c18dbf60300075d835cb969f1da15ee2b3ffb397e311aa8d2f00bac611c228ee8d314423b42d8827a6c8a838b654ba0913bbea1e7ef2200ece93710c2f298f6e7acad0ecdbf3ab7d81659b0d2ef3a6a96001d26f229225d4aa40c5f19caf00831fcf669bcbc86bee36a4484b0b23364c4d75bab6e6c394431778513c3c9a555448cf03206ab6b46bfe81fb1aa6549a619f3d4774e87bd1174c33f3cdbbbdf23ef2c4ec1eaf42a4d337dfeede40b61906fbf5c196eec6c94d4c6b4a8921dbc5d796d6d448ae80ef0aed80eb4684fc1f3358a5cdd8d4accd26d5b8156a4e04fb3d13308adbbd339ef92a06d88e200ae16184cb89f650263c044048c8ac74d2acc45bea274127a3ec9f1afb04ea980d7373f93feaf724b96b1814056e772162031ef293668cd2ce2214e0f05a5d3bca2f364ab3060653d5dde7b89ed125c8c94180642f0272e70556592de412e99a84fa065836289ea45c7674ea1b5dc1523bad27432ecfc5d7f988a7f529ab3c499bcb0778458058950b47dadcea477bbe61020d6b0adc5b4bf89b44272bba8aec066da11c39a59acbf1eb4333f7733294c7353a75fd44064840a1ccfa0bcd891dde901b62cf65ec0a38a2e8960ea7000e95d75e76715c1882d7baf963bd43c9ab95fda3932604459a74d0d0cb13eb6f50821be1aa333a6304d5a1b2efe7486eedb4923d2536946e0c280101c2c960a9db481630fc17b62288b1e1539de2dfc3ee77b5f73c5217a05ae30c715e47b200fa61141c306dde261fb35d3a6c34982c0612a68b6c65b270434e895afc356808a54c5b1f7c9759290e6d50356f46bd47d30a9c57105933a3a915313086d51067ff42fe05d97cb35d84a2e3dda7351eb291d4d1c79da93e295fff5d88dfa88d34f693241122463f183b5449e50ee86ecc1e2b40b6428e8062580ab4b7fec8f79b3eb911ab5197d0bbe7f94d424d5cacbce53ab6701741af053bb04789be08e3b57d0a744934217115159df075ce1427982ad4620bbfbbdc89d5d3799bf7b6f32958e5d670a9e7a6c47af21f1ec6c66a8f8037d2562ead253b6bd80dd0631ad2d617fbdab767d378afee8b3fb70c5d0d16e1082865a4932c0f019f2648101793cf3dc3b323ba788b257dbf511bc26d67019daa8eb3c6adf3b2b2d1e771523ac2bd38b06d699b06c1ef414a5e3fe76e8daec72377600b5f3b1ec5666e320adc62a5e41818bf7808165ac4ca3585aa065bc70c6eea9b4627fa1b6fa145992c40696f5b4a529df9825229b3810266cd2244fddeefdcf72c3e5062eb159fc8b33fa78879795745ad8369c5cc7fe1a831c553f0b812683484df46ecf40cf7c1c8ed76a6e01b8a62fb794d542be577b8b9ff54dcef9c95365f46dfde350be7ff95b929f983f7de6a2baf44dac8e2faf141ee8d4144d3dac26c3b5550fea956905dd4b8e32d0788d4af7225666f54bd60502c6b0b2bad7a99857cc523568e976276f0fec132d5a4029ff32c4e69845ede86f7a1681592b63de672120a0cc1922606093df872e84cac7e3b478a3b1ebb26c0d6f724d3e62ae05fbec4313f6eee719081a7cae171c52a63f87d6bdcf5eed0bd3033d381cf86e3630128ee81f2112b6325c376d2e1e0f1e31d08910d61f5e09c3d804c443e178e188bc8abb37efbbe9bfba11203bd3633e3e52314fc28f8a6cb106c01ca2a413b18d48515a682b1456c08a5ad1aca08f56997da817c71b22d8b0fb2c12b94749c2bf35de9669591b7e1928c3f11db16e1672513357018e4a257502c2d78cefc0a56b25fa3e569bc7bb25babcbcf5be73360b9a1b395a4c6332379a16ebfb5921606d87e8c207e67276b49f9e2bcc45f35051cfff5558eb84d89823616bbe1a1478051f60356bb88f3297b2c67579abc4ec1da7c4d86ade5dd5551c2616de8c4bd01ed2c439d184b8790fb4dceb068c65fa7964affddfe261cc573ca6455f87e96e27a84098c9747a761d469383dae18becaa4cca38375dd781613a6830fb7bb8ba1091a868a0f28f4fb1056930633dda302893fb8fb5e5f6f0dab26da2d9b57bc20ee6772d560aaaf78be16426ef8b3cca6ce941b744d9242d7b1ef488d1988cbb5839ed8f0308146963c7b08497465982ef97137e83b9477808714fb27c1cced3d87bc11e1314ce265941f550ef4c3f86caa84833d182af7356a5bfdc9f0e93b9de5a449f414c6a69e4d45bc8e64db7ee957f936f52cbde6bbad43faf3d31cf605b1c23c2d3670613cf60e934f71cb29d7f83c4bb903a41749200478d469dd8e41b3cae99cfa1d5ebd9861a3a962752d98a2cdb70e6cc94679673a1dcf879a356796b1bb4a8dc1949807690a445147509233b014ca39b287cb47db432cc67b737318abfc88c8c97fdc769504e5c345b5554be647e8ffbb70e3fb3a83435131fc9263a078c6c0cf5d0cbc881ff775b6a50a30b24316da2d14f67de85c51b71814bc69f68bbe09ef8a51b8aee3b533752cd6289465296c8f75f58a05347c8eff5a28f63d29a59b1ade65078e617fc5b39cee41edc2e1909419475ba4cece7ea60d0c7368b4e62607124b0c08b6e756e10ca699b8b3d9830fbed169c6bc392fff18a56f3dce743624dba8246f3fd315ddc1a9a0cbaa372074f039e71b3b435182134089ea71346dbf6c8c09ba7bc2fda3865e8d9a39634733d1f47e80bb58b57476c35972f58a016b9da67ae5e6fca743373394fed60c3beb27ab7b3c1d3f64e97d5d9bac686f26b0731adaa16842d3f5d683285dc081bf31e306d57d80393edd25cd7973b4e5b16b29f5ca0dbbc5fd861ae9853fd6541c3bb5f6cadcc0a6b25580833ab60e6195209009e790ae33bf54b2011cfc91863bcb48c213fa8e1d39864339d0d91bc55d572048672810ac9a671528dc832170de3445ea44204a54146a5a857523040a17bb8dfef51131eeb3ac946529250b46145a07afb6fa8e08a242548e32e1fc13e43a4c4f3ca87f0448284fc9f2c12ca8ea1c95c10ea83f136c063205a9c95a6de26e466c31e304c713f36f4a23c461e7cdd81d99abd73b968a2c533aea80efe47e83d6879113f1d6862e8431d866ee86c49995d3864c9cadad0dd584eb7e596814d02dd2c804a0a123fe720c7cde7c619fcf6076382e3f9f26c9ce5cdc07b28e6b96868cefc319964386ce83d853641c8d953a6d8ccb15f102e5e1a04f940a44a93758cd1d4ef5308c951a231acfccede38d95e8b10aa8314ab3051ff3df9c1eba9defa537e78b5f12e5a454e4658de3cc0de4670d9178be9fad9e095e730acf79f685473b194bd6eab49496003e3675722f9105c429e987d3d1df850bf077a78bcf87d7d16f70a46bebce31456ed961a5fffbe28e0b04865330365df2748d342f40824752419ec7cdc7c0e4331d321cfeda2f122d8ce4b21cda21c1cb9720214a1e607fc167ea6f86aaac55c204d12b4ff232daf3646264a8bf0ec9990f01ca77e45770796b31e92e4f7bdebabd4663ad3fa93b73cc353c6c5cf616e48a2528dadf4601133446cfb0d4eaca89d40eef00eb9fe7fb01165e9d84de8bfe47d911e4bffcf4b762e81b50b122103c9522710c8ee9cb4471a711d007e4f8defeaa1875c82b8ae9716659c350f30ba44164cc87d18c174b4289da619d08b1d0f0cd0af5c32834b71a0274bb1a7e4839860922e6bf42d40b20af32e7ab9ef8078fbe32de43a119c621947c9dc138bc6d82082307a8251d3eb62445f84d9a353753bdc2bc66de7a59ac1bf48edf262b1f3d67343c2c3735adff2429f68a44a2f5d7997f72db7d1ed3843d938390c1647023ab242481bb4f1fdcac54eb5d11da2761c67ad34b773ed926e745ef80936d901fdd0bb83f28d63b4e5fdc99347d32574ec12b3985ef5de826a7d576688d159fcf653cc6438675b1910a588cb2f2b5f45503e05c495fc3e012b48dcf29cf665375f738847bb0f9ded9628dd9b6b334c4c43db4bbbc2ff0fb85978270e2b4b3dfc57378e91b23c5ea000dad0bc1480191e98206139ad6476ac813d12ad3bc4b59c8201fd346a7d916324cf7d5782e0647d12ebc358e3b865c1bbb1180d3d65e7a0b13ddf8cd6ecfc473846d44e6ec0120f9c7507c3acfe7ccdb873352a898debf38b8e0b5b49471d66b86592b012e88586582d7c383e0cfe9aa0496b7253fd88735148fe6a9d46390b7744bf23e4f5300e85b08bb52bce7babca394e42df12d35a746b3d9e67822fb34727e432d01efe5d2b62bd473b909e0b3a6102e54ae246e792108ed24947ee3c8f60a8870c896954625373aef903acbcbcf8352d6dc18eaf81c9a79cb1f160b3b1eb4b99b8dc543f4f Hey, password is required here.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Windows 快捷键]]></title>
    <url>%2Fposts%2Fwindows-shortcuts%2F</url>
    <content type="text"><![CDATA[windows 快捷键 打开 cmd 当前目录下打开cmd：Windows 文件资源管理器路径栏中输入 cmd 当前目录下打开cmd：在文件夹中，按shift键，点击右键，选择在此处打开cmd user目录下：Windows+r，然后输入cmd 另外，在文件上shift+右键会多出来一个 “复制为路径” 选项 cmd 命令窗口中输入start .会打开处于当前目录的资源管理器cmd 命令窗口按下 F7 可以显示历史命令记录 搜索win + s或直接 win键 打开开始菜单后输入名称快捷搜索打开应用和文件 记事本打开，命令窗口输入：1notepad记事本第一行写上.LOG：关闭时会在最后一行插入编辑时间 文件资源管理器Windows + e：打开文件资源管理器在路径栏输入shell:startup 或者启动 进入启动目录路径栏输入shell:appsfolder 进入应用程序目录 选中文件ALT + 回车 或者 ALT + 双击文件：查看文件属性 应用程序窗口关闭Windows自带的程序窗口 点击右上角的叉关闭 双击窗口左上角的图标关闭 ALT + f4，在桌面按下 ALT + f4会弹出关机菜单 ALT + 空格 + c Windows + ↑↓←→：调整窗口布局 ALT + TAB ：程序窗口切换 Windows + 1234等数字键：按任务栏上的顺序快捷切换窗口 Windows + g打开Xbox便捷工具，比如截屏、录屏 Windows + d：显示桌面或恢复桌面Windows + m：最小化所有窗口Windows + Shift + m：恢复最小化窗口 浏览器清空浏览器缓存：Ctrl+Shift+Delete --THE END--]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Windows cmd命令]]></title>
    <url>%2Fposts%2Fwindows-shell-command%2F</url>
    <content type="text"><![CDATA[本文列出一些常用的 windows cmd命令，使用windows + r键后输入命令或者打开cmd.exe命令提示符输入，其中cmd命令提示符可以通过使用windows + r键后输入cmd打开 杀掉进程123$ taskkill /im chromedriver.exe /f# 或者$ wmic process where name=&quot;chromedriver.exe&quot; call terminate 切换盘符目录切换到其它盘123456789# 方法1C:\Users\10287&gt;d:D:\&gt;# 方法2C:\Users\10287&gt;cd /d d:D:\&gt; 设置windows系统时区参考：https://winaero.com/blog/set-time-zone-windows-10/1234tzutil /l //查看所有可设置时区tzutil /g //查看当前时区tzutil /s &quot;China Standard Time&quot; //设置时区 tzutil /s &quot;China Standard Time_dstoff&quot; //关闭夏令时 打开资源管理器1explorer 关机重启shutdown /? 查看帮助信息关机1234shutdown -s -t 60 # 60s 后关机rononce -p # 15s 后关机shutdown -s -t 0 # 立即关机shutdown -p # 立即关机或者使用wmic命令：1wmic process call create shutdown.exe 重启12shutdown -r -t 60 # 60s 后重启shutdown -r -t 0 # 立即重启休眠1shutdown -h在rononce -p、shutdown -s或者shutdown -r倒计时结束之前执行shutdown -a可以取消关机或者重启操作 按住 shift 并点重启可以使重启后进入 BIOS windows远程管理1mstsc 无法远程复制文件问题： 结束进程rdpclip.exe 重新开启进程：win + r 输入rdpclip.exe windows计算器1calc 打开记事本1notepad 打开控制面板1control 打开剪贴板Win10：windows + v 打开屏幕键盘1osk 服务设置1services.msc 注册表编辑1regedt32 任务管理器1taskmgr 写字板1write 画图板1mspaint 防火墙1firewall.cpl 其它重置 Windows 10 本地帐户密码：https://support.microsoft.com/zh-cn/help/4028457/windows-10-reset-your-local-account-password --THE END--]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 网络管理命令]]></title>
    <url>%2Fposts%2Fwindows-shell-for-networking-management%2F</url>
    <content type="text"><![CDATA[本文列出一些常用的 Windows 网络管理命令。 pingping: 测试网络连接情况 -n：要发送的回显请求数 -t：ping 主机直到中断 -i：生存时间ttl -6：IPv6 1234567891011$ ping 192.168.20.8 -n 3Pinging 192.168.20.8 with 32 bytes of data:Reply from 192.168.20.8: bytes=32 time&lt;1ms TTL=64Reply from 192.168.20.8: bytes=32 time&lt;1ms TTL=64Reply from 192.168.20.8: bytes=32 time&lt;1ms TTL=64Ping statistics for 192.168.20.8: Packets: Sent = 3, Received = 3, Lost = 0 (0% loss),Approximate round trip times in milli-seconds: Minimum = 0ms, Maximum = 0ms, Average = 0ms 网络信息查询netstatnetstat: 协议统计和当前 TCP/IP 网络连接 -t 列出所有tcp连接 -a：显示所有连接和侦听端口 -n：以数字形式显示地址和端口号 -o：显示进程 ID -p proto：显示指定的协议的连接，TCP、UDP、TCPv6 或 UDPv6 -s：显示每个协议的统计。默认情况下，显示IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6的统计信息，可使用-p 选项指定协议。 -e：显示以太网统计。此选项可以与 -s 选项结合使用。 -r：显示路由信息 12345678910111213$ netstat -ano -p tcpActive Connections Proto Local Address Foreign Address State PID TCP 0.0.0.0:21 0.0.0.0:0 LISTENING 4896 TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 1032 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:902 0.0.0.0:0 LISTENING 10388 TCP 0.0.0.0:912 0.0.0.0:0 LISTENING 10388 TCP 0.0.0.0:1080 0.0.0.0:0 LISTENING 11476 TCP 0.0.0.0:2425 0.0.0.0:0 LISTENING 7728 TCP 0.0.0.0:5040 0.0.0.0:0 LISTENING 7940 TCP 0.0.0.0:5357 0.0.0.0:0 LISTENING 4 网卡信息12345$ ipconfig$ ipconfig /all$ netsh interface ipv4 show config$ netsh interface ipv6 show config$ wmic nic list brief 路由配置route add [Destination] mask [netmask] [gw] metric [测量值] -p：添加永久路由 Destination： 指定该路由的网络目标。 mask：当添加一个网络路由时，需要使用网络掩码。 gw：路由数据包通过网关。注意，你指定的网关必须能够达到。 metric：设置路由跳数。 12345# ipv4$ route -p add 23.23.23.0 mask 255.255.255.0 192.168.97.60route delete 23.23.23.0# ipv6$ netsh interface ipv6 add/del route 2001::/64 &quot;Local Area Connection 2&quot; 2001::2 查看路由表123456$ netstat -r$ route print$ route print -4$ route print -6$ netsh interface ipv4 show route$ netsh interface ipv6 show route 禁用启用网卡12345678910$ netsh interface set interface eth0 disabled # 禁用网卡$ netsh interface set interface name=&quot;接口名称&quot; admin=DISABLE$ netsh interface set interface eth0 enabled #启用网卡$ netsh interface set interface name=&quot;接口名称&quot; admin=ENABLE$ netsh interface ipv6 set interface name=&quot;接口名称&quot; disable/enable$ netsh interface show interface #显示接口 通过python脚本自动化控制：12import osos.popen(&#x27;netsh interface set interface name=&quot;接口名称&quot; admin=DISABLE&#x27;) 释放、更新地址123456# ipv4$ ipconfig /release$ ipconfig /renew# ipv6$ ipconfig /release6$ ipconfig /renew6 添加、删除IP地址123456789# ipv4$ netsh interface ip add address &quot;本地连接&quot; 192.168.1.100 255.255.255.0$ netsh interface ip delete address &quot;本地连接&quot; 192.168.1.100## 设置静态IP地址$ netsh interface ip set address name=&quot;eth1&quot; source=static address=192.168.5.125 mask=255.255.255.0# ipv6$ netsh interface ipv6 delete address 本地连接 2001::1$ netsh interface ipv6 add/del address 本地连接 2001::1 --THE END--]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>cmd</tag>
        <tag>wmic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法笔记：数组、链表、栈和队列]]></title>
    <url>%2Fposts%2Falgorithm-notes-for-linear-list%2F</url>
    <content type="text"><![CDATA[从逻辑结构上来说，数组和链表这两种数据结构都属于线性表，从物理存储来看，数组占用一块连续的内存区，而链表在内存中是分散的，由于这种物理结构差异，在对数组和链表进行增删改查操作的时间复杂度不同。栈和队列是特殊的线性表，数组和链表都可以用来实现栈和队列，本文将简要介绍这几种数据结构。 数组-Array数组使用的是连续的内存空间，内存地址是连续的，所以在声明时一般需要申请固定大小的内存空间。对数组元素的访问可以进行随机访问，时间复杂度为O(1)。 链表-Linked List单向链表链表可以在非连续的空间中存储数据，访问效率低。由节点组成，每个节点都包含下一个节点的指针，在进行删除插入操作时修改相应指针就行，所以相比数组，它的插入删除速度很快。单链表链接方向是单向的，访问要从头部顺序读取 双向链表双向链表的每个结点有两个指针，分别指向直接后继和直接前驱节点，对双向链表的访问可以从任何地方开始。 跳表-Skip List跳表只能用于元素有序的情况，也就是链表元素有序。跳表(skip list)对标的是平衡树(AVL Tree)和二分查找，插入、删除和搜索时间复杂度都是O(log n)，其中Redis中的sorted list使用的就是跳表。 跳表其实是对有序的链表进行升维，也就是空间换时间，升维后就会多一维度的信息： 可以看出，这跟二分查找类似，第k级索引结点的个数为n/(2^k)，在跳表中查询任意数据的时间复杂度就是O(logn)，空间复杂度为O(n)。 栈-Stack栈是一种特殊的线性表，在一端进行操作，特点是先进后出(First in Last out，FILO)，或者说后进先出。 主要包括入栈（push）和出栈（pop）两个操作，Python中可以使用append(data)方法实现入栈操作，使用pop()方法实现出栈操作，可参考：https://docs.python.org/3/library/collections.html 队列队列是允许在一端进行插入而在另一端进行删除操作的线性表，特点是先进先出（First in First Out，FIFO）。 在Python中，入队使用append(data)方法实现，出队使用pop(0)。 一种两端都可以进行入队和出队操作的队列称为双端队列，还有一种队列叫优先队列(priority queue)，队列中的元素被赋予优先级，具有最高级先出 （first in, largest out）的特点。 python中的列表和元组列表和元组列表和元组都是有序的，可以存储任意数据类型的集合，支持切片操作，主要区别如下： 列表是动态的，长度可变，可以随意地增加、删减或者改变元素（mutable）。 元组是静态的，长度大小固定，无法增加删减或者改变元素（immutable）。要想改变元组，只能重新开辟一块内存，创建新的元组。 123456789&gt;&gt;&gt; l = [1, 2, 3]&gt;&gt;&gt; l.append(4)&gt;&gt;&gt; l[1, 2, 3, 4]&gt;&gt;&gt; &gt;&gt;&gt; tup = (1, 2, 3)&gt;&gt;&gt; new_tup = tup + (4, )&gt;&gt;&gt; new_tup(1, 2, 3, 4) 由于列表是动态的、可变的，而元组是静态的、不可变的。所以他们的存储方式是有差异的： 123456l = [1, 2, 3]l.__sizeof__()64tup = (1, 2, 3)tup.__sizeof__()48 元组的存储空间，比列表要少 16 字节： 由于列表是动态的，所以它需要存储指针，来指向对应的元素（int 型，8 字节）。 由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。 为了减小每次增加 / 删减操作时空间分配的开销，Python 列表每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加(append()) / 删除(pop())的时间复杂度均为 O(1)。元组长度大小固定，元素不可变，所以存储空间固定。 元组比列表更加轻量级一些，所以元组的性能速度要略优于列表。当然，对于增加、删除或者修改元素，列表的效率更高。在实际应用中，如果存储的数据和数量不变，使用元组更合适。如果存储的数据或数量是可变的，需要随时更新，则使用列表。 常用方法创建列表1234&gt;&gt;&gt; l=[]&gt;&gt;&gt; l = [3, 2, 5, 4, 8, 6]&gt;&gt;&gt; l=list()&gt;&gt;&gt; l=list([3, 2, 5, 4, 8, 6]) list()是一个function call，创建list时会进行一系列参数检查的操作，而[]可以进行直接调用，是一个内置的C函数，下面测试一下他们的性能差异：1234&gt;&gt;&gt; python -m timeit -n 1000000 -r 5 -s &#x27;a=[]&#x27;1000000 loops, best of 5: 6.7 nsec per loop&gt;&gt;&gt; python -m timeit -n 1000000 -r 5 -s &#x27;a=list()&#x27;1000000 loops, best of 5: 7.17 nsec per loop可以发现[]方法的性能更优。 增加元素12345678910111213141516171819# 获取list长度&gt;&gt;&gt; l = [3, 2, 5, 4, 8, 6]&gt;&gt;&gt; len(l)6# 新增元素（末尾添加）&gt;&gt;&gt; l.append(1)&gt;&gt;&gt; l[3, 2, 5, 4, 8, 6, 1]# 新增多个元素（末尾添加）&gt;&gt;&gt; l.extend([9,10,12])&gt;&gt;&gt; l[3, 9, 2, 5, 4, 8, 6, 1, 9, 10, 12]# 在指定位置插入元素&gt;&gt;&gt; l.insert(1, 9)&gt;&gt;&gt; l[3, 9, 2, 5, 4, 8, 6, 1] 删除元素可以使用remove、pop和del方法参删除list中的某个元素1234567891011121314151617181920&gt;&gt;&gt; l = [3, 2, 5, 4, 8, 6]&gt;&gt;&gt; l.remove(3)&gt;&gt;&gt; l[2, 5, 4, 8, 6]&gt;&gt;&gt; l.pop(0) # l.pop()删除最后一个元素2&gt;&gt;&gt; l[5, 4, 8, 6]&gt;&gt;&gt; del l[0]&gt;&gt;&gt; l[4, 8, 6]&gt;&gt;&gt; del l[0:2]&gt;&gt;&gt; l[6]&gt;&gt;&gt; del l&gt;&gt;&gt; lTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;l&#x27; is not defined&gt;&gt;&gt;对于 Python 3.2以后的版本可以使用clear()清空元素：1234&gt;&gt;&gt; l = [3, 2, 5, 4, 8, 6]&gt;&gt;&gt; l.clear()&gt;&gt;&gt; l[] 切片1234567891011121314151617181920212223242526272829303132# 获取list长度&gt;&gt;&gt; l = [3, 2, 5, 4, 8, 6]# 打印最后一个元素&gt;&gt;&gt; l[-1]6# 打印倒数第3个元素&gt;&gt;&gt; l[-3]4# 打印前3个元素&gt;&gt;&gt; l[0:3][3, 2, 5]# 打印后3个元素&gt;&gt;&gt; l[-3:][4, 8, 6]# 倒序输出&gt;&gt;&gt; l[::-1][6, 8, 4, 5, 2, 3]&gt;&gt;&gt; l.reverse()&gt;&gt;&gt; l[6, 8, 4, 5, 2, 3]&gt;&gt;&gt; l = [3, 2, 5, 4, 8, 6]&gt;&gt;&gt; list(reversed(l))[6, 8, 4, 5, 2, 3]# 间隔1个字符输出&gt;&gt;&gt; l[::2][3, 5, 8] 列表推导式列表推导式是Python中比较常用的功能，用于从其他可迭代对象(如元组、字符串、数组、列表等)中创建新的列表。语法格式如下：1newList = [ expression(element) for element in oldList if condition ]比如计算列表中偶数的平方：12345&gt;&gt;&gt; list_num = [3, 4, 6, 2, 5, 8]&gt;&gt;&gt; list_square = [x ** 2 for x in list_num if x % 2 == 0]&gt;&gt;&gt; list_square[16, 36, 4, 64]&gt;&gt;&gt;上面的列表推导式等价于：123456list_num = [3, 4, 6, 2, 5, 8]list_square = []for x in list_num: if x % 2 == 0: list_square.append(x ** 2)&gt;&gt;&gt; 其它方法下面列出操作list的其它内置方法 方法 描述 语法 index() 返回查找元素的索引 list_name.index(element, start, end) count() 返回目标元素的个数 list_name.count(object) sort() 排序，默认升序排列 降序：list_name.sort(reverse=True) sorted() 排序,返回排好序的新列表 sorted(list_name) reverse() 翻转列表 list_name.reverse() reversed() 翻转列表,返回一个倒转后的迭代器 reversed(list_name) reduce() 对可迭代对象(链表、元组等)中元素进行累积 reduce(fun,seq) sum() 求和 sum(iterable, start) max() 求最大值 max(list) min() 求最小值 max(list) enumerate() 返回可迭代对象的下标和值 enumerate(iterable, start=0) filter() 过滤序列 filter(function, iterable) map() 求最大值 max(list) min() 求最小值 max(list) 注意，元组没有内置的reverse() 和 sort()这两个函数 复杂度分析理解了这几个数据结构的特性后，我们可以计算出对他们进行增删改查的算法复杂度了，可参考https://www.bigocheatsheet.com/ ，列出了对各种数据结构操作的时间复杂度和空间复杂度。 参考资料 链表实现代码：https://www.geeksforgeeks.org/implementing-a-linked-list-in-java-using-class/ Java 链表源码：http://developer.classpath.org/doc/java/util/LinkedList-source.html 跳表：https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html https://www.bigocheatsheet.com/ --THE END--]]></content>
      <categories>
        <category>算法</category>
        <category>线性表</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法笔记：时间复杂度和空间复杂度]]></title>
    <url>%2Fposts%2Falgorithm-notes-for-algorithmic-complexity%2F</url>
    <content type="text"><![CDATA[算法复杂度包括空间复杂度和时间复杂度，是衡量算法执行效率的重要指标。为了充分利用计算资源，提高业务处理效率，最有效的一种解决方式就是优化算法。 在介绍空间复杂度和时间复杂度之前先问一个问题：为什么不通过执行代码，然后统计算法执行的时间和占用的内存大小来度量算法执行效率呢？ 答案显而易见，算法执行时间受硬件影响，同一段代码在不同机器上执行时间可能都会不一样。再者，执行时间也受数据影响，比如数据规模，还有比如排序算法中，如果排序数据长度大小相同，但有序度不一样，执行时间也会有很大差别的。 算法复杂度通常用大O表示法（Big O notation），计算算法的渐近复杂度(asymptotic complexity)，表示代码执行所消耗资源（CPU时间和内存）随数据规模增长的变化趋势。 时间复杂度时间复杂度表示为： T(n) = O(f(n)) 代码的执行时间T(n)与每行代码的执行次数n成正比 n表示数据规模的大小 f(n) 表示每行代码执行的次数总和 常见时间复杂度 O(1)：Constant Complexity 常数复杂度 O(log(n))：Logarithmic Complexity 对数复杂度 O(n)：Linear Complexity 线性时间复杂度 O(n^2)：N square Complexity 平方 O(n^3): N cubic Complexity 立方 O(2^n): Exponential Growth 指数 O(n!): Factorial 阶乘 O(1) &lt; O(logn) &lt; O(n) &lt; O(nlog(n)) &lt; O(n^2) &lt; O(n^3) &lt;O(2^n) &lt; O(n!) O(1)：12int n=6;System.out.println(&quot;n=&quot;+n); O(log(n))：123for (int i= 1; i &lt; n; i=i*2) &#123; System.outt.println(&quot;n:&quot;+i) &#125; O(n)：123for (int i= 1; i &lt; n; i++) &#123; System.out.println(&quot;n:&quot;+i); &#125; O(n^2)：12345for (int i= 1; i &lt; n; i++) &#123; for (int j= 1; j &lt; n; j++) &#123; System.out.println(&quot;i=&quot;+i+&quot;j=&quot;+j); &#125; &#125;O(2^n) ：1234int fib(int n) &#123; if (n&lt;2) return n; return fib(n-1) + fib(n-2);&#125; 主定理(Master Theorem)主定理（The Master Theorem）用于计算分治算法的时间复杂度，将规模为 n 的问题转换为 a 个规模为n/b的子问题，其时间复杂度的递归公式为T(n) = a*T(n/b) +f(n)，f(n)是将原问题分解成子问题和将子问题的解合并成原问题的解的时间。 更详细介绍参考： https://en.wikipedia.org/wiki/Mastertheorem(analysis_of_algorithms)) https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AE%9A%E7%90%86 比如二分查找，二叉搜索，归并排序等算法的时间复杂度采用主定理来计算。搜索算法DFS、BFS，图的遍历时间复杂度也为O(N) 空间复杂度空间复杂度度量算法运行过程中临时占用存储空间的大小，可表示为： S(n)=O(f(n)) 代码的执行占用存储空间 S(n)与n成正比 n表示数据规模的大小 f(n) 表示存储单元占用大小 常用的空间复杂度为O(1)、O(n)、 O(n^2)，相比时间复杂度，空间复杂度更简单，比如数组的长度，递归的深度。 --THE END--]]></content>
      <categories>
        <category>算法</category>
        <category>算法复杂度</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jenkins实现hexo博客自动发布]]></title>
    <url>%2Fposts%2Fcontinuous-integration-for-jenkins-blog-build%2F</url>
    <content type="text"><![CDATA[本文介绍使用jenkins来进行自动发送博客，检测博客项目是否有文件增加或者修改，如果有改动就执行本地构建和发布。 前言去年使用hexo搭建了一个个人博客，使用Gitee Pages服务部署。发布博客的步骤一般是这样的：先编辑好文章，放到特定的博客项目目录下，然后本地生成博客静态文件，本地构建完成后进行发布，也就是上传到gitee博客仓库，更新Gitee Pages 服务，这样hexo博客就发布完成了。hexo博客搭建和发布可参考文章：Hexo+Github/Gitee 搭建个人博客。 这个发布过程，开始是进行手动操作，每次编辑好文章后，除了发布到公众号，CSDN博客外，还需要发布到搭建的个人博客上（个人博客搜索自己的文章更方便），Gitee Pages服务与GitHub Pages不同的是，博客push完成后，需要手动更新，GitHub Pages是自动更新，出于人类懒惰的本性（哈哈，是我比较懒），感觉这个过程比较繁琐。然后写了一个自动部署的脚本，这样本次写好文章后，双击运行脚本就会自动进行上面的步骤，脚本执行完成后看一下部署有没有问题就行了，这样比手动操作省事很多。 但是又发现一个问题就是，构建博客的环境在一台笔记本电脑上，但我不在一台电脑上更新博客文章，也就是我在其它电脑上更新文章后，需要到笔记本上pull新的更改，然后进行构建发布，有时候会忘记更新，所以希望实现定期自动更新。什么技术方法可以实现呢？想到了持续集成工具jenkins，它可以实现持续集成和持续交付。本文主要记录一下这个实现过程。 下面先介绍一下使用到的自动化脚本。 自动化脚本检查博客是否更改检查博客是否更改主要包括： 本地仓库是否有文件删除、增加或者修改 是否需要同步远程仓库：博客文章使用github管理，需要检查远程仓库是否有更新 远程仓库是否更新的代码参考了https://stackoverflow.com/questions/3258243/check-if-pull-needed-in-git。 脚本如下：1234567891011121314151617181920212223242526272829303132#!/bin/bashrepo_path=D:\\ProgramWorkspace\\GitHubProject\\GitHub\\hiyong\\source # 本地博客项目地址cd $repo_pathset -e # 告诉bash如果任何语句的执行结果为false则退出UPSTREAM=$&#123;1:-&#x27;@&#123;u&#125;&#x27;&#125;LOCAL=$(git rev-parse @)REMOTE=$(git rev-parse &quot;$UPSTREAM&quot;)BASE=$(git merge-base @ &quot;$UPSTREAM&quot;)if [ $LOCAL = $REMOTE ]; then echo &quot;Up-to-date&quot;elif [ $LOCAL = $BASE ]; then echo &quot;Need to pull&quot; git pull elif [ $REMOTE = $BASE ]; then echo &quot;Need to push&quot; git push fi# 判断本地仓库是否变化if [ -n &quot;$(git status -s | grep _posts)&quot; ];then echo &quot;blog changes&quot; git add -A git commit -m &quot;jenkins update&quot; git push exit 0else echo &quot;no blog changes&quot; exit 1 # 退出，jenkins会显示失败fi1、jenkins中，非零返回就是job失败。2、-n参数：判断该参数是否已被赋值3、git status -s 或者 git status --short ：以精简的方式显示文件状态 ??标记：有新增文件12$ git status -s?? test.txt M标记：有修改过的文件12$ git status -sM testcase_name.txt D标记：本地删除的文件 博客构建部署脚本如果博客有更新，进行本地构建，然后发布。博客构建命令：123hexo cleanhexo ghexo d 更新后的博客需要手动更新Gitee Pages服务，使用selenium实现自动化操作，gitee登录使用cookie认证的方式（cookie的介绍可参考Session、Cookie和Token介绍），python脚本如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import jsonimport timefrom typing import List, Dictfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditionsfrom selenium.webdriver.support.wait import WebDriverWaitimport pytestclass TestGitee: def setup(self): self.driver = webdriver.Chrome(executable_path=&quot;D:/testing_tools/chromedriver88/chromedriver.exe&quot;) self.driver.get(&quot;https://gitee.com/hiyong/hiyong&quot;) self.driver.implicitly_wait(10) def teardown_method(self): # self.driver.quit() pass def test_blog_build(self): print(&quot;登录。。。。。。&quot;) with open(&quot;gitee_cookies.txt&quot;,&#x27;r&#x27;) as f: # cookies = json.load(f) cookies:List[Dict] = json.load(f) for cookie in cookies: if &quot;expiry&quot; in cookie.keys(): cookie.pop(&quot;expiry&quot;) self.driver.add_cookie(cookie) self.driver.refresh() print(&quot;点击服务&quot;) time.sleep(1) # articles = self.driver.find_elements(By.XPATH, &#x27;//*[@class=&quot;article-item-box csdn-tracking-statistics&quot;]//a&#x27;) services = self.driver.find_element(By.XPATH, &#x27;//*[@class=&quot;ui pointing top right dropdown git-project-service&quot;]&#x27;) time.sleep(1) services.click() print(&quot;点击Gitee Ppages&quot;) WebDriverWait(self.driver, 10).until( expected_conditions.visibility_of_element_located((By.XPATH,&#x27;//*[contains(text(),&quot;Gitee Pages&quot;)]&#x27;))) gitee_pages = self.driver.find_element(By.XPATH, &#x27;//*[contains(text(),&quot;Gitee Pages&quot;)]&#x27;) gitee_pages.click() print(&quot;点击更新&quot;) WebDriverWait(self.driver, 10).until( expected_conditions.visibility_of_element_located((By.XPATH, &#x27;//*[@class=&quot;button orange redeploy-button ui update_deploy&quot;]&#x27;))) update = self.driver.find_element(By.XPATH, &#x27;//*[@class=&quot;button orange redeploy-button ui update_deploy&quot;]&#x27;) update.click() alert = self.driver.switch_to.alert print(alert.text) alert.accept() WebDriverWait(self.driver, 10).until( expected_conditions.visibility_of_element_located((By.ID, &#x27;pages_deploying&#x27;))) print(&quot;正在部署，请稍后......&quot;) WebDriverWait(self.driver, 60).until( expected_conditions.invisibility_of_element_located((By.ID, &#x27;pages_deploying&#x27;))) print(&quot;部署成功，请访问：https://hiyong.gitee.io&quot;) self.driver.get(&quot;https://hiyong.gitee.io&quot;) 上面的Python脚本使用pytest执行：1pytest -v -s test_gitee.py::TestGitee::test_blog_build 好了，主要使用到的自动化脚本就介绍完了，下面开始配置jenkins项目 jenkins配置前面介绍过，如果博客有更新就进行自动化部署操作，如果没有更新就不操作。下面介绍一种解决方案，构建两个job，一个用于检查博客是否有更新，另一个用于博客发布，也就是配置Jenkins父子多任务（可参考持续集成平台Jenkins详细介绍），如果有更新就触发博客发布项目，没有就不用触发。 另外再说明一下我的jenkins部署环境，我的jenkins是部署在虚拟机里面的，博客项目部署在物理机，所以物理机为一个节点，Windows节点添加方法参考持续集成平台Jenkins详细介绍。 1. 新建检测博客是否更新项目新建一个名为blog_git_status的job，运行节点为配置的windows节点名称（我的为slave2）。 配置周期触发构建操作，我配置的是每天晚上11点进行构建操作。 添加构建动作Execute shell，将前面写的shell脚本粘贴进去： 2. 新建博客发布项目新建一个名为blog_build_and_publish的job，和blog_git_status一样，运行节点配置为slave2，配置Build Triggers为blog_git_status：添加构建动作Execute windows batch command，输入如下脚本：1cd /d D:\\ProgramWorkspace\\GitHubProject\\GitHub\\hiyong&amp;&amp;hexo clean&amp;&amp;hexo g&amp;&amp;hexo d&amp;&amp;D:\\Anaconda3\\Scripts\\activate.bat&amp;&amp;cd /d D:\\ProgramWorkspace\\TestingDemo\\test_blog&amp;&amp;pytest -v -s test_gitee.py::TestGitee::test_blog_build 可以配置一下Jenkins邮件报警，构建成功或者失败后会发一个文件，这里不介绍了，参考持续集成平台Jenkins详细介绍。 3. 构建运行第一个项目blog_git_status，如果构建成功就会自动触发blog_build_and_publish项目。下图是构建日志： blog_git_status构建成功后，触发第二个项目： blog_build_and_publish项目的构建日志： 总结本文介绍了使用持续集成工具jenkins实现博客的自动发布，构建了两个Job，一个用于检测博客是否更新，另一个用于博客的构建和发布。除了这种方法以外，还可以使用Jenkins的pipeline实现持续发布，就不用创建两个Job了。 --THE END--]]></content>
      <categories>
        <category>测试开发</category>
        <category>持续集成</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session、Cookie和Token介绍]]></title>
    <url>%2Fposts%2Fnetwork-cookies-session-and-token%2F</url>
    <content type="text"><![CDATA[HTTP是一个无状态的面向连接的协议，服务器不知道客户端的状态，比如使用用户名密码认证成功后，在下一次的请求中，服务器不知道用户是谁，如果需要后续服务，需要进行重新认证。然而，在某些场景，我们需要保存某些状态，比如在购物网站进行商品购买时，在某个域名下浏览多个网页，选择多个商品，这种情况下需要保存已加入购物车的商品信息，在需要支付时，也要保存用户认证信息。为了实现保存用户登录状态，可以使用session或者token解决HTTP协议的无状态特性。 session认证session认证过程session用于记录服务器和客户端之间的会话状态，下面以用户认证为例介绍session连接过程： client发送post请求到server端 server端接收到请求并认证通过后建立一个session，HTTP响应中包含Set-Cookie头部（包括了一个sessionId） client再次发送请求时请求头中携带了cookie 服务器根据cookie值来验证client信息（根据sessionId与保存的session进行比较来验证用户身份），并对client进行响应。 cookie与session的区别 cookie是实现session的其中一种方案，session可以基于 cookie，也可以基于 query参数。 cookie存储在客户端，客户端（浏览器）接受服务器的Set -Cookie指令，并把 cookie保存到电脑上。 session存储在服务端，只把关联数据的一个加密串放到 cookie中标记 根据他们的存储位置，session相对来说更加安全。 Token认证Token认证过程Token认证是另外一种常用的身份认证方式，相比session更加安全，比较常用的Token认证方案是JSON Web Token（JWT），是一种基于 JSON 的开放标准（RFC 7519），客户端和服务器之间使用JSON对象进行安全信息传输，信息进行数字签名，可以使用私钥（HMAC算法）或者公钥/私钥对（RSA算法）进行签名。Token认证过程可以简单描述如下： client发送post请求到server端 server端使用秘钥创建JWT并将JWT发送给client client本地保存JWT，client在每次请求的请求头中携带JWT server端验证JWT并响应 在token认证中，可以凭借认证信息生成 token，也可以通过后台配置token，比如配置github的token： 常用的token认证header使用Bearer 模式：Authorization: Bearer &lt;token&gt;，比如Github:1$ curl -H &quot;Authorization: Bearer TOKEN&quot; https://api.github.com/user session与token的区别 token是一个用户请求时附带的请求字段，用于验证身份与权限，不存储在服务器上。 token 安全性比 Session 要好，因为token每一个请求都有数字签名，Session 仅通过sessionId进行简单认证。 大多web应用和移动设备身份验证使用token进行身份认证，android原生系统不支持cookie。 keep-alive现在已经大致了解了session和token这两种认证方式，那么HTML 页面加载流程是什么呢？在开头提到过，HTTP是一个无状态的面向连接的协议，HTTP是应用层协议，TCP协议工作在传输层，在进行认证之前需要进行TCP连接，也就是三次握手。 HTML 页面加载、解析流程大致如下： 浏览器向服务器发起请求，浏览器先查询本地（浏览器或者本机）DNS缓存，如果没有，向DNS 服务器发起 域名解析请求 浏览器拿到域名对应的IP地址后，建立与服务器的 TCP/IP 连接（3次握手，断开连接进行4次挥手） 浏览器向服务器发送 HTTP / HTTPs 请求，服务器进行后台内部处理，进行HTTP响应，返回状态和浏览器请求的内容。session和token认证过程就在这一步完成。 浏览器接收到HTTP数据包后进行解析 解析HTML页面代码，遇到静态资源（js、css、图片等）则向服务器发起请求。 从上到下进行加载、渲染，下载和渲染同时进行 js文件的加载会阻塞HTML内容的加载 CSS样式表下载完成之后会跟之前的样式表一起进行解析，会对之前的元素重新渲染 上面的步骤中提到了静态资源的请求，在HTTP/0.9版本中使用短连接，发送完 HTTP 的响应之后，服务器就会断开 TCP 连接，遇到需要请求资源时，浏览器会重新建立一个HTTP会话，也就是重复第一步。为了节约资源，HTTP/1.0版本新增了 keep-alive 字段（长连接，不过默认还是短连接），HTTP/1.1默认开启长连接。 长连接表示在完成HTTP 请求之后，不断开TCP 连接，这样之后发送 HTTP 请求就不需要重新建立 TCP 连接了。在请求头中加入了Connection: keep-alive 字段，当然，实现长连接需要客户端和服务端都支持，如果不希望使用长连接，在请求头中加上Connection: close。长连接不会永久保持，一般会有一个超时时间，某些服务器还会设置一个最大请求次数，如果超过就断开连接。 --THE END--]]></content>
      <categories>
        <category>计算机网络</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>协议</tag>
        <tag>Session</tag>
        <tag>Cookie</tag>
        <tag>Token</tag>
        <tag>keep-alive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI自动化测试：键盘输入之Android keycode]]></title>
    <url>%2Fposts%2Fselenium-appium-keycode%2F</url>
    <content type="text"><![CDATA[列出UI自动化测试中用到的keycode Android keycodeappium模拟键盘事件表，参考：https://developer.android.com/reference/android/view/KeyEvent.html 12driver.keyevent()driver.press_keycode() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485****************电话键****************KEYCODE_CALL 拨号键 5KEYCODE_ENDCALL 挂机键 6KEYCODE_HOME 按键Home 3KEYCODE_MENU 菜单键 82KEYCODE_BACK 返回键 4KEYCODE_SEARCH 搜索键 84KEYCODE_CAMERA 拍照键 27KEYCODE_FOCUS 拍照对焦键 80KEYCODE_POWER 电源键 26KEYCODE_NOTIFICATION 通知键 83KEYCODE_MUTE 话筒静音键 91KEYCODE_VOLUME_MUTE 扬声器静音键 164KEYCODE_VOLUME_UP 音量增加键 24KEYCODE_VOLUME_DOWN 音量减小键 25 ****************控制键****************KEYCODE_ENTER 回车键 66KEYCODE_ESCAPE ESC键 111KEYCODE_DPAD_CENTER 导航键 确定键 23KEYCODE_DPAD_UP 导航键 向上 19KEYCODE_DPAD_DOWN 导航键 向下 20KEYCODE_DPAD_LEFT 导航键 向左 21KEYCODE_DPAD_RIGHT 导航键 向右 22KEYCODE_MOVE_HOME 光标移动到开始键 122KEYCODE_MOVE_END 光标移动到末尾键 123KEYCODE_PAGE_UP 向上翻页键 92KEYCODE_PAGE_DOWN 向下翻页键 93KEYCODE_DEL 退格键 67KEYCODE_FORWARD_DEL 删除键 112KEYCODE_INSERT 插入键 124KEYCODE_TAB Tab键 61KEYCODE_NUM_LOCK 小键盘锁 143KEYCODE_CAPS_LOCK 大写锁定键 115KEYCODE_BREAK Break/Pause键 121KEYCODE_SCROLL_LOCK 滚动锁定键 116KEYCODE_ZOOM_IN 放大键 168KEYCODE_ZOOM_OUT 缩小键 169 ****************组合键****************KEYCODE_ALT_LEFT Alt+LeftKEYCODE_ALT_RIGHT Alt+RightKEYCODE_CTRL_LEFT Control+LeftKEYCODE_CTRL_RIGHT Control+RightKEYCODE_SHIFT_LEFT Shift+LeftKEYCODE_SHIFT_RIGHT Shift+Right ****************基本****************KEYCODE_0 按键&#x27;0&#x27; 7KEYCODE_1 按键&#x27;1&#x27; 8KEYCODE_2 按键&#x27;2&#x27; 9KEYCODE_3 按键&#x27;3&#x27; 10KEYCODE_4 按键&#x27;4&#x27; 11KEYCODE_5 按键&#x27;5&#x27; 12KEYCODE_6 按键&#x27;6&#x27; 13KEYCODE_7 按键&#x27;7&#x27; 14KEYCODE_8 按键&#x27;8&#x27; 15KEYCODE_9 按键&#x27;9&#x27; 16KEYCODE_A 按键&#x27;A&#x27; 29KEYCODE_B 按键&#x27;B&#x27; 30KEYCODE_C 按键&#x27;C&#x27; 31KEYCODE_D 按键&#x27;D&#x27; 32KEYCODE_E 按键&#x27;E&#x27; 33KEYCODE_F 按键&#x27;F&#x27; 34KEYCODE_G 按键&#x27;G&#x27; 35KEYCODE_H 按键&#x27;H&#x27; 36KEYCODE_I 按键&#x27;I&#x27; 37KEYCODE_J 按键&#x27;J&#x27; 38KEYCODE_K 按键&#x27;K&#x27; 39KEYCODE_L 按键&#x27;L&#x27; 40KEYCODE_M 按键&#x27;M&#x27; 41KEYCODE_N 按键&#x27;N&#x27; 42KEYCODE_O 按键&#x27;O&#x27; 43KEYCODE_P 按键&#x27;P&#x27; 44KEYCODE_Q 按键&#x27;Q&#x27; 45KEYCODE_R 按键&#x27;R&#x27; 46KEYCODE_S 按键&#x27;S&#x27; 47KEYCODE_T 按键&#x27;T&#x27; 48KEYCODE_U 按键&#x27;U&#x27; 49KEYCODE_V 按键&#x27;V&#x27; 50KEYCODE_W 按键&#x27;W&#x27; 51KEYCODE_X 按键&#x27;X&#x27; 52KEYCODE_Y 按键&#x27;Y&#x27; 53KEYCODE_Z 按键&#x27;Z&#x27; 54 键盘 keycodeWeb自动化测试模拟键盘输入12345from selenium.webdriver.common.keys import Keysinput_element=driver.find_element_by_id(&quot;id_name&quot;)input_element.send_keys(Keys.NUMPAD3)input_element.send_keys(Keys.CONTROL, &quot;a&quot;) selenium按键12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667NULL = &#x27;\ue000&#x27;CANCEL = &#x27;\ue001&#x27; # ^breakHELP = &#x27;\ue002&#x27;BACKSPACE = &#x27;\ue003&#x27;BACK_SPACE = BACKSPACETAB = &#x27;\ue004&#x27;CLEAR = &#x27;\ue005&#x27;RETURN = &#x27;\ue006&#x27;ENTER = &#x27;\ue007&#x27;SHIFT = &#x27;\ue008&#x27;LEFT_SHIFT = SHIFTCONTROL = &#x27;\ue009&#x27;LEFT_CONTROL = CONTROLALT = &#x27;\ue00a&#x27;LEFT_ALT = ALTPAUSE = &#x27;\ue00b&#x27;ESCAPE = &#x27;\ue00c&#x27;SPACE = &#x27;\ue00d&#x27;PAGE_UP = &#x27;\ue00e&#x27;PAGE_DOWN = &#x27;\ue00f&#x27;END = &#x27;\ue010&#x27;HOME = &#x27;\ue011&#x27;LEFT = &#x27;\ue012&#x27;ARROW_LEFT = LEFTUP = &#x27;\ue013&#x27;ARROW_UP = UPRIGHT = &#x27;\ue014&#x27;ARROW_RIGHT = RIGHTDOWN = &#x27;\ue015&#x27;ARROW_DOWN = DOWNINSERT = &#x27;\ue016&#x27;DELETE = &#x27;\ue017&#x27;SEMICOLON = &#x27;\ue018&#x27;EQUALS = &#x27;\ue019&#x27;NUMPAD0 = &#x27;\ue01a&#x27; # number pad keysNUMPAD1 = &#x27;\ue01b&#x27;NUMPAD2 = &#x27;\ue01c&#x27;NUMPAD3 = &#x27;\ue01d&#x27;NUMPAD4 = &#x27;\ue01e&#x27;NUMPAD5 = &#x27;\ue01f&#x27;NUMPAD6 = &#x27;\ue020&#x27;NUMPAD7 = &#x27;\ue021&#x27;NUMPAD8 = &#x27;\ue022&#x27;NUMPAD9 = &#x27;\ue023&#x27;MULTIPLY = &#x27;\ue024&#x27;ADD = &#x27;\ue025&#x27;SEPARATOR = &#x27;\ue026&#x27;SUBTRACT = &#x27;\ue027&#x27;DECIMAL = &#x27;\ue028&#x27;DIVIDE = &#x27;\ue029&#x27;F1 = &#x27;\ue031&#x27; # function keysF2 = &#x27;\ue032&#x27;F3 = &#x27;\ue033&#x27;F4 = &#x27;\ue034&#x27;F5 = &#x27;\ue035&#x27;F6 = &#x27;\ue036&#x27;F7 = &#x27;\ue037&#x27;F8 = &#x27;\ue038&#x27;F9 = &#x27;\ue039&#x27;F10 = &#x27;\ue03a&#x27;F11 = &#x27;\ue03b&#x27;F12 = &#x27;\ue03c&#x27;META = &#x27;\ue03d&#x27;COMMAND = &#x27;\ue03d&#x27; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115vbKeyLButton 1 鼠标左键 vbKeyRButton 2 鼠标右键 vbKeyCancel 3 CANCEL 键 vbKeyMButton 4 鼠标中键 vbKeyBack 8 BACKSPACE 键 vbKeyTab 9 TAB 键 vbKeyClear 12 CLEAR 键 vbKeyReturn 13 ENTER 键 vbKeyShift 16 SHIFT 键 vbKeyControl 17 CTRL 键 vbKeyMenu 18 菜单键 vbKeyPause 19 PAUSE 键 vbKeyCapital 20 CAPS LOCK 键 vbKeyEscape 27 ESC 键 vbKeySpace 32 SPACEBAR 键 vbKeyPageUp 33 PAGEUP 键 vbKeyPageDown 34 PAGEDOWN 键 vbKeyEnd 35 END 键 vbKeyHome 36 HOME 键 vbKeyLeft 37 LEFT ARROW 键 vbKeyUp 38 UP ARROW 键 vbKeyRight 39 RIGHT ARROW 键 vbKeyDown 40 DOWN ARROW 键 vbKeySelect 41 SELECT 键 vbKeyPrint 42 PRINT SCREEN 键 vbKeyExecute 43 EXECUTE 键 vbKeySnapshot 44 SNAP SHOT 键 vbKeyInser 45 INS 键 vbKeyDelete 46 DEL 键 vbKeyHelp 47 HELP 键 vbKeyNumlock 144 NUM LOCK 键 A 键到 Z 键与其 ASCII 码的相应值&#x27;A&#x27; 到 &#x27;Z&#x27; 是一致的常数 值 描述 vbKeyA 65 A 键 vbKeyB 66 B 键 vbKeyC 67 C 键 vbKeyD 68 D 键 vbKeyE 69 E 键 vbKeyF 70 F 键 vbKeyG 71 G 键 vbKeyH 72 H 键 vbKeyI 73 I 键 vbKeyJ 74 J 键 vbKeyK 75 K 键 vbKeyL 76 L 键 vbKeyM 77 M 键 vbKeyN 78 N 键 vbKeyO 79 O 键 vbKeyP 80 P 键 vbKeyQ 81 Q 键 vbKeyR 82 R 键 vbKeyS 83 S 键 vbKeyT 84 T 键 vbKeyU 85 U 键 vbKeyV 86 V 键 vbKeyW 87 W 键 vbKeyX 88 X 键 vbKeyY 89 Y 键 vbKeyZ 90 Z 键 0 键到 9 键与其 ASCII 码的相应值 &#x27;0&#x27; 到 &#x27;9&#x27; 是一致的常数 值 描述 vbKey0 48 0 键 vbKey1 49 1 键 vbKey2 50 2 键 vbKey3 51 3 键 vbKey4 52 4 键 vbKey5 53 5 键 vbKey6 54 6 键 vbKey7 55 7 键 vbKey8 56 8 键 vbKey9 57 9 键 数字小键盘上的键常数 值 描述 vbKeyNumpad0 96 0 键 vbKeyNumpad1 97 1 键 vbKeyNumpad2 98 2 键 vbKeyNumpad3 99 3 键 vbKeyNumpad4 100 4 键 vbKeyNumpad5 101 5 键 vbKeyNumpad6 102 6 键 vbKeyNumpad7 103 7 键 vbKeyNumpad8 104 8 键 vbKeyNumpad9 105 9 键 vbKeyMultiply 106 乘号 (*) 键 vbKeyAdd 107 加号 (+) 键 vbKeySeparator 108 ENTER 键（在数字小键盘上） vbKeySubtract 109 减号 (-) 键 vbKeyDecimal 110 小数点 (.) 键 vbKeyDivide 111 除号 (/) 键 功能键常数 值 描述 vbKeyF1 112 F1 键 vbKeyF2 113 F2 键 vbKeyF3 114 F3 键 vbKeyF4 115 F4 键 vbKeyF5 116 F5 键 vbKeyF6 117 F6 键 vbKeyF7 118 F7 键 vbKeyF8 119 F8 键 vbKeyF9 120 F9 键 vbKeyF10 121 F10 键 vbKeyF11 122 F11 键 vbKeyF12 123 F12 键 vbKeyF13 124 F13 键 vbKeyF14 125 F14 键 vbKeyF15 126 F15 键 vbKeyF16 127 F16 键 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>selenium</tag>
        <tag>keycode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium Grid：在多个主机上并行执行自动化脚本]]></title>
    <url>%2Fposts%2Fselenium-grid-for-parallel-execute-script%2F</url>
    <content type="text"><![CDATA[Selenium Grid是selenium提供的一个分布式测试工具，将自动化脚本发布到多个物理机或者虚拟机（跨平台、跨浏览器）上执行，通过一个中心节点来控制多个设备，也就是在中心节点（hub）上运行测试，在其它节点（node）上执行，实现selenium的并行执行。除了可以在多个设备上运行测试脚本以外，也可以实现多浏览器兼容性测试。它本身不提供多线程并发执行，需要结合多进程技术实现并行执行用例。 Selenium Grid架构Selenium Grid由hub节点和若干个node代理节点组成 https://www.selenium.dev/docs/site/en/grid/components_of_a_grid/ hub作为管理节点，用来管理各个代理节点的注册和状态信息，并且接收远程客户端代码请求调用，然后把请求的命令再转发给代理代点来执行。每个Selenium Grid仅包含一个hub，hub连接多个节点（node），node就是浏览器所在的位置，注册到hub，接收hub的请求并执行测试。 Selenium Grid使用注意hub主机和远程主机需要安装java环境和selenium框架。 1. 下载下载Selenium Server，下载地址：https://www.selenium.dev/downloads/ 2. 启动hubwindows打开命令终端，输入如下命令：1234567$ java -jar selenium-server-standalone-3.141.59.jar -role hub21:07:10.738 INFO [GridLauncherV3.parse] - Selenium server version: 3.141.59, revision: e82be7d35821:07:10.844 INFO [GridLauncherV3.lambda$buildLaunchers$5] - Launching Selenium Grid hub on port 44442021-04-06 21:07:11.265:INFO::main: Logging initialized @987ms to org.seleniumhq.jetty9.util.log.StdErrLog21:07:12.104 INFO [Hub.start] - Selenium Grid hub is up and running21:07:12.108 INFO [Hub.start] - Nodes should register to http://192.168.2.103:4444/grid/register/21:07:12.108 INFO [Hub.start] - Clients should connect to http://192.168.2.103:4444/wd/hub默认情况下，启动4444端口，可以使用-port设置启动端口。 也可以浏览器打开http://localhost:4444/grid/console， 查看hub是否启动成功: 根据打印的日志可以看到主机的IP地址为192.168.2.103，node需要注册到地址http://192.168.2.103:4444/grid/register/ 3. 启动node先编写配置文件chrome_node.json，参考https://github.com/SeleniumHQ/selenium/blob/selenium-3.141.59/java/server/src/org/openqa/grid/common/defaults/DefaultNodeWebDriver.json1234567891011121314151617181920212223242526&#123; &quot;capabilities&quot;: [ &#123; &quot;browserName&quot;: &quot;chrome&quot;, &quot;maxInstances&quot;: 5, &quot;seleniumProtocol&quot;: &quot;WebDriver&quot; &#125; ], &quot;proxy&quot;: &quot;org.openqa.grid.selenium.proxy.DefaultRemoteProxy&quot;, &quot;maxSession&quot;: 5, &quot;port&quot;: -1, &quot;register&quot;: true, &quot;registerCycle&quot;: 5000, &quot;hub&quot;: &quot;http://localhost:4444&quot;, &quot;nodeStatusCheckTimeout&quot;: 5000, &quot;nodePolling&quot;: 5000, &quot;role&quot;: &quot;node&quot;, &quot;unregisterIfStillDownAfter&quot;: 60000, &quot;downPollingLimit&quot;: 2, &quot;debug&quot;: false, &quot;servlets&quot; : [], &quot;withoutServlets&quot;: [], &quot;custom&quot;: &#123;&#125;&#125;配置文件firefox_node.json1234567891011121314151617181920212223242526&#123; &quot;capabilities&quot;: [ &#123; &quot;browserName&quot;: &quot;firefox&quot;, &quot;maxInstances&quot;: 5, &quot;seleniumProtocol&quot;: &quot;WebDriver&quot; &#125; ], &quot;proxy&quot;: &quot;org.openqa.grid.selenium.proxy.DefaultRemoteProxy&quot;, &quot;maxSession&quot;: 5, &quot;port&quot;: -1, &quot;register&quot;: true, &quot;registerCycle&quot;: 5000, &quot;hub&quot;: &quot;http://localhost:4444&quot;, &quot;nodeStatusCheckTimeout&quot;: 5000, &quot;nodePolling&quot;: 5000, &quot;role&quot;: &quot;node&quot;, &quot;unregisterIfStillDownAfter&quot;: 60000, &quot;downPollingLimit&quot;: 2, &quot;debug&quot;: false, &quot;servlets&quot; : [], &quot;withoutServlets&quot;: [], &quot;custom&quot;: &#123;&#125;&#125; 在本机启动一个node，将节点注册到http://192.168.2.103:4444/grid/register ，新打开一个命令终端，启动chrome节点，输入如下命令：1$ java -Dwebdriver.chrome.driver=D:\\testing_tools\\chromedriver89\\chromedriver.exe -jar selenium-server-standalone-3.141.59.jar -role node -nodeConfig chrome_node.json 启动一个firefox节点：1$ java -Dwebdriver.gecko.driver=D:\\testing_tools\\firefoxdriver\\geckodriver.exe -jar selenium-server-standalone-3.141.59.jar -role node -nodeConfig firefox_node.json 也可以其它设备上（比如虚拟机，注意hub主机与远程node主机之间可以相互ping通）上启动一个node：1$ java -jar selenium-server-standalone-3.141.59.jar -role node -hub http://192.168.2.103:4444/grid/register刷新浏览器：http://localhost:4444/grid/console 发现三个节点注册成功！ 4. 示例脚本串行执行12345678910111213from selenium.webdriver import Remotefrom selenium.webdriver import DesiredCapabilities@pytest.mark.parametrize(&quot;node&quot;, [&quot;firefox&quot;,&quot;chrome&quot;])def test_grid(self,node): if node == &quot;firefox&quot;: capability = DesiredCapabilities.FIREFOX.copy() elif node == &quot;chrome&quot;: capability = DesiredCapabilities.CHROME.copy() self.driver = Remote(command_executor=&quot;http://localhost:4444/wd/hub&quot;, desired_capabilities=capability) self.driver.get(&quot;https://www.baidu.com/&quot;) pytest执行：1pytest test_grid.py::TestGrid::test_grid 并行执行采用多线程分布并行执行，以下示例脚本执行环境为在hub节点主机（windows）上启动了firefox和chrome两个节点。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python3#-*-coding:utf-8-*-import threadingimport timeimport pytestfrom selenium import webdriverfrom selenium.webdriver import DesiredCapabilitiesfrom selenium.webdriver import Remotefrom selenium.webdriver.common.by import Byclass TestGrid: def node_drivers(self,node): if node == &quot;firefox&quot;: capability = DesiredCapabilities.FIREFOX.copy() driver_firefox = Remote(command_executor=&quot;http://localhost:4444/wd/hub&quot;, desired_capabilities=capability) self.test_baidu(driver_firefox) elif node == &quot;chrome&quot;: capability = DesiredCapabilities.CHROME.copy() driver_chrome = Remote(command_executor=&quot;http://localhost:4444/wd/hub&quot;, desired_capabilities=capability) self.test_qq(driver_chrome) def test_baidu(self,driver): driver.get(&quot;https://www.baidu.com/&quot;) ele = driver.find_element(By.ID, &#x27;kw&#x27;) ele.send_keys(&quot;test&quot;) time.sleep(2) driver.find_element(By.ID, &#x27;su&#x27;).click() time.sleep(2) def test_qq(self,driver): driver.get(&quot;https://www.qq.com/&quot;) ele = driver.find_element(By.ID, &#x27;sougouTxt&#x27;) ele.send_keys(&quot;qq&quot;) time.sleep(2) driver.find_element(By.ID, &#x27;searchBtn&#x27;).click() time.sleep(2) def test_parallel(self): node_list = [&quot;firefox&quot;,&quot;chrome&quot;] thread_list = [] for browser in node_list: t = threading.Thread(target=self.node_drivers, args=(browser,)) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join()pytest执行：1pytest test_grid.py::TestGrid::test_parallel对于hub主机上的不同浏览器，command_executor可以直接设置hub的地址，grid会根据浏览器名称来找到节点。 另外，也可以在同一个主机上启动多个相同浏览器的节点，下面在hub节点主机（windows）上启动两个节点，都使用chrome浏览器。12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/python3#-*-coding:utf-8-*-import threadingimport timeimport pytestfrom selenium import webdriverfrom selenium.webdriver import DesiredCapabilitiesfrom selenium.webdriver import Remotefrom selenium.webdriver.common.by import Byclass TestGrid: def setup(self): self.nodes = &#123;&quot;node1&quot;:&quot;http://192.168.2.103:9984/wd/hub&quot;,&quot;node2&quot;:&quot;http://192.168.2.103:1537/wd/hub&quot;&#125; def node_drivers(self,node): capability = DesiredCapabilities.CHROME.copy() if node == &quot;node1&quot;: driver_node1 = Remote(command_executor=self.nodes[node], desired_capabilities=capability) self.test_baidu(driver_node1) elif node == &quot;node2&quot;: driver_node2 = Remote(command_executor=self.nodes[node], desired_capabilities=capability) self.test_qq(driver_node2) def test_parallel(self): node_list = [&quot;node1&quot;,&quot;node2&quot;] thread_list = [] for browser in node_list: t = threading.Thread(target=self.node_drivers, args=(browser,)) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join() pytest执行：1pytest test_grid.py::TestGrid::test_parallel 由于节点都在同一台主机上，节点IP地址相同，启用的端口号不同。端口号可以在启动节点的时候使用-port参数指定，或者在节点的json配置文件中指定，如果不指定端口，需要在节点的json配置文件中设置&quot;port&quot;: -1，这样会随机指定端口，然后你可以在拉起节点的日志中查看端口号，或者在管理页面http://localhost:4444/grid/console 中查看。 参考资料 https://www.selenium.dev/docs/site/en/grid/ https://github.com/SeleniumHQ/selenium https://github.com/SeleniumHQ/selenium/wiki/Grid2 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netdiscover网络扫描工具]]></title>
    <url>%2Fposts%2Fapi-test-security-testing-netdiscover-tool%2F</url>
    <content type="text"><![CDATA[Netdiscover是一种网络扫描工具，通过ARP扫描发现活动主机，可以通过主动和被动两种模式进行ARP扫描。通过主动发送ARP请求检查网络ARP流量，通过自动扫描模式扫描网络地址。本文介绍Netdiscover的安装和使用方法。 Netdiscover安装Kali Linux提供的网络扫描工具github地址：https://github.com/alexxy/netdiscover ubuntu:1$ sudo apt install netdiscover安装完成后查看帮助信息：12345678910111213141516171819202122$ netdiscover -hNetdiscover 0.5.1 [Active/passive ARP reconnaissance tool]Written by: Jaime Penalba &lt;jpenalbae@gmail.com&gt;Usage: netdiscover [-i device] [-r range | -l file | -p] [-m file] [-F filter] [-s time] [-c count] [-n node] [-dfPLNS] -i device: your network device -r range: scan a given range instead of auto scan. 192.168.6.0/24,/16,/8 -l file: scan the list of ranges contained into the given file -p passive mode: do not send anything, only sniff -m file: scan a list of known MACs and host names -F filter: customize pcap filter expression (default: &quot;arp&quot;) -s time: time to sleep between each ARP request (milliseconds) -c count: number of times to send each ARP request (for nets with packet loss) -n node: last source IP octet used for scanning (from 2 to 253) -d ignore home config files for autoscan and fast mode -f enable fastmode scan, saves a lot of time, recommended for auto -P print results in a format suitable for parsing by another program and stop after active scan -L similar to -P but continue listening after the active scan is completed -N Do not print header. Only valid when -P or -L is enabled. -S enable sleep time suppression between each request (hardcore mode)If -r, -l or -p are not enabled, netdiscover will scan for common LAN addresses Netdiscover选项 选项 说明 -i device 网络接口 -r range 扫描范围，例如192.168.0.0/24，仅支持/8, /16和/24 -l file 扫描范围列表文件，每行一个范围 -p 被动模式：不发生任何报文，仅嗅探 -m file 扫描已知Mac地址和主机名的列表文件 -F filter 自定义pcap filter表达式(默认“arp”) -s time 每个ARP请求间的休眠时间(毫秒,默认1ms) -c count 发送每个ARP请求的次数，用于丢失数据包的网络，默认1次 -n node 扫描最后的源IP，默认为67(x.x.x.67),允许范围为2-253 -d 忽略自动扫描和快速模式的主配置文件,扫描默认的范围和IP -f 启用快速模式扫描,扫描每个网段的.1、.100 和 .254 -P 产生输出到文件或者其他解析程序，扫描完成后退出，例如：`netdiscover -P -r 192.168.20.0/16 grep 192.168.20.100` -L 与-P类似，但在主动扫描后继续捕获ARP包 -N 不打印表头，仅在-P 或者-L启用时有效 -S 已弃用 Netdiscover使用用法如果未启用被动模式（-p）、扫描列表（-l）或扫描范围（-r）选项，netdiscover将扫描LAN地址（192.168.0.0/16、172.16.0.0/12和10.0.0.0/8）。 扫描结果控制键：h：显示帮助信息1$ netdiscover -i ens38 -p q：退出帮助信息界面，或者退出扫描（或者Ctrl+c退出）j：向下滚动（或者使用下方向箭头）k：向上滚动（或者使用上方向箭头）.：向上翻页,：向下翻页 扫描结果视图：a：显示ARP响应列表 r：显示ARP请求列表 u：显示检测到的唯一主机 使用实例扫描指定接口：1$ netdiscover -i ens38 快速扫描：1$ netdiscover -i ens38 -f扫描指定范围：1$ netdiscover -i ens38 -r 192.168.0.0/16 被动扫描，仅嗅探：1$ netdiscover -i ens38 -r 192.168.0.0/16 -p --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>渗透测试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Netdiscover</tag>
        <tag>网络扫描</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytest插件开发]]></title>
    <url>%2Fposts%2Fpytest-plugin%2F</url>
    <content type="text"><![CDATA[Pytest测试框架功能非常多，它其实就是由一组插件组成的，具有大量的插件，可以通过插件来扩展、定制功能，能满足大部分的测试需求。本文介绍pytest插件的开发方法，帮助更好的理解pytest测试框架。 pytest插件介绍pytest的三种插件pytest插件通过hook函数来实现，pytest主要包括以下三种插件 内置插件：pytest内部的_pytest目录中加载：\Lib\site-packages\_pytest\hookspec.py 外部插件：pip install 插件，通过setuptools的Entry points机制来发现外部插件，可用插件列表：https://docs.pytest.org/en/latest/reference/plugin_list.html 本地插件：conftest.py插件，pytest自动模块发现机制，在项目根目录下的conftest文件起到全局作用，在项目下的子目录中的conftest.py文件作用范围只能在该层级及以下目录生效。 他们的加载顺序为： 内置插件 外部插件 本地插件 pytest的hook函数hook函数(钩子函数)是程序中预留的函数（相当于暴露了一个钩子），如果我们需要在程序某个步骤执行某个操作，我们就直接重写特定的钩子函数（挂载到钩子上），这样就实现了我们要增加的功能。没有挂载或者注册钩子时，它就是空的，也就是没有执行任何操作。 Pytest 的hook函数可查看\Lib\site-packages\_pytest\hookspec.py 文件， Pytest hook函数的执行顺序如下(https://github.com/pytest-dev/pytest/issues/3261)：12345678910111213141516171819202122232425262728293031323334353637root└── pytest_cmdline_main ├── pytest_plugin_registered ├── pytest_configure │ └── pytest_plugin_registered ├── pytest_sessionstart │ ├── pytest_plugin_registered │ └── pytest_report_header ├── pytest_collection │ ├── pytest_collectstart │ ├── pytest_make_collect_report │ │ ├── pytest_collect_file │ │ │ └── pytest_pycollect_makemodule │ │ └── pytest_pycollect_makeitem │ │ └── pytest_generate_tests │ │ └── pytest_make_parametrize_id │ ├── pytest_collectreport │ ├── pytest_itemcollected │ ├── pytest_collection_modifyitems │ └── pytest_collection_finish │ └── pytest_report_collectionfinish ├── pytest_runtestloop │ └── pytest_runtest_protocol │ ├── pytest_runtest_logstart │ ├── pytest_runtest_setup │ │ └── pytest_fixture_setup │ ├── pytest_runtest_makereport │ ├── pytest_runtest_logreport │ │ └── pytest_report_teststatus │ ├── pytest_runtest_call │ │ └── pytest_pyfunc_call │ ├── pytest_runtest_teardown │ │ └── pytest_fixture_post_finalizer │ └── pytest_runtest_logfinish ├── pytest_sessionfinish │ └── pytest_terminal_summary └── pytest_unconfigure 我们可以对上面的hook函数进行改写，实现某些功能。我在以前的pytest文章中（Pytest测试框架（三）：pytest fixture 用法）介绍了fixture 插件的用法，fixture实现的功能其实也对pytest的hook函数进行了改写，比如pytest_generate_tests，pytest_sessionstart等hook函数，大家如果感兴趣可以查看源码：\Lib\site-packages\_pytest\fixtures.py pluggy插件系统前面简要介绍了pytest插件，这些插件是怎么管理的呢？pytest的大量插件使用pluggy进行管理，pluggy是pytest使用的一个插件系统，用于pytest插件的管理和钩子调用。也就是说，pluggy使pytest具有了钩子功能，实现主机（主程序）与插件的连接。 pytest插件：中文编码先写一个测试用例test_hook.py:1234567#!/usr/bin/python3#-*-coding:utf-8-*-import pytest@pytest.mark.parametrize(&quot;name&quot;,[&quot;张三&quot;,&quot;李四&quot;])def test_name(name): print(name)执行：1$ pytest -vs test_hook.py::test_name结果（只截取部分）：12345test_hook.py::test_name[\u5f20\u4e09] 张三PASSEDtest_hook.py::test_name[\u674e\u56db] 李四PASSED我们发现用例名字编码格式为Unicode，无法显示中文。 怎么解决呢？我们可以对pytest hook函数pytest_collection_modifyitems()进行重写：12345678910def pytest_collection_modifyitems( session: &quot;Session&quot;, config: &quot;Config&quot;, items: List[&quot;Item&quot;]) -&gt; None: &quot;&quot;&quot; called after collection has been performed, may filter or re-order the items in-place. :param _pytest.main.Session session: the pytest session object :param _pytest.config.Config config: pytest config object :param List[_pytest.nodes.Item] items: list of item objects &quot;&quot;&quot;根据注释我们知道这个hook函数在用例收集完成后进行调用，可对用例进行过滤或者重新排序（修改用例执行顺序的pytest-ordering插件就修改了这个hook函数） 接下来开始修改这个hook函数，对用例名进行解码并反转用例顺序，在测试用例同级目录下新建conftest.py函数，修改代码如下：12345678910#!/usr/bin/python3#-*-coding:utf-8-*-from typing import Listdef pytest_collection_modifyitems(session, config, items: List): for item in items: item.name = item.name.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode-escape&#x27;) item._nodeid = item.nodeid.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode-escape&#x27;) items.reverse()items就是收集到的测试用例，可对它进行各种操作。 再次执行：1$ pytest -vs test_hook.py::test_name结果（只截取部分）：1234test_hook.py::test_name[李四] 李四PASSEDtest_hook.py::test_name[张三] 张三PASSED解码成功，并且顺序反转了。 添加命令行参数通过改写hook函数pytest_addoption()可以实现添加自定义的命令行参数，几乎每个pytest 插件都会使用这个hook方法。下面在conftest.py中改写pytest_addoption()方法：12345678# 添加一个命令行参数def pytest_addoption(parser, pluginmanager): mygroup = parser.getgroup(&quot;testgroup&quot;) #group将下面所有的 optiongroup都展示在这个group下。 mygroup.addoption(&quot;--env&quot;, #注册一个命令行选项 default=&#x27;test&#x27;, # 参数的默认值 dest = &#x27;env&#x27;, # 存储的变量 help = &#x27;set your run env&#x27; #帮助提示参数的描述信息 ) 然后我们在命令行中输入pytest -h，在打印的帮助信息中，我们可以看到添加的自定义参数：12testgroup: --env=ENV set your run env 接下来获取这个参数，在conftest.py中添加如下代码：12345678910111213@pytest.fixture(scope=&#x27;session&#x27;)def cmdoption(request): env = request.config.getoption(&quot;--env&quot;, default=&#x27;test&#x27;) if env == &quot;test&quot;: print(&quot;test环境&quot;) datapath = &quot;data/test/data.yml&quot; if env == &quot;develop&quot;: print(&quot;开发环境&quot;) datapath = &quot;data/develop/data.yml&quot; with open(datapath) as f: datas = yaml.safe_load(f) return env,datas 测试数据： 编写测试用例：123456def test_env(cmdoption): env,datas = cmdoption host = datas[&#x27;env&#x27;][&#x27;host&#x27;] port = datas[&#x27;env&#x27;][&#x27;port&#x27;] url = str(host) + &quot;:&quot; + str(port) print(url)执行测试用例：1$ pytest -vs test_hook.py::test_env结果（只截取部分）：123test_hook.py::test_env test环境http://192.168.11.1:4567PASSED传递参数：1$ pytest -vs --env develop test_hook.py::test_env结果（只截取部分）：123test_hook.py::test_env 开发环境http://192.168.0.1:1234PASSED传递成功 打包发布你的Python插件开发完成后，可以对它进行打包发布，方便给别人使用，打包后也可以发布代码到到PyPI上，可参考Python打包文档：https://packaging.python.org/tutorials/packaging-projects/ ，下面介绍Python打包过程。 1、创建包文件12345678pytest-encode/├── LICENSE├── README.md├── setup.py├── pytest_encode/│ └── __init__.py└──tests/ └── test_encode.py setup.py是一个构建脚本：1234567891011121314151617181920212223242526272829303132333435363738import setuptoolssetuptools.setup( name=&quot;pytest-encode&quot;, # Replace with your own username version=&quot;0.0.1&quot;, author=&quot;hiyongz&quot;, author_email=&quot;zhiyo2016@163.com@example.com&quot;, description=&quot;set your encoding&quot;, long_description=&quot;show Chinese for your mark.parametrize().&quot;, url=&quot;https://github.com/pypa/sampleproject&quot;, project_urls=&#123; &quot;Bug Tracker&quot;: &quot;https://github.com/pypa/sampleproject/issues&quot;, &#125;, classifiers=[ &quot;Programming Language :: Python :: 3&quot;, &quot;Framework :: Pytest&quot;, &quot;Topic :: Software Develoment :: Testing&quot;, ], license=&#x27;MIT License&#x27;, packages=[&#x27;pytest_encode&#x27;], keywords=[ &quot;pytest&quot;, &quot;py.test&quot;, &quot;pytest_encode&quot;, ], install_requires=[ &#x27;pytest&#x27; ], python_requires=&quot;&gt;=3.6&quot;, # 入口模块或者入口函数 entry_points=&#123; &#x27;pytest11&#x27;:[ &#x27;pytest-encode = pytest_encode&#x27; ] &#125;, zip_safe=False,) 其中依赖包可以通过如下命令生成：1$ pip freeze &gt;requirements.txt entry_points为入口函数，使用pluggy插件中PluginManager类的load_setuptools_entrypoints方法加载，其中pytest11为入口点，这是官方定义的固定入口点，用于发现插件，参考https://docs.pytest.org/en/latest/how-to/writing_plugins.html __init__.py：12345678910111213141516171819202122232425262728import loggingfrom typing import Listimport pytestlogging.basicConfig(level=logging.INFO, # 日志格式 # 时间、代码所在文件名、代码行号、日志级别名字、日志信息 format=&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;, # 打印日志的时间 datefmt=&#x27;%a, %d %b %Y %H:%M:%S&#x27;, # 日志文件存放的目录（目录必须存在）及日志文件名 filename=&#x27;report.log&#x27;, # 打开日志文件的方式 filemode=&#x27;w&#x27; )logger = logging.getLogger(__name__)def pytest_collection_modifyitems(session, config, items: List): for item in items: item.name = item.name.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode-escape&#x27;) item._nodeid = item.nodeid.encode(&#x27;utf-8&#x27;).decode(&#x27;unicode-escape&#x27;) # 添加login标签 # pytest -vs -m login test_hook.py if &#x27;login&#x27; in item.nodeid: item.add_marker(pytest.mark.login) items.reverse() 2、打包打包需要安装两个库： wheel：pip install wheel setuptools：pip install setuptools 进入包目录（pytest-encode）下，执行目录：1$ python setup.py sdist bdist_wheel命令执行完成后，新生成如下文件：1234567891011121314151617pytest-encode/├── build/ ├── bdist.win-amd64 └── lib └── pytest_encode └── __init__.py├── dist/ ├── pytest-encode-0.0.1.tar.gz └── pytest_encode-0.0.1-py3-none-any.whl └──pytest_encode.egg-info/ ├── dependency_links.txt ├── entry_points.txt ├── not-zip-safe ├── PKG-INFO ├── requires.txt ├── SOURCES.txt └── test_encode.pypytest-encode-0.0.1.tar.gz为源码包，pytest_encode-0.0.1-py3-none-any.whl可以通过pip install命令安装 3、测试打包文件我们新建一个Python虚拟环境，在新的虚拟环境下执行：12345$ pip listPackage Version---------- -------pip 21.0.1setuptools 54.2.0只安装了两个包，下面安装刚才生成的包文件：1$ pip install pytest_encode-0.0.1-py3-none-any.whl它会自动安装setup.py中定义的依赖包。 然后在新的虚拟环境中编写测试用例并执行：1234567import pytestfrom pytest_encode import logger@pytest.mark.parametrize(&quot;name&quot;,[&quot;张三&quot;,&quot;李四&quot;])def test_name(name): logger.info(&quot;测试编码&quot;) print(name) 1$ pytest -vs test_encode.py::test_name 结果（只截取部分）：1234test_hook.py::test_name[李四] 李四PASSEDtest_hook.py::test_name[张三] 张三PASSED解码成功，并且生成了日志文件：report.log：12Sat, 03 Apr 2021 20:21:45 test_encode.py[line:13] INFO 测试编码Sat, 03 Apr 2021 20:21:45 test_encode.py[line:13] INFO 测试编码表明安装的包生效了。 4、发布包使用Twine来上传包到PyPI，需要注册一个PyPI账号 然后安装twine:1$ pip install twine上传：1$ twine upload --repository test-encode dist/*上传过程中会让你输入前面注册的用户名和密码，上传成功后就可以在PyPI上查看 参考资料 https://docs.pytest.org/en/latest/how-to/writing_plugins.html https://docs.pytest.org/en/stable/reference.html?#hooks https://docs.pytest.org/en/stable/_modules/_pytest/hookspec.html#pytest_cmdline_parse https://github.com/pytest-dev/pytest/issues/3261 https://packaging.python.org/tutorials/packaging-projects/ pytest-ordering：https://github.com/ftobia/pytest-ordering pluggy：https://pluggy.readthedocs.io/en/latest/]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试框架</category>
      </categories>
      <tags>
        <tag>pytest</tag>
        <tag>pytest插件</tag>
        <tag>hook函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法笔记：递归、动态规划]]></title>
    <url>%2Fposts%2Falgorithm-notes-for-dynamic-programming%2F</url>
    <content type="text"><![CDATA[动态规划是求解决策过程最优化的过程，可以高效求解那些可以分解为高度重复子问题的问题，应用非常广泛，比如解决最短路线、NLP等实际问题。 递归、分治和动态规划德罗斯特效应德罗斯特效应（Droste effect）是递归艺术中的一种表现形式，德罗斯特效应即在一幅图像中，某个局部图像与整体图像类似，而在这个局部中，又有更小的部分与这个局部类似，依次类推且可无限重复。 德罗斯特（Droste）可可粉的包装盒 德罗斯特是荷兰的一个著名巧克力品牌，创立于1863年，上面这张图片从1904年起开始使用，数十年间只进行了一些小幅的调整，后来成为一个家喻户晓的概念。诗人及专栏作家Nico Scheepmaker在七十年代起，开始使用“德罗斯特效应”此一词语。下面介绍动态规划算法。 递归、分治和动态规划迭代和递归的区别 迭代是将输出作为输入，再次进行处理。 递归，自己调用自己，自己包含自己。 分治 分治（ Divide &amp;Conquer ）是将问题分解为若干个子问题（Divide），递归求解这些子问题（Conquer），然后合并子问题的解。 动态规划动态规划（Dynamic Programming）和分治策略类似，也是将原问题分解为若干子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。（维基百科：动态规划） 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量。动态规划、递归和分治没有根本上的区别，解法都是先找到重复的子问题，也就是将问题拆解成可重复解决的问题。 解法递归问题解法： 找到重复子问题 确定递归终止条件 对于动态规划问题，每个子问题只求解一次，注意将其结果保存起来，进行记忆化存储。 斐波那契数斐波那契数列LeetCode地址：https://leetcode-cn.com/problems/fibonacci-number/ 解法1：暴力递归123456789101112class Solution: def fib(self, n): if n &lt;= 0: return 0 elif n == 1: return 1 else: return self.fib(n - 1) + self.fib(n - 2)if __name__ == &quot;__main__&quot;: solu = Solution() result = solu.fib(6) print(result) 结果：18 时间复杂度：O(2^N)空间复杂度：O(N) 如果数比较大，2^N的时间复杂度将会占用大量资源，计算非常慢。其实暴力递归计算过程中，进行了大量重复计算，我们来看一下Fib(6)的状态树： 我们发现f(4)计算了2次，f(3)计算了3次，其实没必要重复计算，可以使用记忆化存储来保存计算值。 解法2：记忆化存储12345678910111213class Solution: def fib(self, n): cash = &#123;0:0,1:1&#125; def memoize(n): if n in cash: return cash[n] cash[n] = memoize(n - 1) + memoize(n - 2) return cash[n] return memoize(n)if __name__ == &quot;__main__&quot;: solu = Solution() result = solu.fib(6) print(result) 时间复杂度：O(N)空间复杂度：O(N) 解法3：动态规划12345678910111213class Solution: def fib(self, n): if n &lt;= 1: return n dp = [0, 1] + [0]*(n-1) for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[i] if __name__ == &quot;__main__&quot;: solu = Solution() result = solu.fib(6) print(result) 时间复杂度：O(N)空间复杂度：O(N) 解法4：自底向上迭代可以进一步减少空间复杂度1234567891011121314class Solution: def fib(self, n): if n &lt;= 1: return n a, b = 0, 1 for _ in range(1, n): c = a + b a, b = b, c return c if __name__ == &quot;__main__&quot;: solu = Solution() result = solu.fib(6) print(result)时间复杂度：O(N)空间复杂度：O(1) --THE END--]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>递归</tag>
        <tag>fibonacci</tag>
        <tag>斐波那契数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hydra暴力破解工具]]></title>
    <url>%2Fposts%2Fapi-test-security-testing-hydra-tool%2F</url>
    <content type="text"><![CDATA[Hydra是一款暴力破解工具，进行并行登录破解，破解远程服务的用户名密码，由黑客组织THC开发，它可以对超过50个协议进行快速字典攻击，包括telnet、ftp、http(s)、smb、MySQL、SMTP等。 Hydra安装官方github地址：https://github.com/vanhauser-thc/thc-hydraKali Linux中自带Hydra，下面介绍其它系统安装方法。 Ubuntu安装1$ apt-get install hydra centos系统安装1、下载地址：https://github.com/vanhauser-thc/thc-hydra/releases/tag/v9.2 2、安装依赖 1$ yum install openssl-devel pcre-devel ncpfs-devel postgresql-devel libssh-devel subversion-devel libncurses-devel 3、编译安装 12345$ tar zxf thc-hydra-9.2.tar.gz$ cd thc-hydra-9.2$ ./configure$ make$ make install 查看帮助信息：12345678hydra -hHydra v9.2 (c) 2021 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Syntax: hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [-m MODULE_OPT] [service://server[:PORT][/OPT]]Options: -R restore a previous aborted/crashed session.............. windows安装GitHub地址：https://github.com/maaaaz/thc-hydra-windows下载发布版本，解压就可以使用了 Hydra参数说明 选项 说明 -R 继续上一次破解 -I 忽略现有还原文件（不等待10秒） -s PORT 指定默认端口 -l LOGIN 指定破解登录用户名 -L FILE 使用文件指定多个用户名 -p PASS 指定密码 -P FILE 指定密码字典 -x MIN:MAX:CHARSET 密码暴力生成 -y 禁止在暴力破解中使用符号 -r 对选项-x使用非随机方法 -e nsr n：空密码试探，s：使用指定用户和密码试探。 -u 循环用户 -C FILE 冒号分隔用户名密码：”login:pass” 格式 -M FILE 要攻击的服务器列表，每行一个条目，’:’指定端口 -o FILE 将找到的登录/密码写入文件 -b FORMAT 指定-o输出格式，默认text,可选json, jsonv1 -f / -F 找到用户名/密码后中止破解，-f:每个主机，-F：所有 -t TASKS 每个主机并行线程数，默认16 -T TASKS 所有并行线程数，默认64 -w / -W TIME 最大等待响应时间 -c TIME 所有进程每次尝试登录等待时间 -4 / -6 IPv4(默认)/IPv6地址 -v / -V / -d 详细日志模式/每次尝试仅显示用户名密码/调试模式 -k 不重做失败的尝试（适用于-M批量扫描） -q 不要打印错误连接消息 -U 服务模块详细使用信息 server 目标服务名称或IP地址(也可以使用-M参数) service 要破解的服务 OPT 可选项 支持的服务包括：adam6500, asterisk, cisco, cisco-enable, cvs, ftp, http-{head|get|post}, http-{get|post}-form, http-proxy, http-proxy-urlenum, icq, imap, irc, ldap2, ldap3[s], mssql, mysql(v4), nntp, pcanywhere, pcnfs, pop3, redis, rexec, rlogin, rpcap, rsh, rtsp, s7-300, smb, smtp, smtp-enum, snmp, socks5, teamspeak, telnet, vmauthd, vnc, xmpp Hydra使用实例手动创建用户名字典和密码字典1234567891011121314$ cat user.txt adminroottestzhyhaha$ cat pwd.txt admintest123456666666zhy12345678$ 破解ssh使用单个用户名密码12345678910$ hydra 192.168.20.9 ssh -l root -p 12345678ydra v9.0 (c) 2019 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-03-21 23:41:45[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4[DATA] max 1 task per 1 server, overall 1 task, 1 login try (l:1/p:1), ~1 try per task[DATA] attacking ssh://192.168.20.9:22/[22][ssh] host: 192.168.20.9 login: root password: 123456781 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2021-03-21 23:41:46上面的结果提示推荐使用-t 4，默认并发数为16 使用密码字典123456789101112$ hydra 192.168.20.9 ssh -L user.txt -P pwd.txt -t 4 -e nshydra ssh://192.168.20.9 -L user.txt -P pwd.txt -t 4 -e ns -fHydra v9.0 (c) 2019 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-03-21 23:50:05[DATA] max 4 tasks per 1 server, overall 4 tasks, 40 login tries (l:5/p:8), ~10 tries per task[DATA] attacking ssh://192.168.20.9:22/[22][ssh] host: 192.168.20.9 login: root password: 123456781 of 1 target successfully completed, 1 valid password found[WARNING] Writing restore file because 1 final worker threads did not complete until end.[ERROR] 0 targets did not completeHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2021-03-21 23:50:23-e ns参数：尝试空密码 破解ftp/telnet与ssh类似12$ hydra 192.168.20.9 ftp -L user.txt -P pwd.txt -t 4$ hydra 192.168.20.9 telnet -L user.txt -P pwd.txt -t 4 破解MySQL数据库123456789101112$ hydra -L user.txt -P pwd.txt -t 4 127.0.0.1 mysql$ hydra -L user.txt -P pwd.txt -t 4 mysql://127.0.0.1:3306Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-03-22 15:55:50[DATA] max 4 tasks per 1 server, overall 4 tasks, 30 login tries (l:5/p:6), ~8 tries per task[DATA] attacking mysql://127.0.0.1:3306/[3306][mysql] host: 127.0.0.1 login: admin password: admin[3306][mysql] host: 127.0.0.1 login: root password: 1234561 of 1 target successfully completed, 2 valid passwords foundHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2021-03-22 15:55:51 ssh、ftp、telnet和mysql协议也可以使用nmap工具破解：nmap暴力破解脚本：https://nmap.org/nsedoc/categories/brute.html123$ nmap --script ftp-brute -p 21 &lt;host&gt;$ nmap --script ssh-brute -p 22 &lt;host&gt;$ nmap --script mysql-brute -p 3306 &lt;host&gt; 批量破解多个主机：-M参数创建主机字典：123$ cat host.txt192.168.20.8192.168.20.9 1234567891011121314$ hydra -L user.txt -P pwd.txt -t 4 -M host.txt -f sshHydra v9.0 (c) 2019 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2021-03-21 23:59:03[DATA] max 4 tasks per 2 servers, overall 8 tasks, 30 login tries (l:5/p:6), ~8 tries per task[DATA] attacking ssh://(2 targets):22/[22][ssh] host: 192.168.20.9 login: root password: 12345678[22][ssh] host: 192.168.20.8 login: root password: 123456782 of 2 targets successfully completed, 2 valid passwords found[WARNING] Writing restore file because 4 final worker threads did not complete until end.[ERROR] 4 targets did not resolve or could not be connected[ERROR] 0 targets did not completeHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2021-03-21 23:59:17 将破解日志保存到文件中：1$ hydra -L user.txt -P pwd.txt -t 4 -vV -M host.txt -o results.log ssh --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
        <tag>hydra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统性能监控：Prometheus + Grafana 监控服务器性能]]></title>
    <url>%2Fposts%2Fperformance-monitoring-for-server-with-prometheus%2F</url>
    <content type="text"><![CDATA[Prometheus 是一个开源的服务监控系统和时间序列数据库，是一款开源系统监控和警报工具，在测试领域中，我们可以使用Promethues来监控压力测试时服务端的性能。 Prometheus简介Prometheus使用Go语言开发，是最初在SoundCloud上构建的开源系统监控和警报工具，在2016年加入了Cloud Native Computing Foundation（CNCF）基金会，是继Kubernetes之后该基金会的第二个托管项目。 主要特性 多维数据模型，由指标名称和键值对标识的时间序列数据度量 PromQL查询语言 不依赖分布式存储；单个服务器节点是自治的 通过HTTP使用pull模式收集时间序列数据 支持通过中间网关推送时间序列数据 通过服务发现或静态配置发现目标对象 支持多种图形和仪表盘 组成Prometheus由多个组件组成： Prometheus主服务器：用于抓取并存储时间序列数据 客户端库：用于检测应用程序代码 推送网关：支持短生命周期 各种exporter：HAProxy，StatsD，Graphite等服务收集服务器性能数据 警告管理器 各种支持工具 架构 Prometheus + Grafana 监控系统性能主要用到了Prometheus，node exporter和Grafana，Prometheus和node exporter收集保存服务器性能数据，Grafana用于图形化展示数据。 图片来源：https://www.ansible.com/blog/red-hat-ansible-tower-monitoring-using-prometheus-node-exporter-grafana docker安装Prometheusdocker hub地址：https://registry.hub.docker.com/r/prom/prometheus docker安装：1$ docker pull prom/prometheus 配置prometheus.yml文件参考：https://github.com/prometheus/prometheus/blob/main/documentation/examples/prometheus.yml 新建/root/prometheus/prometheus.yml文件：1234567891011121314151617181920212223242526272829# my global configglobal: scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute. evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute. # scrape_timeout is set to the global default (10s).# Alertmanager configurationalerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093# Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.rule_files: # - &quot;first_rules.yml&quot; # - &quot;second_rules.yml&quot;# A scrape configuration containing exactly one endpoint to scrape:# Here it&#x27;s Prometheus itself.scrape_configs: # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config. - job_name: &#x27;prometheus&#x27; # metrics_path defaults to &#x27;/metrics&#x27; # scheme defaults to &#x27;http&#x27;. static_configs: - targets: [&#x27;localhost:9090&#x27;] 启动prometheus我们要用Grafana展示prometheus监控数据，先启动Grafana，Grafana安装配置方法可参考：JMeter性能监控系统：Jmeter + InfluxDB + Grafana 启动命令：1$ docker run -d -p 3000:3000 --name=grafana --network=grafana grafana/grafana:latest 启动prometheus：1$ docker run -d --name prometheus --network grafana -p 9090:9090 -v /root/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus:latest --config.file=/etc/prometheus/prometheus.yml启动后使用docker ps查看是否启动成功1234[root@server prometheus]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0587156618c5 prom/prometheus:latest &quot;/bin/prometheus --c…&quot; About a minute ago Up About a minute 0.0.0.0:9090-&gt;9090/tcp prometheus[root@server prometheus]# 浏览器访问：http://192.168.30.8:9090/其中192.168.30.8是我的服务器主机ip地址 metrics为本地主机的数据，访问http://192.168.30.8:9090/metrics 可以查看采集的数据。 安装启动node exporternode exporter用于收集系统数据，下面介绍它的使用方法。 node exporter github地址：https://github.com/prometheus/node_exporter下载node_exporter-1.1.2.linux-amd64.tar.gz，安装到另一台Linux系统上 123456789[root@Server2 exporter]# tar -xvzf node_exporter-1.1.2.linux-amd64.tar.gznode_exporter-1.1.2.linux-amd64/node_exporter-1.1.2.linux-amd64/LICENSEnode_exporter-1.1.2.linux-amd64/NOTICEnode_exporter-1.1.2.linux-amd64/node_exporter[root@Server2 exporter]# cd node_exporter-1.1.2.linux-amd64/[root@Server2 node_exporter-1.1.2.linux-amd64]# lsLICENSE node_exporter NOTICE[root@Server2 node_exporter-1.1.2.linux-amd64]# 运行node exporter，端口号为9100（默认）：1[root@Server2 node_exporter-1.1.2.linux-amd64]# nohup ./node_exporter --web.listen-address=&quot;:9100&quot; &amp; 启动后，浏览器输入http://192.168.30.9:9100/ 访问Node Exporter采集的数据，192.168.30.9为安装node exporter服务器的IP地址。 这时候在Prometheus是看不到这个节点的，因为没有建立连接，接下来配置prometheus.yml文件 配置Prometheus配置前面创建的prometheus.yml文件(启动prometheus的那个服务器)，在scrape_configs下添加： 123456789scrape_configs: - job_name: &#x27;prometheus&#x27; static_configs: - targets: [&#x27;localhost:9090&#x27;] - job_name: &#x27;centos server2&#x27; static_configs: - targets: [&#x27;192.168.30.9:9100&#x27;] 重启Prometheus：12$ docker restart prometheusprometheus重启成功后，刷新Prometheus页面，发现上线成功 配置Grafana点击Configuration -&gt; Data Sources -&gt; Add data source 选择Prometheus然后配置URL：http://prometheus:9090修改抓取时间，查询超时时间等参数，设置完成后点击Save &amp; Test 接下来配置Dashboard，在https://grafana.com/grafana/dashboards 中搜索选择别人开发好的面板，推荐https://grafana.com/grafana/dashboards/8919 点击Dashboards -&gt; Manage -&gt; Import，输入选择的dashboard地址，点击load，选择prometheus数据源，配置完成后点击Import。监控界面显示： 总结Prometheus提供了各种exporter，用于收集各种数据库、系统、中间件等性能数据，可参考https://prometheus.io/docs/instrumenting/exporters/ 查看所有官方或者第三方提供的exporter。 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>性能监控</tag>
        <tag>Prometheus</tag>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmap扫描工具介绍]]></title>
    <url>%2Fposts%2Fapi-test-security-testing-nmap-tool%2F</url>
    <content type="text"><![CDATA[Nmap (Network Mapper) 是在渗透测试中常用的扫描工具，可用于扫描网络中的 IP 地址和端口，并检测已安装的应用程序。无论是作为网络安全工具还是黑客工具，Nmap 是一个很强大的工具，在《黑客帝国2》电影中就有出现，用于入侵发电站的能源管理系统。本文将介绍 Nmap 的安装和常用命令。 Nmap简介及安装Nmap官网地址：https://nmap.org/ Nmap 特性Nmap使用IP数据包来确定网络上有哪些主机可用、提供哪些服务（应用程序名称和版本）、它们运行的操作系统（操作系统版本信息）、使用的数据包过滤/防火墙类型等其它特性。Nmap可以运行在所有主流的操作系统上，比如Linux、Windows和Mac OS等。 Nmap 支持检查主机是否启动，可用于监视主机或服务正常运行时间等 快速识别网络中的设备，包括服务器，路由器，交换机，移动设备等 帮助识别系统上运行的服务，包括 web 服务器、 DNS 服务器和其他常见应用程序。Nmap 还可以检测应用程序版本，帮助检测漏洞 查找在设备上运行的操作系统详细信息 漏洞扫描中，可以使用 Nmap 脚本攻击系统 Nmap提供了以下工具： Zenmap 图形界面：可以绘制网络映射图 Ncat：数据传输、重定向和调试工具 Ndiff：比较扫描结果 Nping：数据包生成和响应分析工具 Nmap安装centos7Linux系统安装：https://nmap.org/book/inst-linux.html#inst-rpm1$ rpm -vhU https://nmap.org/dist/nmap-7.91-1.x86_64.rpm也可以先把rpm下载下来后，再安装 1$ rpm -vhU nmap-7.91-1.x86_64.rpm 查看nmap版本1234567[root@server ~]# nmap -versionNmap version 7.91 ( https://nmap.org )Platform: x86_64-redhat-linux-gnuCompiled with: nmap-liblua-5.3.5 openssl-1.1.1h nmap-libssh2-1.9.0 nmap-libz-1.2.11 nmap-libpcre-7.6 nmap-libpcap-1.9.1 nmap-libdnet-1.12 ipv6Compiled without:Available nsock engines: epoll poll select[root@Client ~]# Windows 下载exe可执行文件，双击安装，不勾选npcap，其它默认 安装npcap，下载地址：https://nmap.org/npcap/#download 安装完成后，npcap默认加入了环境变量，不需要手动添加12345678D:\software\Nmap&gt;nmap --versionNmap version 7.91 ( https://nmap.org )Platform: i686-pc-windows-windowsCompiled with: nmap-liblua-5.3.5 openssl-1.1.1h nmap-libssh2-1.9.0 nmap-libz-1.2.11 nmap-libpcre-7.6 Npcap-1.10 nmap-libdnet-1.12 ipv6Compiled without:Available nsock engines: iocp poll selectD:\software\Nmap&gt; 其它系统安装方法参考：https://nmap.org/download.html Nmap命令查看帮助命令：1$ nmap -h 扫描单个主机1234567891011$ nmap 192.168.20.9Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-05 16:29 CSTNmap scan report for 192.168.20.9Host is up (0.00010s latency).Not shown: 998 closed portsPORT STATE SERVICE22/tcp open ssh111/tcp open rpcbindMAC Address: 00:0C:29:BB:0C:02 (VMware)Nmap done: 1 IP address (1 host up) scanned in 13.15 seconds 扫描多个主机同时扫描多个主机，1234$ nmap 192.168.20.9 192.168.20.8$ nmap 192.168.20.*$ nmap 192.168.20.8,9,10$ nmap 192.168.20.8-255 隐秘扫描(Stealth scan)通过发送 SYN 数据包并分析响应。如果收到 SYN/ACK，则表示端口已打开，可以进行 TCP 连接。1234567891011121314$ nmap -sS 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-05 17:15 CSTNmap scan report for 39.99.181.194Host is up (0.077s latency).Not shown: 995 filtered portsPORT STATE SERVICE22/tcp open ssh23/tcp closed telnet3306/tcp open mysql3389/tcp closed ms-wbt-server8080/tcp closed http-proxyNmap done: 1 IP address (1 host up) scanned in 30.31 seconds 版本扫描查找应用程序的版本，确认目标主机使用的应用版本后，可以在Common vulnerability and Exploits (CVE)数据库中找到应用特定版本的现有漏洞。然后可以使用 Metasploit 类似的工具来攻击计算机。123456789101112131415$ nmap -sV 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-05 17:37 CSTNmap scan report for 39.99.181.194Host is up (0.066s latency).Not shown: 995 filtered portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.0 (protocol 2.0)23/tcp closed telnet3306/tcp open mysql MySQL 5.7.293389/tcp closed ms-wbt-server8080/tcp closed http-proxyService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 13.26 seconds 操作系统探测Nmap 还可以使用 TCP/IP 指纹技术提供有关底层操作系统的信息。Nmap 还将尝试在操作系统扫描期间查找系统正常运行时间。 12345678910111213$ nmap -O 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-05 17:49 CSTNmap scan report for 39.99.181.194Host is up (0.061s latency).Not shown: 998 filtered portsPORT STATE SERVICE22/tcp open ssh3389/tcp closed ms-wbt-serverAggressive OS guesses: Linux 5.1 (94%), Linux 3.10 - 4.11 (92%), HP P2000 G3 NAS device (91%), Linux 3.2 - 4.9 (91%), Linux 3.16 - 4.6 (90%), Linux 2.6.32 (90%), Linux 5.0 (90%), Ubiquiti AirOS 5.5.9 (90%), Linux 4.4 (90%), Linux 5.0 - 5.4 (89%)No exact OS matches for host (test conditions non-ideal).OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 40.84 seconds 激烈扫描模式（-A参数）启用了操作系统检测(-O) 和版本扫描(-sV)，返回系统信息和版本信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ nmap -A 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-12 14:40 CSTNmap scan report for 39.99.181.194Host is up (0.056s latency).Not shown: 995 filtered portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.0 (protocol 2.0)| ssh-hostkey:| 3072 06:56:59:1d:73:7d:8f:e0:e0:0c:65:fa:75:4b:61:0b (RSA)| 256 3b:2e:45:69:49:7a:b2:fa:06:42:d2:1f:4a:c8:e6:2a (ECDSA)|_ 256 6b:a5:e5:b7:39:28:1b:03:e0:c1:6b:2b:fb:19:f0:7b (ED25519)23/tcp closed telnet3306/tcp open mysql MySQL 5.7.29| mysql-info:| Protocol: 10| Version: 5.7.29| Thread ID: 35| Capabilities flags: 65535| Some Capabilities: Support41Auth, Speaks41ProtocolNew, Speaks41ProtocolOld, SwitchToSSLAfterHandshake, IgnoreSigpipes, InteractiveClient, DontAllowDatabaseTableColumn, FoundRows, LongPassword, SupportsTransactions, ODBCClient, ConnectWithDatabase, IgnoreSpaceBeforeParenthesis, LongColumnFlag, SupportsLoadDataLocal, SupportsCompression, SupportsMultipleStatments, SupportsMultipleResults, SupportsAuthPlugins| Status: Autocommit| Salt: \x1E7aZ5\x07%|\x02+\x01_#\x1B6FX~\x07|_ Auth Plugin Name: mysql_native_password| ssl-cert: Subject: commonName=MySQL_Server_5.7.29_Auto_Generated_Server_Certificate| Not valid before: 2020-06-17T09:36:07|_Not valid after: 2030-06-15T09:36:07|_ssl-date: TLS randomness does not represent time3389/tcp closed ms-wbt-server8080/tcp closed http-proxyAggressive OS guesses: Linux 5.1 (94%), Linux 3.10 - 4.11 (92%), HP P2000 G3 NAS device (91%), Linux 3.2 - 4.9 (91%), Linux 3.16 - 4.6 (90%), Linux 2.6.32 (90%), Linux 2.6.32 - 3.1 (90%), Ubiquiti AirMax NanoStation WAP (Linux 2.6.32) (90%), Linux 3.7 (90%), Linux 4.4 (90%)No exact OS matches for host (test conditions non-ideal).Network Distance: 16 hopsTRACEROUTE (using port 3389/tcp)HOP RTT ADDRESS1 1.00 ms 192.168.101.12 6.00 ms 120.237.96.813 8.00 ms 183.233.126.854 8.00 ms 211.136.248.815 12.00 ms 221.183.39.1576 75.00 ms 221.183.37.1377 ...8 51.00 ms 111.13.0.1739 44.00 ms 39.156.0.3710 52.00 ms 39.156.7.24911 ... 1213 54.00 ms 116.251.124.19414 ... 1516 61.00 ms 39.99.181.194OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 23.85 seconds 端口扫描使用 -p 参数扫描单个端口123456789$ nmap -p 3306 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-16 17:35 CSTNmap scan report for 39.99.181.194Host is up (0.049s latency).PORT STATE SERVICE3306/tcp open mysqlNmap done: 1 IP address (1 host up) scanned in 0.99 seconds 指定端口连接类型，比如TCP连接1$ nmap -p T:3306 39.99.181.194指定端口范围12345678910111213$ nmap -p 22-8080 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-16 17:38 CSTNmap scan report for 39.99.181.194Host is up (0.052s latency).Not shown: 8054 filtered portsPORT STATE SERVICE22/tcp open ssh23/tcp open telnet3306/tcp open mysql3389/tcp closed ms-wbt-server8080/tcp closed http-proxyNmap done: 1 IP address (1 host up) scanned in 22.10 seconds 123456789101112131415161718$ nmap --top-ports 10 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-16 17:41 CSTNmap scan report for 39.99.181.194Host is up (0.15s latency).PORT STATE SERVICE21/tcp filtered ftp22/tcp open ssh23/tcp open telnet25/tcp filtered smtp80/tcp filtered http110/tcp filtered pop3139/tcp filtered netbios-ssn443/tcp filtered https445/tcp filtered microsoft-ds3389/tcp filtered ms-wbt-serverNmap done: 1 IP address (1 host up) scanned in 5.29 seconds TCP扫描：12345678910111213$ nmap -sT 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-18 16:47 CSTNmap scan report for 39.99.181.194Host is up (0.049s latency).Not shown: 995 filtered portsPORT STATE SERVICE22/tcp open ssh23/tcp open telnet25/tcp open smtp110/tcp open pop33306/tcp open mysqlNmap done: 1 IP address (1 host up) scanned in 49.29 secondsTCP SYN扫描（半开放扫描）：SYN扫描执行快，每秒钟可以扫描数千个 端口，因为它不完成TCP连接 1$ nmap -sS 39.99.181.194 UDP扫描：UDP扫描一般较慢，DNS，SNMP，和DHCP (端口53，161/162，和67/68)是最常见的三个UDP服务。 1234567$ nmap -sU 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-18 16:49 CSTNmap scan report for 39.99.181.194Host is up (0.052s latency).All 1000 scanned ports on 39.99.181.194 are open|filteredNmap done: 1 IP address (1 host up) scanned in 59.64 seconds open|filtered表示无法确定端口是开放还是被过滤的 UDP扫描比TCP扫描慢的原因是UDP是无连接的，Nmap无法区分应用过滤数据包的开放端口、数据包被防火墙阻止丢弃的端口或者数据包由于网络拥塞而在传输过程中丢失。而且对于closed端口（ICMP端口无法访问），Nmap无法区分端口被防火墙过滤还是数据包丢失。除非端口返回数据或返回ICMP不可达报文，否则Nmap需要发送多个数据包来消除速率限制或丢失数据包的可能性。 可以通过如下方式提高扫描速度（牺牲扫描精度） --min-rate参数：--min-rate 5000表示每秒发送5000个数据包 --max-rtt-timeout参数：控制nmap等待响应时间，需大于5ms，具体时间可以通过ping命令查看。--max-rtt-timeout 0.005：5ms等待时间 --max-retries参数：设置重试次数，--max-retries 1重试1次 --max-scan-delay参数：设置扫描间隔，用在主机响应慢的情况下。 1$ nmap -sU --min-rate 5000 39.99.181.194 Null扫描 (-sN)：不设置任何标志位(tcp标志头是0) 1$ nmap -sN 39.99.181.194 FIN扫描 (-sF)：只设置TCP FIN标志位。 1$ nmap -sF 39.99.181.194 Xmas扫描 (-sX)：设置FIN，PSH，和URG标志位 1$ nmap -sX 39.99.181.194 TCP ACK扫描：用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。 12345678910111213$ nmap -sA 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-18 17:07 CSTNmap scan report for 39.99.181.194Host is up (0.053s latency).Not shown: 995 filtered portsPORT STATE SERVICE22/tcp unfiltered ssh23/tcp unfiltered telnet3306/tcp unfiltered mysql3389/tcp unfiltered ms-wbt-server8080/tcp unfiltered http-proxyNmap done: 1 IP address (1 host up) scanned in 11.24 seconds IP协议扫描：确定目标机支持哪些IP协议 (TCP，ICMP，IGMP等) 123456789$ nmap -sO 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-18 17:11 CSTNmap scan report for 39.99.181.194Host is up (0.054s latency).Not shown: 255 open|filtered protocolsPROTOCOL STATE SERVICE1 open icmpNmap done: 1 IP address (1 host up) scanned in 16.49 seconds PING扫描：检测目标主机是否在线1$ nmap -sP 39.99.181.194 读取文件扫描如果需要扫描的IP地址很多，可以存放在一个文件里面进行扫描 1$ nmap -iL nmap_test.txt 扫描日志-v参数打印扫描日志 12345678910111213141516171819202122$ nmap -v -p 3306 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-16 17:51 CSTInitiating Ping Scan at 17:51Scanning 39.99.181.194 [4 ports]Completed Ping Scan at 17:51, 0.23s elapsed (1 total hosts)Initiating Parallel DNS resolution of 1 host. at 17:51Completed Parallel DNS resolution of 1 host. at 17:51, 0.35s elapsedInitiating SYN Stealth Scan at 17:51Scanning 39.99.181.194 [1 port]Discovered open port 3306/tcp on 39.99.181.194Completed SYN Stealth Scan at 17:51, 0.05s elapsed (1 total ports)Nmap scan report for 39.99.181.194Host is up (0.049s latency).PORT STATE SERVICE3306/tcp open mysqlRead data files from: D:\software\NmapNmap done: 1 IP address (1 host up) scanned in 1.06 seconds Raw packets sent: 5 (196B) | Rcvd: 2 (72B)D:\software\Nmap&gt; 保存到文件，保存格式支持text、xml 12$ nmap -oN output.txt 39.99.181.194$ nmap -oX output.xml 39.99.181.194 或者1$ nmap -oA output 39.99.181.194生成output,xml、output.nmap、output.gnmap文件 NSE脚本NSE(Nmap Scripting Engine)是一个非常强大的渗透工具，它允许用户编写各种网络任务的自动化脚本。脚本基于Lua语言，可以自己编写满足需求的脚本或者修改已有的脚本。目前Nmap集成了600多个脚本，参考：https://nmap.org/nsedoc/ 语法：12$ nmap --script &lt;filename&gt;$ nmap -sC # 使用默认脚本集执行脚本扫描，等价于 --script=default多个脚本使用逗号分隔 NSE脚本类别NSE 通过 -sC 选项（或--script）激活，主要包括以下功能： 网络发现：扫描目标主机信息、服务等 版本检测：检测应用版本 漏洞检测：扫描系统漏洞 后门检测 攻击、利用漏洞 NSE 脚本主要包括以下14类： auth：身份认证 broadcast：广播，通过在本地网络上广播来发现没有列出的主机 brute：使用暴力破解来猜测远程服务器的身份认证凭据 default：默认设置的脚本，使用 -sC 或 -A 选项时默认运行，比如identd-owners、http-auth、ftp-anon。 discovery：通过查询公共注册中心、支持 snmp 的设备、目录服务等来发现更多关于网络的信息 dos：测试拒绝服务的漏洞 exploit：主动利用某些漏洞 external：将数据发送到第三方数据库或其他网络资源，比如whois-ip通过连接到 whois 服务器获取目标地址 fuzzer：在每个数据包中发送随机字段，可用于发现软件的缺陷和漏洞 intrusive：可能会消耗目标主机大量资源，风险太高，可能会导致目标系统崩溃 malware：测试目标平台是否被恶意软件或后门感染 safe：安全脚本，不攻击，不使用大量网络带宽或其他资源 version：版本检测： vuln：检查特定的已知漏洞，通常只报告发现的结果 NSE脚本示例discoverymysql-info：打印mysql服务器版本，协议，进程ID，密码盐度等信息 123456789101112131415161718192021$ nmap -sV --script=mysql-info 39.99.181.194Nmap scan report for 39.99.181.194Host is up (0.064s latency).Not shown: 995 filtered portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.0 (protocol 2.0)23/tcp open telnet Linux telnetd3306/tcp open mysql MySQL 5.7.29| mysql-info:| Protocol: 10| Version: 5.7.29| Thread ID: 33| Capabilities flags: 65535| Some Capabilities: LongColumnFlag, SupportsLoadDataLocal, Support41Auth, DontAllowDatabaseTableColumn, SupportsTransactions, IgnoreSigpipes, FoundRows, SwitchToSSLAfterHandshake, IgnoreSpaceBeforeParenthesis, ODBCClient, Speaks41ProtocolNew, ConnectWithDatabase, InteractiveClient, Speaks41ProtocolOld, LongPassword, SupportsCompression, SupportsMultipleResults, SupportsAuthPlugins, SupportsMultipleStatments| Status: Autocommit| Salt:| =\x06Dq\x17Z|W&#x27;\x1F:\x1C)\x07`Bx,D|_ Auth Plugin Name: mysql_native_password3389/tcp closed ms-wbt-server8080/tcp closed http-proxyService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel authssh-auth-methods：返回SSH服务器支持的认证方法12345678910111213141516171819$ nmap --script=ssh-auth-methods 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-18 16:03 ?D1ú±ê×?ê±??Nmap scan report for 39.99.181.194Host is up (0.069s latency).Not shown: 995 filtered portsPORT STATE SERVICE22/tcp open ssh| ssh-auth-methods:| Supported authentication methods:| publickey| gssapi-keyex| gssapi-with-mic|_ password23/tcp open telnet3306/tcp open mysql3389/tcp closed ms-wbt-server8080/tcp closed http-proxyNmap done: 1 IP address (1 host up) scanned in 60.76 seconds brute暴力破解对SSH服务进行暴力破解： 12345678910111213$ nmap -p 22 --script ssh-brute --script-args userdb=users.lst,passdb=pass.lst --script-args ssh-brute.timeout=4s 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-18 16:11 CSTNSE: [ssh-brute] Trying username/password pair: root:rootNSE: [ssh-brute] Trying username/password pair: admin:adminNSE: [ssh-brute] Trying username/password pair: administrator:administratorNSE: [ssh-brute] Trying username/password pair: webadmin:webadminNSE: [ssh-brute] Trying username/password pair: sysadmin:sysadminNSE: [ssh-brute] Trying username/password pair: netadmin:netadminNSE: [ssh-brute] Trying username/password pair: guest:guestNSE: [ssh-brute] Trying username/password pair: user:userNSE: [ssh-brute] Trying username/password pair: web:webNSE: [ssh-brute] Trying username/password pair: test:test...... ftp暴力破解1$ nmap --script ftp-brute -p 21 &lt;host&gt; mysql-enum：获取mysql有效用户1234567891011121314151617181920212223$ nmap -p 3306 --script=mysql-enum 39.99.181.194Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-18 16:19 CSTNmap scan report for 39.99.181.194Host is up (0.23s latency).PORT STATE SERVICE3306/tcp open mysql| mysql-enum:| Valid usernames:| root:&lt;empty&gt; - Valid credentials| netadmin:&lt;empty&gt; - Valid credentials| guest:&lt;empty&gt; - Valid credentials| test:&lt;empty&gt; - Valid credentials| web:&lt;empty&gt; - Valid credentials| sysadmin:&lt;empty&gt; - Valid credentials| administrator:&lt;empty&gt; - Valid credentials| webadmin:&lt;empty&gt; - Valid credentials| admin:&lt;empty&gt; - Valid credentials| user:&lt;empty&gt; - Valid credentials|_ Statistics: Performed 10 guesses in 1 seconds, average tps: 10.0Nmap done: 1 IP address (1 host up) scanned in 9.15 seconds mysql-brute：密码破解1234567891011121314$ nmap --script=mysql-brute -p 3306 127.0.0.1Starting Nmap 7.91 ( https://nmap.org ) at 2021-03-22 16:24 CSTNmap scan report for localhost (127.0.0.1)Host is up (0.0010s latency).PORT STATE SERVICE3306/tcp open mysql| mysql-brute:| Accounts:| admin:admin - Valid credentials| root:123456 - Valid credentials|_ Statistics: Performed 40012 guesses in 20 seconds, average tps: 2000.6Nmap done: 1 IP address (1 host up) scanned in 21.36 seconds Zenmap可视化Zenmap是Nmap的图形化界面 总结本文简要介绍了nmap工具的安装、一些常用扫描命令、NSE脚本以及可视化工具Zenmap的演示。nmap是一个强大的渗透测试工具，提供丰富的命令脚本，可以说是网络的“瑞士军刀”，更多用法可以参考Nmap官网网站：https://nmap.org/ ，上面介绍了Nmap工具的详细信息和更高级的用法。中文文档参考：https://nmap.org/man/zh/ --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>nmap</tag>
        <tag>NSE</tag>
        <tag>Zenmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成：Jenkins API简单使用]]></title>
    <url>%2Fposts%2Fcontinuous-integration-for-jenkins-api%2F</url>
    <content type="text"><![CDATA[Jenkins具有丰富的API接口，可以通过调用API接口实现对Job的触发、删除、查看任务状态等操作，支持HTTP协议，支持用户名、密码认证，提供的这些接口可以实现对 Jenkins 的控制。下面介绍Jenkins API的使用实例。 先创建一个有Job任务运行和状态查询权限的用户，可使用admin用户；新建一个项目（可参考持续集成平台Jenkins介绍） Jenkins API调用示例远程调用 Jenkins API返回最新任务编号GET请求URL：http://username:password@hostname:port/job/任务名/lastBuild/buildNumber 12345import requestsurl = &quot;http://admin:admin@192.168.30.8:8080/job/demo/lastBuild/buildNumber&quot;ret = requests.get(url)print(ret.text) 输出：117 远程调用 Jenkins API查询任务状态GET请求URL：http://username:password@hostname:port/job/任务名/\/api/json 12345import jsonimport requestsurl = &quot;http://admin:admin@192.168.30.8:8080/job/demo/17/api/json&quot;ret = requests.get(url)print(json.dumps(ret.json(),indent=2)) 返回的日志123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;_class&quot;: &quot;hudson.model.FreeStyleBuild&quot;, &quot;actions&quot;: [ &#123; &quot;_class&quot;: &quot;hudson.model.CauseAction&quot;, &quot;causes&quot;: [ &#123; &quot;_class&quot;: &quot;hudson.model.Cause$UserIdCause&quot;, &quot;shortDescription&quot;: &quot;Started by user anonymous&quot;, &quot;userId&quot;: null, &quot;userName&quot;: &quot;anonymous&quot; &#125; ] &#125;, &#123;&#125;, &#123; &quot;_class&quot;: &quot;org.jenkinsci.plugins.displayurlapi.actions.RunDisplayAction&quot; &#125; ], &quot;artifacts&quot;: [], &quot;building&quot;: false, &quot;description&quot;: null, &quot;displayName&quot;: &quot;#17&quot;, &quot;duration&quot;: 109, &quot;estimatedDuration&quot;: 222, &quot;executor&quot;: null, &quot;fullDisplayName&quot;: &quot;demo #17&quot;, &quot;id&quot;: &quot;17&quot;, &quot;keepLog&quot;: false, &quot;number&quot;: 17, &quot;queueId&quot;: 3, &quot;result&quot;: &quot;SUCCESS&quot;, &quot;timestamp&quot;: 1615705287802, &quot;url&quot;: &quot;http://192.168.30.8:8080/job/demo/17/&quot;, &quot;builtOn&quot;: &quot;&quot;, &quot;changeSet&quot;: &#123; &quot;_class&quot;: &quot;hudson.scm.EmptyChangeLogSet&quot;, &quot;items&quot;: [], &quot;kind&quot;: null &#125;, &quot;culprits&quot;: []&#125; 远程调用 Jenkins API启动任务使用POST请求方法：URL：http://username:password@hostname:port/job/任务名/build 1234import requestsurl = &quot;http://admin:admin@192.168.30.8:8080/job/demo/build&quot;ret = requests.post(url)print(ret.text) Jenkins 跨站请求伪造保护采取 Crumb（碎片生成器），可以使用jenkinsapi库来调用api Python jenkinsapi库jenkinsapi库封装了Jenkins api 的调用方法安装：1$ pip install jenkinsapi下面代码实现启动job名为demo的任务123456789101112131415161718192021222324from jenkinsapi.jenkins import Jenkinsjk = Jenkins(&#x27;http://192.168.30.8:8080&#x27;, username=&#x27;admin&#x27;, password=&#x27;admin&#x27;, useCrumb=True)# print(jk.keys())job_name = &#x27;demo&#x27;if jk.has_job(job_name): my_job = jk.get_job(job_name) if not my_job.is_queued_or_running(): try: last_build = my_job.get_last_buildnumber() except: last_build = 0 build_num = last_build + 1 # 启动任务 try: jk.build_job(job_name) except Exception as e: print(str(e)) while True: if not my_job.is_queued_or_running(): print(&quot;Finished&quot;) print(f&quot;build_num：&#123;build_num&#125;&quot;) break输出：12Finishedbuild_num：20 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试开发</category>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成：jenkins + pytest + selenium + Git + Allure自动化测试]]></title>
    <url>%2Fposts%2Fcontinuous-integration-for-jenkins-example%2F</url>
    <content type="text"><![CDATA[本文介绍jenkins， pytest ，selenium，Git，Allure的自动化测试实现方法，使用jenkins实现web自动化测试，并生成报告，自动发送邮件。 0-测试环境准备 Selenium Web自动化测试框架 自动化测试框架pytest编写测试用例 windows配置Git：可参考Git简易教程-安装及简单使用 linux虚拟机 (centos7) 运行jenkins，虚拟机和Windows可以互相ping通 配置jenkins-Windows节点：参考持续集成平台Jenkins详细介绍 用例Github地址：https://github.com/hiyongz/selenium_pytest_demo 1-jenkins配置github项目1、新建项目新建一个item，名称：selenium_pytest_demo，选择freestyle project 2、配置项目Git地址节点名为配置的windows节点名 3、配置代码管理注意：分支和github代码分支名一致 4、构建选择执行windows批处理命令 5、配置构建后操作1、选择Allure报告注意要配置Allure Commandline：进入Global Tool Configuration进行配置 2、配置邮件提醒Jenkins邮件报警配置方法可参考：持续集成平台Jenkins详细介绍 2-运行配置完成后保存，点击Build Now 运行 控制台输出日志： jenkins查看Allure报告： 邮件提醒： 3-jenkins执行本地项目如果不从GitHub上克隆项目，可以运行本地项目，不需要配置Git，只需要配置项目的本地路径 其它配置类似，配置完成后，点击构建 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试开发</category>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记：日期时间获取与转换]]></title>
    <url>%2Fposts%2Fpython-notes-for-datetime%2F</url>
    <content type="text"><![CDATA[python 日期时间获取与转换 世界时、原子时和世界协调时世界时世界时（Universal Time, UT）是根据地球自转周期确定的时间，1s为全年内每日平均长度的1/86400，由于地球绕太阳公转的轨道不是圆的，地球与太阳之间的距离不是固定的，导致太阳相对绕地球的周期不等于地球自转周期，通过对产生的时差进行修正，称为“平均太阳时”。根据国际协定，将英国格林威治所在子午圈（又称本初子午线）的平太阳时，定义为零类世界时（UT0）。由于地球的旋转轴会有微小移动（每年有几厘米的移动），对极移效应进行修正后的时间称为为一类世界时UT1。一类世界时UT1也有原因不明的季节性周期变化，对此进行修正，便得到更加均匀的二类世界时UT2。 原子时原子时钟是利用铯原子振荡周期极为规律的特性研制而出，原子时(international atomic time,TAI)的秒长定义为铯 -133 原子能级跃迁辐射9192631770周所持续的时间。原子钟的精度可以达到每100万年误差才1秒。在要求更高时间精度的天文、航海、航天等领域发挥了巨大的作用。 世界协调时世界协调时(Coordinatde Universal Time, UTC)基于国际原子时，以原子时秒长为基础，在时刻上尽量接近于格林威治标准时间(GMT)，通过不规则的加入闰秒来抵消地球自转变慢的影响，保证UTC与世界时（UT1）相差不超过0.9秒。 epoch timeUnix epoch (Unix time, POSIX time, Unix timestamp)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix 系统、类Unix系统中，也在许多其他操作系统中被广泛采用。 2038问题32位操作系统将epoch日期存储为有符号的32位整数，此类系统的Unix时间戳最多可以使用到格林威治时间2038年01月19日03时14分07秒（二进制：01111111 11111111 11111111 11111111）。其后一秒，二进制数字会变为10000000 00000000 00000000 00000000，发生溢出错误，造成系统将时间误解为1901年12月13日20时45分52秒。这很可能会引起软件故障，甚至是系统瘫痪(称为2038年问题或者Y2038)。 使用64位二进制数字表示时间的系统（最多可以使用到格林威治时间292,277,026,596年12月04日15时30分08秒）则基本不会遇到这类溢出问题。 python time时间格式在线转换：https://www.epochconverter.com/时区转换 国际时区转换在线计算器 世界时区划分时差查询 Python time文档：https://docs.python.org/zh-cn/3/library/time.html python获取当前时间 time.time()：获取当前的epoch时间（时间戳） time.localtime()：获取本地时间 time.gmtime()：获取GMT时间12345&gt;&gt; import time; &gt;&gt; time.time()1612661504.1785676&gt;&gt; time.localtime()time.struct_time(tm_year=2021, tm_mon=2, tm_mday=7, tm_hour=11, tm_min=23, tm_sec=20, tm_wday=6, tm_yday=38, tm_isdst=0) 标准时间转换为epoch时间本文将标准时间定义为ISO 8601格式时间：YYYY-MM-DD hh:mm:ss.mil 两种方法转换为 Unix timestamp： calendar.timegm：转换的时间格式为格林威治标准时间 time.mktime：转换的时间为本地时间（考虑了时区） 123456&gt;&gt; import calendar, time&gt;&gt; date_time = time.strptime(&#x27;2000-01-01 12:34:00&#x27;, &#x27;%Y-%m-%d %H:%M:%S&#x27;)&gt;&gt; calendar.timegm(date_time)946730040&gt;&gt; time.mktime(date_time)946701240.0 epoch时间转换为标准时间 time.localtime(epoch_time)：转换为本地时间，或者获取本地时间 time.gmtime(epoch_time)：转换为GMT时间，或者获取GMT时间 datetime.datetime.utcfromtimestamp(epoch_time)：UTC时间 datetime.datetime.fromtimestamp(epoch_time)：本地时间 12345678910111213&gt;&gt; import time&gt;&gt; epoch_time = 946730040&gt;&gt; time.strftime(&quot;%a, %d %b %Y %H:%M:%S&quot;, time.localtime(epoch_time)) &#x27;Sat, 01 Jan 2000 20:34:00&#x27;&gt;&gt; time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(epoch_time)) &#x27;2000-01-01 20:34:00&#x27;&gt;&gt; time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.gmtime(epoch_time)) &#x27;2000-01-01 12:34:00&#x27;&gt;&gt; import datetime&gt;&gt;&gt; datetime.datetime.fromtimestamp(epoch_time)datetime.datetime(2000, 1, 1, 20, 34)&gt;&gt;&gt; datetime.datetime.utcfromtimestamp(epoch_time)datetime.datetime(2000, 1, 1, 12, 34) python datetime获取当前时间（本地时间）12345import datetimenow_time = datetime.datetime.now()print(now_time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))print(now_time.strftime(&quot;%A&quot;)）print(now_time.strftime(&quot;%w&quot;)） out：1232020-09-28 14:15:24Monday1 时间格式化123import datetimetimestr = &quot;2020-10-01 18:30:00&quot;print(datetime.datetime.strptime(timestr, &quot;%Y-%m-%d %H:%M:%S&quot;)) out：12020-10-01 18:30:00 timedeltatimedelta表示一个时间段，可用于时间计算。语法：1datetime.timedelta(days&#x3D;0, seconds&#x3D;0, microseconds&#x3D;0, milliseconds&#x3D;0, minutes&#x3D;0, hours&#x3D;0, weeks&#x3D;0) 123456import datetimenow_time = datetime.datetime.now()# 当前时间加一天now_time + datetime.timedelta(days=1)# 当前时间减一周now_time + datetime.timedelta(weeks=-1) --THE END--]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器技术介绍：Dockerfile语法指令及Docker镜像构建]]></title>
    <url>%2Fposts%2Fcontainer-docker-dockerfile%2F</url>
    <content type="text"><![CDATA[在工作中，通常会根据项目需要制作镜像，Docker可以通过读取Dockerfile文件中的指令来自动构建镜像，Dockerfile文本文件包含镜像构建的命令，通过 docker build 执行 Dockerfile中的一系列指令来自动构建镜像。除了Dockerfile的方式外，也可以使用Docker commit来制作镜像，本文将介绍Dockerfile语法Docker镜像的构建方法。 常用Dockerfile指令Dockerfile官方文档：https://docs.docker.com/engine/reference/builder/ Docker 顺序执行Dockerfile文件中的指令，指令不区分大小写，为了区分，建议都大写。Dockerfile以 FROM 指令开始，FROM指令指定了构建的父镜像（基础镜像），Dockerfile使用 # 注释行，下面列出其它常用指令： COPY：复制文件，复制文件或者目录到容器里指定路径 LABEL：为镜像生成元数据标签信息 WORKDIR：指定工作目录，为后续的RUN、CMD、 ENTRYPOINT、ADD指令配置工作目录。 USER：指定运行容器时的用户名或UID，后续命令执行也会使用指定用户。 RUN：Dockerfile RUN命令是执行命令的核心部分，在docker build时执行。它接受命令作为参数并用于创建镜像。每条RUN命令在当前基础镜像上执行，并且会提交一个新镜像层：RUN pip install flask CMD：容器运行 docker run 时执行的默认命令。 ENV：容器启动的环境变量。 ARG：构建环境的环境变量。 ENTRYPOINT：指定容器的“入口”。 HEALTHCHECK：用于指定某个程序或者指令来监控 docker 容器服务的运行状态 Dockerfile构建容器常用文件、命令： .dockerignore：设置希望构建时需要忽略的文件，过滤指定文件 docker build -f Dockerfile文件名：指定Dockerfile文件 docker build -t 标签：添加标签 docker build --no-cache：不使用缓存，也就是每次构建时，不管有没有安装过都进行重新构建 docker build --build-arg：传递ARG指令变量 1. 创建Dockerfile文件构建一个dockerfile文件，定制一个Nginx镜像，添加容器健康检查。Dockerfile：123456789101112131415161718192021222324252627282930313233343536373839404142# 基于 nginx:latest 镜像构建FROM nginx:latest# 指定信息LABEL maintainer=&quot;test_dockerfile&quot;# 设置环境变量ENV NGINX_VERSION latestARG workpath=/data/html/# 切换root用户USER root# 执行命令，安装cur软件，设置软链接把ngin服务的日志显示到终端RUN apt-get -yq update &amp;&amp; apt-get install -y curl &amp;&amp; \ln -sf /dev/stdout /var/log/nginx/access.log &amp;&amp; \ln -sf /dev/stderr /var/log/nginx/error.log# 挂载卷VOLUME [&quot;/data&quot;]# 设置工作目录WORKDIR $workpath# 复制 index.html 文件到nginx的html目录下COPY index.html /usr/share/nginx/html# 映射80端口EXPOSE 80# 此处CMD作为 ENTRYPOINT的参数。CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]# CMD [&quot;-g&quot;,&quot;daemon off;&quot;]# CMD nginx -g daemon off# 设置容器启动的命令ENTRYPOINT [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]STOPSIGNAL SIGRTMAX# 检查容器健康，通过访问 Nginx服务80端口，来判断容器服务是否健康HEALTHCHECK --interval=5s --timeout=3s \ CMD curl -fs http://localhost/ || exit 1 index.html文件内容：1&lt;h1&gt;Hello World !&lt;/h1&gt; 2. 构建镜像：docker build在Dockerfile 文件目录下执行构建：1$ docker build -t nginx:testv1 -f Dockerfile . nginx:testv1：镜像名称:镜像标签 Dockerfile：Dockerfile 文件名，默认文件名为Dockerfile . 表示当前目录，代表本次执行的上下文路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[root@server test_dockerfile]# pwd/root/docker/test_dockerfile[root@server test_dockerfile]# lsDockerfile index.html[root@server test_dockerfile]# docker build -t nginx_demo:v1 .Sending build context to Docker daemon 4.096kBStep 1/13 : FROM nginx:latest ---&gt; f6d0b4767a6cStep 2/13 : LABEL maintainer=&quot;test_dockerfile&quot; ---&gt; Running in 6c4b611a19e9Removing intermediate container 6c4b611a19e9 ---&gt; 6a6f12ed39adStep 3/13 : ENV NGINX_VERSION latest ---&gt; Running in e9cfc405af5aRemoving intermediate container e9cfc405af5a ---&gt; 6608a514dc4aStep 4/13 : ARG workpath=/data/html/ ---&gt; Running in 31ec17310301Removing intermediate container 31ec17310301 ---&gt; 04b7f5b51c63Step 5/13 : USER root ---&gt; Running in 1d6aaf7f9d13Removing intermediate container 1d6aaf7f9d13 ---&gt; 3568d2cf3a36Step 6/13 : RUN apt-get install -y curl &amp;&amp; ln -sf /dev/stdout /var/log/nginx/access.log &amp;&amp; ln -sf /dev/stderr /var/log/nginx/error.log ---&gt; Running in fcf7a55bbb4aReading package lists...Building dependency tree...Reading state information...curl is already the newest version (7.64.0-4+deb10u1).0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.Removing intermediate container fcf7a55bbb4a ---&gt; 20cb644a11c3Step 7/13 : VOLUME [&quot;/data&quot;] ---&gt; Running in ebaa3b7e6dbfRemoving intermediate container ebaa3b7e6dbf ---&gt; 246093dbcc45Step 8/13 : WORKDIR $workpath ---&gt; Running in 494a62d4166bRemoving intermediate container 494a62d4166b ---&gt; 2afb818a2a35Step 9/13 : COPY index.html /usr/share/nginx/html ---&gt; 1fee5e32c1fcStep 10/13 : EXPOSE 80 ---&gt; Running in 2a80075b76f3Removing intermediate container 2a80075b76f3 ---&gt; 3ef9846b592eStep 11/13 : CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;] ---&gt; Running in db5ab895a85bRemoving intermediate container db5ab895a85b ---&gt; 4e70e4e4ef95Step 12/13 : STOPSIGNAL SIGRTMAX ---&gt; Running in d7ceb8fdbd59Removing intermediate container d7ceb8fdbd59 ---&gt; 68c8bb3b43f9Step 13/13 : HEALTHCHECK --interval=5s --timeout=3s CMD curl -fs http://localhost/ || exit 1 ---&gt; Running in 3cb2690c7c13Removing intermediate container 3cb2690c7c13 ---&gt; e20cc62ae3e5Successfully built e20cc62ae3e5Successfully tagged nginx_demo:v1 查看镜像：12[root@server test_dockerfile]# docker images | grep nginx_demonginx_demo v1 adfe6b7f7297 5 minutes ago 133MB 3. 运行镜像：docker run123[root@server test_dockerfile]# docker run -d --name=nginx-test -p 8080:80 nginx_demo:v1b0bd21087663 nginx_demo:v1 &quot;/docker-entrypoint.…&quot; 6 minutes ago Up 6 minutes (unhealthy) 80/tcp admiring_swanson[root@server test_dockerfile]# docker ps 查看容器123[root@server test_dockerfile]# docker ps | grep nginx_demo710628d0ad55 nginx_demo:v1 &quot;/docker-entrypoint.…&quot; 2 minutes ago Up 2 minutes (unhealthy) 0.0.0.0:8080-&gt;80/tcp nginx-test[root@server test_dockerfile]# 浏览器输入：192.168.30.8:8080 可以进入容器查看设置的环境变量1234567891011121314151617181920212223242526272829303132[root@server test_dockerfile]# docker exec -it 710628d0ad55 bashroot@b0bd21087663:/data/html# root@b0bd21087663:/data/html# root@b0bd21087663:/data/html# pwd/data/htmlroot@b0bd21087663:/data/html# lsindex.htmlroot@b0bd21087663:/data/html# envHOSTNAME=b0bd21087663PWD=/data/htmlPKG_RELEASE=1~busterHOME=/rootNJS_VERSION=0.5.0TERM=xtermSHLVL=1PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNGINX_VERSION=latest_=/usr/bin/envroot@b0bd21087663:/data/html# iduid=0(root) gid=0(root) groups=0(root)root@b0bd21087663:/data/html# df -hFilesystem Size Used Avail Use% Mounted onoverlay 45G 22G 24G 48% /tmpfs 64M 0 64M 0% /devtmpfs 910M 0 910M 0% /sys/fs/cgroupshm 64M 0 64M 0% /dev/shm/dev/mapper/centos-root 45G 22G 24G 48% /datatmpfs 910M 0 910M 0% /proc/asoundtmpfs 910M 0 910M 0% /proc/acpitmpfs 910M 0 910M 0% /proc/scsitmpfs 910M 0 910M 0% /sys/firmwareroot@b0bd21087663:/data/html# Docker commitDocker commit一般用做从一个运行状态的容器来创建一个新的镜像，对外不可解释，不知道容器有什么应用，不方便排查问题，可维护性差。Dockerfile的方式更容易排查问题。 Docker commit构建命令：1$ docker commit 容器名 新镜像名:tag对于上面构建的镜像，如果对index.html文件内容修改后重新打包一个镜像，我们可以使用Docker commit来构建：1[root@server ~]# docker commit nginx-test nginx_demo:v2启动：1[root@server ~]# docker run -d --name=nginx-test2 -p 8080:80 nginx_demo:v2 --THE END--]]></content>
      <categories>
        <category>测试开发</category>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库基础入门]]></title>
    <url>%2Fposts%2Fmysql-database-operate%2F</url>
    <content type="text"><![CDATA[本文介绍MySQL数据库基础操作方法 MySQL 连接命令行连接mysql服务器：1mysql -h 主机名 -u 用户名 -p -h：指定要登录的MySQL主机名，登录本机可以省略 -u：用户名 -p：登录密码 123456789101112131415C:\Users\10287&gt;mysql -u root -pEnter password: *********Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 8Server version: 8.0.16 MySQL Community Server - GPLCopyright (c) 2000, 2019, Oracle and&#x2F;or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and&#x2F;or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; 也可以通过数据库管理工具连接MySQL，可参考MySQL数据库安装配置详细教程 可使用exit 命令退出1234mysql&gt; exitByeC:\Users\10287&gt; 创建数据库1234567891011121314mysql&gt; create database testdb;Query OK, 1 row affected (0.13 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || sys || testdb |+--------------------+9 rows in set (0.37 sec)mysql&gt; 删除数据库1234mysql&gt; drop database testdb;Query OK, 0 rows affected (0.35 sec)mysql&gt; create database testdb;Query OK, 1 row affected (0.13 sec) 数据表操作创建数据表首先选择一个数据库12mysql&gt; use testdb;Database changed进入testdb数据库后，创建一个名称为student的表12345678create table student( id int not null auto_increment primary key COMMENT &#x27;ID&#x27;, name varchar(10) not null COMMENT &#x27;姓名&#x27;, sex char(10) not null COMMENT &#x27;性别&#x27;, age tinyint(100) not null COMMENT &#x27;年龄&#x27;, dept char(4) not null COMMENT &#x27;专业&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC comment = &#x27;学生&#x27;; 删除数据表1drop table 表名 查看表结构1234567891011mysql&gt; desc student;+-------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | | NULL | || sex | char(10) | NO | | NULL | || age | tinyint(100) | NO | | NULL | || dept | char(4) | NO | | NULL | |+-------+--------------+------+-----+---------+----------------+5 rows in set (0.03 sec) 使用以下命令是一样的效果：12describe student;show columns from student;查看详细表结构1show full fields from student; 表结构修改常用语法格式:ALTER TABLE &lt;表名&gt; [修改选项]修改选项的语法格式如下:12345ADD COLUMN &lt;列名&gt; &lt;类型&gt; [after 插入位置]/*添加字段，或者在某列后插入列*/CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt; /*改变字段名*/MODIFY COLUMN &lt;列名&gt; &lt;类型&gt; /*修改字段类型*/DROP COLUMN &lt;列名&gt; /*删除字段*/RENAME TO &lt;新表名&gt; /*修改表名*/修改字段长度1alter table 表名 modify column 字段名 char(10); 1alter table 表名 auto_increment = 201215121; 增删改查插入数据语法：1insert into 表名(字段1,字段2) values(字段值1,字段值2)插入数据1234567891011mysql&gt; insert into Student (name, sex, age, dept) values (&#x27;张三&#x27;, &#x27;男&#x27;, 20, &#x27;通信&#x27;);Query OK, 1 row affected (0.45 sec)mysql&gt; select * from student;+----+------+-----+-----+------+| id | name | sex | age | dept |+----+------+-----+-----+------+| 1 | 张三 | 男 | 20 | 通信 |+----+------+-----+-----+------+1 row in set (0.03 sec)mysql&gt; 删除数据语法：12delete from 表名 where 字段名1= 字段值1delete from 表名 /*删除表里所有数据*/删除12345678910111213141516171819202122mysql&gt; delete from student;Query OK, 1 row affected (0.09 sec)mysql&gt; select * from student;Empty set (0.00 sec)mysql&gt; insert into Student (name, sex, age, dept) values (&#x27;张三&#x27;, &#x27;男&#x27;, 20, &#x27;通信&#x27;);Query OK, 1 row affected (0.07 sec)mysql&gt; insert into Student (name, sex, age, dept) values (&#x27;李四&#x27;, &#x27;男&#x27;, 22, &#x27;通信&#x27;);Query OK, 1 row affected (0.07 sec)mysql&gt; delete from student where name=&#x27;张三&#x27;;Query OK, 1 row affected (0.17 sec)mysql&gt; select * from student;+----+------+-----+-----+------+| id | name | sex | age | dept |+----+------+-----+-----+------+| 3 | 李四 | 男 | 22 | 通信 |+----+------+-----+-----+------+1 row in set (0.00 sec)mysql&gt; 更新数据语法：12update 表名 set 字段名1=字段值1 where 字段名2=字段值2update 表名 set 字段名1=字段值1 /*修改表里所有数据*/更新数据12345678910111213141516171819202122232425262728mysql&gt; update student set age=20 where name=&#x27;李四&#x27;;Query OK, 1 row affected (0.07 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from student;+----+------+-----+-----+------+| id | name | sex | age | dept |+----+------+-----+-----+------+| 3 | 李四 | 男 | 20 | 通信 |+----+------+-----+-----+------+1 row in set (0.00 sec)mysql&gt; update student set age=age+1;Query OK, 4 rows affected (0.79 sec)Rows matched: 4 Changed: 4 Warnings: 0mysql&gt; select * from student;+----+------+-----+-----+--------+| id | name | sex | age | dept |+----+------+-----+-----+--------+| 1 | 李四 | 男 | 21 | 通信 || 2 | 张三 | 男 | 21 | 通信 || 3 | 王二 | 男 | 23 | 计算机 || 4 | 小花 | 女 | 23 | 计算机 |+----+------+-----+-----+--------+4 rows in set (0.04 sec)mysql&gt; 查询数据再创建一个名称为score的表，记录成绩12345678create table score( sid int not null auto_increment primary key COMMENT &#x27;score ID&#x27;, student_id int(10) not null COMMENT &#x27;学号&#x27;, name varchar(10) not null COMMENT &#x27;姓名&#x27;, course char(10) not null COMMENT &#x27;课程&#x27;, grade tinyint(100) not null COMMENT &#x27;分数&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC comment = &#x27;成绩&#x27;; student和score两个表显示如下：12345678910111213141516171819202122232425262728mysql&gt; select * from student;+----+------+-----+-----+--------+| id | name | sex | age | dept |+----+------+-----+-----+--------+| 1 | 李四 | 男 | 20 | 通信 || 2 | 张三 | 男 | 20 | 通信 || 3 | 王二 | 男 | 22 | 计算机 || 4 | 小花 | 女 | 22 | 计算机 |+----+------+-----+-----+--------+4 rows in set (0.00 sec)mysql&gt; select * from score;+-----+------------+------+------------+-------+| sid | student_id | name | course | grade |+-----+------------+------+------------+-------+| 1 | 1 | 李四 | 高数 | 90 || 2 | 1 | 李四 | 英语 | 92 || 3 | 1 | 李四 | 经济学基础 | 88 || 4 | 2 | 张三 | 高数 | 80 || 5 | 2 | 张三 | 英语 | 85 || 6 | 2 | 张三 | 经济学基础 | 93 || 7 | 3 | 王二 | 高数 | 82 || 8 | 3 | 王二 | 英语 | 98 || 9 | 3 | 王二 | 经济学基础 | 80 |+-----+------------+------+------------+-------+9 rows in set (0.00 sec)mysql&gt; 查询语法：1select * from 表名123456789101112mysql&gt; select * from student;+----+------+-----+-----+--------+| id | name | sex | age | dept |+----+------+-----+-----+--------+| 1 | 李四 | 男 | 20 | 通信 || 2 | 张三 | 男 | 20 | 通信 || 3 | 王二 | 男 | 22 | 计算机 || 4 | 小花 | 女 | 22 | 计算机 |+----+------+-----+-----+--------+4 rows in set (0.00 sec)mysql&gt; where 关键词查询：select 列名称 from 表名称 where 条件;where关键词支持如下运算： =、&gt;、&lt;、&gt;=、&lt;>、!= is [not] null、in、like 支持 or 和 and 组合查询 123456789101112131415161718192021222324252627282930313233343536mysql&gt; select * from student where age &gt; 20;+----+------+-----+-----+--------+| id | name | sex | age | dept |+----+------+-----+-----+--------+| 3 | 王二 | 男 | 22 | 计算机 || 4 | 小花 | 女 | 22 | 计算机 |+----+------+-----+-----+--------+2 rows in set (0.71 sec)mysql&gt; select * from student where age &gt; 20 and sex = &#x27;女&#x27;;+----+------+-----+-----+--------+| id | name | sex | age | dept |+----+------+-----+-----+--------+| 4 | 小花 | 女 | 22 | 计算机 |+----+------+-----+-----+--------+1 row in set (0.03 sec)mysql&gt; select * from student where dept like &#x27;计算%&#x27;;+----+------+-----+-----+--------+| id | name | sex | age | dept |+----+------+-----+-----+--------+| 3 | 王二 | 男 | 22 | 计算机 || 4 | 小花 | 女 | 22 | 计算机 |+----+------+-----+-----+--------+2 rows in set (0.00 sec)mysql&gt; select * from student where dept like &#x27;计算_&#x27;;+----+------+-----+-----+--------+| id | name | sex | age | dept |+----+------+-----+-----+--------+| 3 | 王二 | 男 | 22 | 计算机 || 4 | 小花 | 女 | 22 | 计算机 |+----+------+-----+-----+--------+2 rows in set (0.00 sec)mysql&gt; 嵌套查询：查询李四同学的高数成绩（注意可能存在同名的，所以可以添加学号来组合查询）12345678mysql&gt; select student_id, name, course, grade from score where student_id in (select id from student where name=&#x27;李四&#x27;) and course=&#x27;高数&#x27;;+------------+------+--------+-------+| student_id | name | course | grade |+------------+------+--------+-------+| 1 | 李四 | 高数 | 90 |+------------+------+--------+-------+1 row in set (0.00 sec) 连接查询join多表查询 insert into Student (name, sex, age, dept) values (‘小花’, ‘女’, 22, ‘计算机’); 右连接 right joinright join 是 right outer join的简写，全称右外连接，是外连接中的一种。语句:1SELECT * FROM student a right outer join b on a.a_id = b.b_id;连接student和score：12345678910111213141516mysql&gt; SELECT * FROM student a right outer join score b on a.name = b.name;+------+------+------+------+--------+-----+------------+------+------------+-------+| id | name | sex | age | dept | sid | student_id | name | course | grade |+------+------+------+------+--------+-----+------------+------+------------+-------+| 1 | 李四 | 男 | 21 | 通信 | 1 | 1 | 李四 | 高数 | 90 || 1 | 李四 | 男 | 21 | 通信 | 2 | 1 | 李四 | 英语 | 92 || 1 | 李四 | 男 | 21 | 通信 | 3 | 1 | 李四 | 经济学基础 | 88 || 2 | 张三 | 男 | 21 | 通信 | 4 | 2 | 张三 | 高数 | 80 || 2 | 张三 | 男 | 21 | 通信 | 5 | 2 | 张三 | 英语 | 85 || 2 | 张三 | 男 | 21 | 通信 | 6 | 2 | 张三 | 经济学基础 | 93 || 3 | 王二 | 男 | 23 | 计算机 | 7 | 3 | 王二 | 高数 | 82 || 3 | 王二 | 男 | 23 | 计算机 | 8 | 3 | 王二 | 英语 | 98 || 3 | 王二 | 男 | 23 | 计算机 | 9 | 3 | 王二 | 经济学基础 | 80 |+------+------+------+------+--------+-----+------------+------+------------+-------+9 rows in set (0.09 sec) 注意：与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL 示例sql:1234567891011121314151617mysql&gt; SELECT student.id, student.name, score.course, score.grade FROM student RIGHT JOIN score ON student.id = score.sid;+------+------+------------+-------+| id | name | course | grade |+------+------+------------+-------+| 1 | 李四 | 高数 | 90 || 2 | 张三 | 英语 | 92 || 3 | 王二 | 经济学基础 | 88 || 4 | 小花 | 高数 | 80 || NULL | NULL | 英语 | 85 || NULL | NULL | 经济学基础 | 93 || NULL | NULL | 高数 | 82 || NULL | NULL | 英语 | 98 || NULL | NULL | 经济学基础 | 80 |+------+------+------------+-------+9 rows in set (0.00 sec)mysql&gt; 内连接查询 inner join语句:1select * from a_table a inner join b_table b on a.a_id=b.b_id;说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集部分; 内连接查询，示例sql:123456789101112mysql&gt; SELECT student.id, student.name, score.course, score.grade FROM student INNER JOIN score ON student.id = score.sid;+----+------+------------+-------+| id | name | course | grade |+----+------+------------+-------+| 1 | 李四 | 高数 | 90 || 2 | 张三 | 英语 | 92 || 3 | 王二 | 经济学基础 | 88 || 4 | 小花 | 高数 | 80 |+----+------+------------+-------+4 rows in set (0.00 sec)mysql&gt; 左连接查询 left joinleft join是 left outer join的简写,它的全称是左外连接，是外连接中的一种。语句:1SELECT * FROM a_table a left join b_table b ON a.a_id = b.b_id 说明：左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。 示例sql:1234567891011121314151617181920212223242526272829mysql&gt; SELECT student.id, student.name, score.course, score.grade FROM student LEFT JOIN score ON student.id = score.sid;+----+------+------------+-------+| id | name | course | grade |+----+------+------------+-------+| 1 | 李四 | 高数 | 90 || 2 | 张三 | 英语 | 92 || 3 | 王二 | 经济学基础 | 88 || 4 | 小花 | 高数 | 80 |+----+------+------------+-------+4 rows in set (0.00 sec)mysql&gt; SELECT student.id, student.name, score.course, score.grade FROM student LEFT JOIN score ON student.name = score.name;+----+------+------------+-------+| id | name | course | grade |+----+------+------------+-------+| 1 | 李四 | 高数 | 90 || 1 | 李四 | 英语 | 92 || 1 | 李四 | 经济学基础 | 88 || 2 | 张三 | 高数 | 80 || 2 | 张三 | 英语 | 85 || 2 | 张三 | 经济学基础 | 93 || 3 | 王二 | 高数 | 82 || 3 | 王二 | 英语 | 98 || 3 | 王二 | 经济学基础 | 80 || 4 | 小花 | NULL | NULL |+----+------+------------+-------+10 rows in set (0.00 sec)mysql&gt; --THE END--]]></content>
      <categories>
        <category>测试开发</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记：Python装饰器]]></title>
    <url>%2Fposts%2Fpython-notes-for-decorator%2F</url>
    <content type="text"><![CDATA[装饰器是通过装饰器函数修改原函数的一些功能而不需要修改原函数，在很多场景可以用到它，比如① 执行某个测试用例之前，判断是否需要登录或者执行某些特定操作；② 统计某个函数的执行时间；③ 判断输入合法性等。合理使用装饰器可以极大地提高程序的可读性以及运行效率。本文将介绍Python装饰器的使用方法。 python简单装饰器python装饰器可以定义如下：123456789101112def my_decorator(func): def wrapper(*args, **kwargs): print(&#x27;this is wrapper&#x27;) func(*args, **kwargs) print(&#x27;bye&#x27;) return wrapperdef test_decorator(message): print(message)decorator = my_decorator(test_decorator)decorator(&#x27;hello world&#x27;) 输出：123this is wrapperhello worldbyepython解释器将test_decorator函数作为参数传递给my_decorator函数，并指向了内部函数 wrapper()，内部函数 wrapper() 又会调用原函数 test_decorator()，所以decorator()的执行会先打印’this is wrapper’，然后打印’hello world’， test_decorator()执行完成后，打印 ‘bye’ ，*args和**kwargs，表示接受任意数量和类型的参数。 装饰器 my_decorator() 把真正需要执行的函数 test_decorator() 包裹在其中，并且改变了它的行为，但是原函数 test_decorator() 不变。 一般使用如下形式使用装饰器： 12345@my_decoratordef test_decorator(message): print(message)test_decorator(&#x27;hello world&#x27;) @my_decorator就相当于 decorator = my_decorator(test_decorator) 语句。 functools()内置装饰器@functools.wrap可用于保留原函数的元信息（将原函数的元信息，拷贝到对应的装饰器函数里）。先来看看没有使用functools的情况： 1234567891011121314def my_decorator(func): def wrapper(*args, **kwargs): print(&#x27;this is wrapper&#x27;) func(*args, **kwargs) return wrapper@my_decoratordef test_decorator(message): print(message)test_decorator(&#x27;hello world&#x27;)print(test_decorator.__name__)print(&quot;######&quot;)help(test_decorator) 输出：1234567this is wrapperhello worldwrapper######Help on function wrapper in module __main__:wrapper(*args, **kwargs) 从上面的输出可以看出test_decorator() 函数被装饰以后元信息被wrapper() 函数取代了，可以使用@functools.wrap装饰器保留原函数的元信息： 1234567891011121314151617import functoolsdef my_decorator(func): @functools.wraps(func) def wrapper(*args, **kwargs): print(&#x27;this is wrapper&#x27;) func(*args, **kwargs) return wrapper@my_decoratordef test_decorator(message): print(message)test_decorator(&#x27;hello world&#x27;)print(test_decorator.__name__)print(&quot;######&quot;)help(test_decorator) 输出：1234567this is wrapperhello worldtest_decorator######Help on function test_decorator in module __main__:test_decorator(message) 带参数的装饰器装饰器可以接受自定义参数。比如定义一个参数来设置装饰器内部函数的执行次数： 1234567891011121314def repeat(count): def my_decorator(func): def wrapper(*args, **kwargs): for i in range(count): print(f&#x27;counter: &#123;i&#125;&#x27;) func(*args, **kwargs) return wrapper return my_decorator@repeat(4)def test_decorator(message): print(message)test_decorator(&#x27;hello world&#x27;) 输出：12345counter: 0counter: 1counter: 2counter: 3hello world 装饰器的嵌套Python 支持多个装饰器嵌套： 12345@decorator1@decorator2@decorator3def func(): ... 嵌套示例123456789101112131415161718192021222324252627282930313233import functoolsdef decorator1(func): @functools.wraps(func) def wrapper(*args, **kwargs): print(&#x27;decorator1&#x27;) func(*args, **kwargs) return wrapperdef decorator2(func): @functools.wraps(func) def wrapper(*args, **kwargs): print(&#x27;decorator2&#x27;) func(*args, **kwargs) return wrapperdef decorator3(func): @functools.wraps(func) def wrapper(*args, **kwargs): print(&#x27;decorator3&#x27;) func(*args, **kwargs) return wrapper@decorator1@decorator2@decorator3def test_decorator(message): print(message)test_decorator(&#x27;hello world&#x27;) 装饰的过程： wrapper3 = decorator3(test_decorator) wrapper2 = decorator2(wrapper3) wrapper1 = decorator1(wrapper2) test_decorator = wrapper1 顺序从里到外：1decorator1(decorator2(decorator3(func)))test_decorator(‘hello world’) 执行顺序和装饰的过程相反。 输出：1234decorator1decorator2decorator3hello world 类装饰器类也可以作为装饰器，类装饰器主要依赖__call__()方法，是python中所有能被调用的对象具有的内置方法（python魔术方法），每当调用一个类的实例时，__call__()就会被执行一次。 下面的类装饰器实现统计函数执行次数：12345678910111213141516class Count: def __init__(self, func): self.func = func self.num_calls = 0 def __call__(self, *args, **kwargs): self.num_calls += 1 print(f&#x27;num of calls is: &#123;self.num_calls&#125;&#x27;) return self.func(*args, **kwargs)@Countdef test_decorator(): print(&quot;hello world&quot;)test_decorator()test_decorator()输出：1234num of calls is: 1hello worldnum of calls is: 2hello world 装饰器使用实例下面介绍两种装饰器使用场景 统计函数执行时间统计函数执行所花费的时间1234567891011121314151617181920212223import functoolsimport timedef timer(func): # 统计函数执行时间 @functools.wraps(func) def wrapper_timer(*args, **kwargs): start_time = time.perf_counter() value = func(*args, **kwargs) end_time = time.perf_counter() run_time = end_time - start_time print(f&quot;&#123;func.__name__&#125; 执行时间为：&#123;run_time:.4f&#125; 秒&quot;) return value return wrapper_timer@timerdef test_sum(num): sum = 0 for i in range(num+1): sum = sum + i print(sum) test_sum(100000)输出：125000050000test_sum 执行时间为：0.0046 秒 登录认证在使用某些web服务时，需要先判断用户是否登录，如果没有登录就跳转到登录页面或者提示用户登录：12345678910111213141516import functoolsdef authenticate(func): @functools.wraps(func) def wrapper_login(*args, **kwargs): request = args[0] if check_user_logged_in(request): # 判断用户是否处于登录状态 return func(*args, **kwargs) # 执行函数secret() else: return redirect(url_for(&quot;login&quot;, next=request.url)) # 跳转登录页面 return wrapper_login @authenticatedef secret() ... --THE END--]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium自动化测试框架介绍]]></title>
    <url>%2Fposts%2Fselenium-architecture-introduce%2F</url>
    <content type="text"><![CDATA[本文简要介绍Selenium 的Webdriver 架构，我对selenium的相关知识点进行了整理，大家可免费下载：Selenium自动化测试框架详细介绍ppt及示例脚本.rar Selenium简介Selenium是浏览器的自动化测试工具，与浏览器进行交互，实现对web应用的自动化测试，Selenium包括Selenium IDE, Selenium Webdriver 和 Selenium Grid三个工具。 Selenium IDE (Integrated Development Environment)是一个浏览器插件，提供脚本录制、脚本生成和回放功能，初次使用selenium的新手可以用它来做一些简单的测试， Selenium Webdriver 是一个浏览器自动化框架，接受脚本命令并发送到浏览器（通过浏览器驱动来实现），支持多种语言（包括Java, Ruby, Python, PHP, JavaScript, C#等）和多种浏览器，并且支持windows，Linux，macOS等操作系统。 Selenium Grid实现在多个机器上并行运行 selenium，也就是同时在多个机器上执行测试，并且可以是不同的浏览器和操作系统（跨平台）。 下面详细介绍一下Selenium Webdriver 架构。 Selenium Webdriver 架构Selenium Webdriver API实现脚本语言与浏览器之间的通信，Selenium Webdriver 架构包括四个基本组件: Selenium Language Bindings/Selenium Client Library：Selenium语言绑定/客户端库 JSON Wire Protocol：JSON有线协议 Browser Driver：浏览器驱动 Browser：浏览器 Selenium支持多种语言，包括Ruby、Java、Python、C#、JavaScript、GO、Haskell、JavaScript、Perl、PHP、R和Dart。可参考网站：https://www.selenium.dev/downloads/#client-drivers 。执行测试用例时，selenium 代码将被转换为JSON格式，发送给浏览器驱动。 JSON(JavaScript Object Notation)是一种用于在Web上交换数据的开放标准。JSON有线协议是一种REST API ，基于HTTP协议实现selenium客户端与remote server（浏览器驱动的HTTP服务器）的交互，浏览器驱动（HTTP server）接收到命令（HTTP requests）后，将请求发送到对应的浏览器上执行，并返回HTTP响应。如果是POST请求，将在浏览器上执行相应的操作；如果发送的是GET请求，浏览器将发送HTTP响应，发送到浏览器驱动，然后浏览器驱动使用JSON有线协议将响应发送到客户端。 不同的浏览器对应各自的驱动程序，驱动下载和使用方法可参考官方文档：https://www.selenium.dev/documentation/en/webdriver/driver_requirements/ ，或者参考文章Selenium多浏览器测试。]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库安装配置详细教程]]></title>
    <url>%2Fposts%2Fmysql-install-for-linux-and-windows%2F</url>
    <content type="text"><![CDATA[本文介绍MySQL 在 Windows系统和Linux系统安装方法。 Windows系统安装MySQL1、下载下载地址：https://dev.mysql.com/downloads/mysql/选择要下载的MySQL版本 2、解压zip包解压下载的zip压缩包 3、配置环境变量在Path下添加D:\tools\mysql-8.0.16-winx64\bin 4、编写配置文件在安装根目录下添加my-default.ini文件：D:\tools\mysql-8.0.16-winx64\my-default.ini123456789101112131415161718192021222324[mysqld]# 3306端口port=3306# mysql的安装目录basedir=D:\tools\mysql-8.0.16-winx64# 设置mysql数据库的数据的存放目录datadir=D:\tools\mysql-8.0.16-winx64\data# 允许最大连接数max_connections=200# 允许连接失败的次数，防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 5、MySQL服务安装12mysqld --install MySQLmysqld install 报错1：信息如下：Install/Remove of the Service Denied解决办法：打开cmd.exe程序的时候选择“用管理员身份打开”。 报错2：123C:\WINDOWS\system32&gt;mysqld --install MySQLThe service already exists!The current server installed: D:\xampp\mysql\bin\mysqld MySQL解决办法：1mysqld -remove MySQL 6、MySQL初始化在MySQL安装目录的 bin 目录下执行命令：1mysqld --initialize --console执行完成后，会打印 root 用户的初始默认密码：1234C:\WINDOWS\system32&gt;mysqld --initialize --console2019-05-15T09:27:48.338369Z 0 [System] [MY-013169] [Server] D:\tools\mysql-8.0.16-winx64\bin\mysqld.exe (mysqld 8.0.16) initializing of server in progress as process 153082019-05-15T09:28:50.242794Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: u#vTkx6L:dg,2019-05-15T09:29:42.201421Z 0 [System] [MY-013170] [Server] D:\tools\mysql-8.0.16-winx64\bin\mysqld.exe (mysqld 8.0.16) initializing of server has completed启动MySQL服务1net start mysql 7、更改密码和密码认证插件进入D:\tools\mysql-8.0.16-winx64\bin路径下，执行1mysql -u root -p然后输入第6步的密码：u#vTkx6L:dg 然后修改用户密码，在MySQL中执行命令：1ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;; 8、查看默认数据库mysql初始化完成后，初始化了名为mysql数据库，其中user表里面存储MySQL用户信息。123mysql&gt; show databases;mysql&gt; use mysql;mysql&gt; show tables; 123# 显示user表结构mysql&gt; desc user;mysql&gt; select user,host,authentication_string from mysql.user; 添加新的用户除了管理员root用户，也可以添加其他用户。 允许本地 IP访问localhost的Mysql数据库12mysql&gt; create user &#39;admin&#39;@&#39;localhost&#39; identified by &#39;admin&#39;;Query OK, 0 rows affected (0.22 sec) 允许外网IP访问数据库允许开放其他ip登录，添加权限123456mysql&gt; create user &#39;admin&#39;@&#39;%&#39; identified by &#39;admin&#39;; Query OK, 0 rows affected (0.08 sec)mysql&gt; GRANT ALL PRIVILEGES ON e_menu.* TO &#39;admin&#39;@&#39;%&#39; WITH GRANT OPTION; &#x2F;&#x2F;将数据库e_menu授权给admin用户 Query OK, 0 rows affected (0.15 sec)mysql&gt; flush privileges; &#x2F;&#x2F;刷新授权Query OK, 0 rows affected (0.05 sec) 注意：上面的授权命令适用于MySQL8.0及之后的版本，MySQL8.0之前的版本使用如下命令授权1grant all privileges on 库名.表名 to &#39;用户名&#39;@&#39;IP地址&#39; identified by &#39;密码&#39; with grant option;授权基本的查询修改权限：1GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON 库名.表名 TO &#39;用户名&#39;@&#39;IP地址&#39;; 撤销用户权限1revoke all privileges on *.* from &#39;用户名&#39;@&#39;IP地址&#39;; 查看用户权限1show grants for &#39;用户名&#39;@&#39;IP地址&#39;; 查看MYSQL数据库中所有用户1234567891011121314mysql&gt; SELECT DISTINCT CONCAT(&#39;User: &#39;&#39;&#39;,user,&#39;&#39;&#39;@&#39;&#39;&#39;,host,&#39;&#39;&#39;;&#39;) AS query FROM mysql.user;+---------------------------------------+| query |+---------------------------------------+| User: &#39;admin&#39;@&#39;%&#39;; || User: &#39;admin&#39;@&#39;localhost&#39;; || User: &#39;mysql.infoschema&#39;@&#39;localhost&#39;; || User: &#39;mysql.session&#39;@&#39;localhost&#39;; || User: &#39;mysql.sys&#39;@&#39;localhost&#39;; || User: &#39;root&#39;@&#39;localhost&#39;; |+---------------------------------------+6 rows in set (0.04 sec)mysql&gt; Linux系统安装MySQL：Docker安装Linux系统推荐使用docker安装，简单方便。如果没有安装docker，需要先安装一下，可参考 容器技术介绍：Docker简介及安装 1、查看可用的 MySQL 版本先查看一下可以安装的 MySQL 版本，MySQL镜像的可用版本可在docker hub中搜索查看：https://hub.docker.com/_/mysql?tab=tags 2、拉取 MySQL 镜像拉取指定版本的MySQL1$ docker pull mysql:5.7查看是否安装MySQL镜像123456$ docker images[root@server ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEjenkins/jenkins latest 10fafa8484ea 4 weeks ago 721MBnginx latest f6d0b4767a6c 4 weeks ago 133MBmysql 5.7 9cfcce23593a 8 months ago 448MB 3、运行容器运行 mysql 容器：1$ docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 —name mysql-test：设置容器名 -p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口。 MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。 查看MySQL镜像是否启动成功：1234$ docker ps[root@server ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2c5ae10a7543 mysql:5.7 &quot;docker-entrypoint.s…&quot; 7 months ago Up 23 minutes 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-test 4、进入mysql容器1$ docker exec -it 容器ID或者容器名 /bin/bash 12345[root@server ~]# docker exec -it mysql-test /bin/bashroot@2c5ae10a7543:/# exitexit[root@server ~]# docker exec -it 2c5ae10a7543 /bin/bashroot@2c5ae10a7543:/# 通过 root 和密码 123456 访问 MySQL 服务 5、查看mysql镜像的ip地址方法一1$ docker inspect mysql-test方法二1234567891011121314[root@server local]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3bab7ac2a2af jenkins/jenkins:lts &quot;/sbin/tini -- /usr/…&quot; 9 hours ago Up 9 hours 0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:50000-&gt;50000/tcp jenkins2c5ae10a7543 mysql:5.7 &quot;docker-entrypoint.s…&quot; 6 days ago Up 8 hours 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-test[root@server local]# docker exec -it mysql-test bashroot@2c5ae10a7543:/# cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.3 2c5ae10a7543root@2c5ae10a7543:/#命令行连接mysql123456789101112131415root@2c5ae10a7543:&#x2F;# mysql -h 172.17.0.3 -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 8Server version: 5.7.30 MySQL Community Server (GPL)Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and&#x2F;or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; 6、增加远程访问docker MySQL权限在步骤4中，可以进入mysql容器后连接mysql数据库，那么怎么在外面（我的docker mysql安装在centos虚拟机中，想在宿主机上连接docker安装的mysql）也可以连接mysql容器呢？ 前面已经讲过授权其他IP访问mysql，这里类似。先进入docker mysql容器内，连接mysql数据库，然后对root账户进行授权： 123456789101112131415161718root@2c5ae10a7543:&#x2F;# mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.7.30 MySQL Community Server (GPL)Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and&#x2F;or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;Query OK, 0 rows affected, 1 warning (0.66 sec)mysql&gt; 授权成功后，在宿主机上连接虚拟机上docker安装的mysql：123456789101112131415161718192021222324252627C:\WINDOWS\system32&gt;mysql -h 192.168.30.8 -P 3306 -u root -pEnter password: ******Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.30 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and&#x2F;or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and&#x2F;or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.mysql&gt; select user,host,authentication_string from mysql.user;+---------------+-----------+-------------------------------------------+| user | host | authentication_string |+---------------+-----------+-------------------------------------------+| root | localhost | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 || mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || root | % | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 |+---------------+-----------+-------------------------------------------+4 rows in set (0.11 sec)mysql&gt;连接成功！ 数据库管理工具连接MySQL除了通过命令行连接管理数据库，为了更加方便管理mysql数据库，有很多数据库管理工具可以通过GUI界面管理数据库，下面介绍数据库管理工具MySQL Workbench连接数据库方法。 MySQL Workbench是MySQL官方自带的免费管理工具，下载地址：https://dev.mysql.com/downloads/workbench/ 1. 连接宿主机安装的mysql安装成功后打开Workbench，添加连接，设置连接名，配置主机名，用户名。输入密码，连接成功，可以看到数据库 2. 连接虚拟机安装的docker mysql添加连接，设置连接名，配置主机名，用户名输入密码，连接成功 也可以使用Navicat工具连接数据库，连接方法类似 --THE END--]]></content>
      <categories>
        <category>测试开发</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成平台Jenkins介绍]]></title>
    <url>%2Fposts%2Fcontinuous-integration-for-jenkins%2F</url>
    <content type="text"><![CDATA[持续集成（Continuous integration，CI）是软件开发和发布流程中最重要的组成部分，有利于加快开发进度。Jenkins是常用的持续集成管理工具，本文将简要介绍Jenkins持续集成工具。 持续集成简介持续集成（Continuous integration，CI）概念由Martin Fowler 于2006年提出：https://martinfowler.com/， 频繁地（一天多次）将代码集成到主干。 Continuous Integration doesn’t get rid of bugs, but it does make them dramatically easier to find and remove.Martin Fowler, Chief Scientist, ThoughtWorks 持续集成好处： 快速发现错误：持续自动化测试，可以快速发现和定位错误，节约时间。 易于定位项目进度，使项目更加透明。 导致更快的发布 Jenkins介绍Jenkins官网：https://www.jenkins.io/Jenkins官网文档：https://www.jenkins.io/doc/ Jenkins是免费开源的持续集成管理工具，基于Java开发，可以跨平台运行，提供持续集成和持续交付服务 ( continuous integration or continuous delivery，CI/CD)，自动化软件开发流程中的构建、测试和部署工作。Jenkins插件丰富，有超过1000个插件来支持构建、部署自动化，满足任何项目的需要。 持续集成工具比较：https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software Docker Jenkins安装和启动方法参考：Docker搭建持续集成平台Jenkins Jenkins更新进入Manage Jenkins，提示新版本，点击下载 jenkins.war 包。 1. jenkins.war 位置查看方法1：Manage Jenkins中查看点击进入Manage Jenkins，找到Status Information，点击System Information，可以查看war包位置 方法2：find命令查找 使用root账号进入容器中后使用find命令查找12345678[root@server ~]# docker exec -it -u root jenkins bashroot@ed883da9faab:/# find / -name jenkins.warfind: ‘/proc/1/map_files’: Operation not permittedfind: ‘/proc/7/map_files’: Operation not permittedfind: ‘/proc/138/map_files’: Operation not permittedfind: ‘/proc/155/map_files’: Operation not permitted/usr/share/jenkins/jenkins.warroot@ed883da9faab:/# 2. 更新容器中的war包使用root账号进入容器中，备份原来的war包123[root@server ~]# docker exec -it -u root jenkins bashroot@ed883da9faab:/# cd /usr/share/jenkinsroot@ed883da9faab:/usr/share/jenkins# mv jenkins.war jenkins.war.bak将下载的war包复制到容器目录 /usr/share/jenkins 下（注意是在宿主机上操作）1234[root@server ~]# docker cp jenkins.war jenkins:/usr/share/jenkins/[root@server ~]# docker exec -it -u root jenkins bashroot@ed883da9faab:/usr/share/jenkins# lsjenkins.war jenkins.war.bak ref 3. 重启Jenkins1$ docker restart jenkins 刷新页面，登陆，进入Manage Jenkins，可以看到版本更新成功，可以降回原来的版本。 Jenkins配置系统配置进入Manage Jenkins -&gt; System Configuration -&gt; Configure System进行系统配置，有很多配置参数可以配置，比如： Jenkins URL：服务器域名 管理员邮箱 Github配置 默认 Shell：bash 等 配置 Shell比如在windows代理节点中，默认命令行使用cmd，如果你想使用Git Bash，可以在系统配置中进行配置。进入Manage Jenkins -&gt; System Configuration -&gt; Configure System，下拉到shell，配置Shell executable为你的命令行文件路径，比如我的git bash路径为：D:/tools/Git/bin/sh.exe 插件管理Jenkins插件众多，扩展了很多功能。进入Manage Jenkins -&gt; System Configuration -&gt; Manage Plugins进行插件的管理。 可以先点击Advanced 设置更新网址URL：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 然后进行插件的安装更新操作， 插件的安装方法，在Available中的输入框输入要安装的插件名称关键字进行搜索，选择要安装的插件，点击“Download now and install after restart”进行下载安装。 Jenkins推荐插件： Multiple SCMs plugin Rebuilder Safe Restart Plugin Pipeline Text Finder Blue Ocean Allure 用户权限控制在Jenkins的初始化安装过程中会先注册一个管理员用户，管理员用户可以创建一般用户，管理员用户具有最高权限。 进入Manage Jenkins -&gt; Security -&gt; Configure Global Security进行安全配置可以勾选允许用户注册，团队人数较少时，一般建议不勾选，由管理员创建 进入Manage Jenkins -&gt; Security -&gt; Manage Users进行用户管理，可以进行用户删除、修改和添加操作 权限控制在Manage Jenkins -&gt; Security -&gt; Configure Global Security -&gt; Authorization下可以选择【安全矩阵】（个人权限）或者【项目矩阵】（项目权限）进行权限管理 slave节点管理在实际工作中，考虑到宿主机资源限制，可以采用多节点的方式，将任务分配到其他节点执行。通过添加多个Jenkins slave节点来执行Jenkins任务， Jenkins运行的主机称为 master节点： 节点上需要配置Java运行环境, Java_Version&gt;1.5 节点支持Windows, Linux，Mac系统 节点添加方式先查看是否配置了Java运行环境：12345[root@server /]# java -versionopenjdk version &quot;1.8.0_252&quot;OpenJDK Runtime Environment (build 1.8.0_252-b09)OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)[root@server /]# 进入Manage Jenkins -&gt; System Configuration -&gt; Manage Nodes and Clouds 1、添加Linux节点配置节点（注意我配置的slave节点为宿主机）：发现节点连接不成功 查看日志，发现没有known_hosts1/var/jenkins_home/.ssh/known_hosts [SSH] No Known Hosts file was found at /var/jenkins_home/.ssh/known_hosts. Please ensure one is created at this path and that Jenkins can read it.一种解决方法是，设置认证策略为手动信任 上线成功 2、添加Windows节点windows节点配置 节点连接方式第一种方式：点击Launch图标下载，双击运行下载的文件jenkins-agent.jnlp刷新，上线成功 第二种方式：1234java -jar agent.jar -jnlpUrl http://192.168.30.8:8080/computer/slave2/jenkins-agent.jnlp -secret 626402e3eee37788fa41ffa7353a2cc14f269028672a0af206b0f92e6578f364 -workDir &quot;D:\ProgramWorkspace\TestingDemo\jenkins&quot;# Run from agent command line, with the secret stored in a file:echo 626402e3eee37788fa41ffa7353a2cc14f269028672a0af206b0f92e6578f364 &gt; secret-filejava -jar agent.jar -jnlpUrl http://192.168.30.8:8080/computer/slave2/jenkins-agent.jnlp -secret @secret-file -workDir &quot;D:\ProgramWorkspace\TestingDemo\jenkins&quot; 启动jenkins时，开启了8080和50000端口（Docker搭建持续集成平台Jenkins），8080端口是jenkins服务器对外URL地址，50000端口为slave节点与jenkins的通讯端口，在默认情况下，基于JNLP的Jenkins代理通过TCP端口50000与Jenkins主站进行通信。 Windows查看50000端口占用：1234C:\Users\10287&gt;netstat -aon | findstr &quot;50000&quot; TCP 127.0.0.1:50000 0.0.0.0:0 LISTENING 8644 TCP 192.168.30.100:52297 192.168.30.8:50000 ESTABLISHED 10028Linux查看端口占用情况：123456789[root@server /]# lsof -i:8080COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdocker-pr 2787 root 4u IPv4 51423 0t0 TCP *:webcache (LISTEN)[root@server /]# lsof -i:50000COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdocker-pr 2775 root 4u IPv4 50675 0t0 TCP *:50000 (LISTEN)[root@server /]# netstat -aptn | grep 50000tcp 0 0 0.0.0.0:50000 0.0.0.0:* LISTEN 2775/docker-proxy [root@haiyong jenkins_home]# Jenkins创建项目创建项目 选择Freestyle project 项目配置可以发现一个job的组成部分包括： General：项目通用配置 Source Code Management：源代码控制，比如Git配置 Build Triggers：触发，构建时间配置（定期构建，代码变更构建） Build Environment Build：执行命令，比如执行shell Post-build Actions：执行完成后进行分析，生成报告，发送邮件等 构建完成 查看控制台输出 Jenkins父子多任务运行任务启动的触发条件：其他任务的运行结果 前驱任务成功的条件下被触发 前驱任务失败的条件下被触发 前驱任务不稳定的条件下被触发 适用于有先后次序关系的任务，比如 部署环境任务，验收测试任务 Jenkins配置成功任务关联1、新建第一个任务first_test 2、构建 3、新建第二个任务second_test 4、构建，设置触发方式设置为前驱任务稳定成功的条件下被触发 5、启动第一个任务first_test 控制台输出 可以看到second_test也成功了 前驱任务不稳定的条件下也被触发，可以使用Text Finder插件来构建不稳定条件 Jenkins配置失败任务关联前驱任务稳定成功的条件下被触发 Jenkins邮件报警Jenkins可以配置邮件通知，比如在Jenkins构建任务之后发送邮件通知，错误报警等 安装插件：Email Extension和Email Extension Template Jenkins配置 Email进入Manage Jenkins -&gt; System Configuration -&gt; Configure System 配置系统管理员e-mail地址 配置Extended E-mail Notification，注意SMTP Password不是邮箱密码，为你的邮箱授权码拉到最下面，配置邮件通知，配置完成后，可以发一个测试邮件，查看是否配置成功 Jenkins邮件模板配置Jenkins可以根据你配置的邮件模板格式来发送结果邮件，通过Jenkins的参数定制自己的Email模板，常用的参数key值如下: $BUILD_STATUS ：构建结果 $PROJECT_NAME ：构建脚本名称 $BUILD_NUMBER ：构建脚本编号 $JOB_DESCRIPTION ：构建项目描述 $CAUSE ：脚本启动原因 $BUILD_URL ：脚本构建详情URL地址 Default Subject1Jenkins构建提醒：$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS! Default Content12345678910111213141516171819&lt;hr/&gt;(自动化构建邮件，无需回复！)&lt;br/&gt;&lt;hr/&gt;项目名称：$PROJECT_NAME&lt;br/&gt;&lt;br/&gt;项目描述：$JOB_DESCRIPTION&lt;br/&gt;&lt;br/&gt;运行编号：$BUILD_NUMBER&lt;br/&gt;&lt;br/&gt;运行结果：$BUILD_STATUS&lt;br/&gt;&lt;br/&gt;触发原因：$&#123;CAUSE&#125;&lt;br/&gt;&lt;br/&gt;构建日志地址：&lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;构建地址：&lt;a href=&quot;$BUILD_URL&quot;&gt;$BUILD_URL&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;详情：$&#123;JELLY_SCRIPT,template=&quot;html&quot;&#125;&lt;br/&gt;&lt;hr/&gt; Jenkins报警规则在模板设置的下方有个 Default Triggers 按钮，点击后，设定报警规则 在job的构建后操作步骤选择” Editable Email Notification “ 配置完成后，构建项目，查看控制台输出 查看邮箱，发送成功！ --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试开发</category>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter性能监控系统：Jmeter + InfluxDB + Grafana]]></title>
    <url>%2Fposts%2Fperformance-testing-for-performance-monitoring-system%2F</url>
    <content type="text"><![CDATA[JMeter性能测试完成后，可以查看性能报告（参考JMeter性能测试：JMeter多用户并发模拟及压测结果分析），如果想查看实时的性能，可以搭建一个性能监控平台。本文介绍如何搭建JMeter性能测试的性能监控系统。 性能监控系统JMeter性能测试报告呈现的数据是某个时间段内的平均值，而性能监控平台可以实时的查看性能数据，而且有非常友好的图形界面。 JMeter性能监控平台组成 JMeter：性能测试工具，产生压测数据。官网地址：https://jmeter.apache.org/ InfluxDB：一种开源分布式时序数据库，使用Go语言开发，广泛应用于处理和分析资源监控数据，用于存储压测数据。官网地址：https://grafana.com/ Grafana：开源的度量分析与可视化工具，有非常漂亮的图表展示功能、齐全的度量仪表盘和图形编辑器，支持不用种类的数据源（比如InfluxDB和Prometheus），用于将存储于 InfluxDB中的数据以图表的形式展示出来。官网地址：https://grafana.com/ JMeter安装参考：JMeter性能测试：JMeter安装及脚本录制回放 InfluxDB安装GitHub仓库地址：https://github.com/influxdata/influxdb下载地址：https://portal.influxdata.com/downloads/参考文档：https://docs.influxdata.com/influxdb/v2.0/get-started/ docker安装：https://hub.docker.com/_/influxdb拉取influxDB镜像：1$ docker pull influxdb Grafana安装官方文档：https://grafana.com/docs/grafana/latest/Grafana dockerhub地址：https://hub.docker.com/r/grafana/grafana拉取镜像：1$ docker pull grafana/grafana查看镜像是否安装成功：1234[root@server ~]# docker images | egrep &#x27;grafana|influxdb&#x27; grafana/grafana latest 13afb861111c 6 weeks ago 187MBinfluxdb latest 0454d5d215cc 6 weeks ago 307MB[root@server ~]# 性能监控平台部署部署 InfluxDB1. 新建容器网络1$ docker network create grafana2. 运行容器12[root@server ~]# docker run -d -p 8086:8086 --name=influxdb --network=grafana -v $&#123;PWD&#125;/influxdb/:/var/lib/influxdb/ influxdb:latestaa079b4c24cfc95735613dc642c7d60064cf6c6e6c37ab561721de5825368c903. 创建数据库第一种方式 : HTTP请求方式1$ curl -i -XPOST http://localhost:8086/query --data-urlencode &quot;q=CREATE DATABASE jmeter&quot;第二种方式：进入 influxdb容器终端创建 123456789101112131415161718[root@server ~]# docker exec -it influxdb influxConnected to http://localhost:8086 version 1.8.3InfluxDB shell version: 1.8.3&gt; show databases;name: databasesname----_internal&gt; create database jmeter;&gt; &gt; show databases;name: databasesname----_internaljmeter&gt; exit[root@server ~]# 部署 Grafana1. 运行容器123456[root@server ~]# docker run -d -p 3000:3000 --name=grafana --network=grafana grafana/grafana:latest4a329f916f3182a5a742d921d1ed438ba837f57ab3955a45ff34c8e45ce236c5[root@server ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4a329f916f31 grafana/grafana:latest &quot;/run.sh&quot; 37 seconds ago Up 32 seconds 0.0.0.0:3000-&gt;3000/tcp grafanaaa079b4c24cf influxdb:latest &quot;/entrypoint.sh infl…&quot; 19 minutes ago Up 19 minutes 0.0.0.0:8086-&gt;8086/tcp influxdb 2. 登录Grafana浏览器输入URL：http://192.168.30.8:3000/其中192.168.30.8为我的服务器地址（部署Grafana的地址），用户名和密码为admin进入首页 3. 配置数据源点击Configuration -&gt; Data Sources -&gt; Add data source 选择InfluxDB 配置数据源：1）URL设置为: http://influxdb:8086 ：容器名为influxdb，也可以使用容器的IP地址，查看IP地址方法：1234567891011[root@haiyong ~]# docker exec -it influxdb sh# cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.18.0.2 aa079b4c24cf# exit[root@haiyong ~]# 或者使用 docker inspect influxdb 命令查看 2）Database为 jmeter3）Min time interval: 5 设置完成后，点击Save&amp;Test，提示数据源设置成功 4. 选择显示面板显示面板可以自己开发，也可以使用其他开发好的面板，在https://grafana.com/grafana/dashboards 中搜索选择。我使用的是：https://grafana.com/grafana/dashboards/5496 点击Dashboards -&gt; Manage -&gt; Import输入jmeter dashboard url，点击load，配置DB name、Measurement name和Backend send interval 点击Import 好了，InfluxDB和Grafana都配置成功了，下面配置JMeter进行压测 JMeter性能监控在JMeter创建压测任务，创建方法可参考：JMeter性能测试：JMeter多用户并发模拟及压测结果分析 JMeter配置监听器添加Backend Listener，Backend Listener的作用是将压测数据传到 InfluxDB中，JMeter支持 InfluxDB和Graphite数据库Thread Group -&gt; Add -&gt; Listenter -&gt; Backend ListenerBackend Listener应用选择InfluxDB 配置influxdbUrl：http://192.168.30.8:8086/write?db=jmeter application名设置为test666 measurement名设置为jmeter summaryOnly：如果设置为false，在Grafana面板里面的Errors会显示错误的请求信息 配置Grafanaapplication名和JMeter上设置相同的名称，设置刷新时间为5s JMeter运行压测 查看InfluxDB数据库压测数据存到了InfluxDB数据库里面，Grafana显示的就是这里面的数据。123456789101112131415161718192021222324252627[root@server ~]# docker exec -it influxdb influxConnected to http://localhost:8086 version 1.8.3InfluxDB shell version: 1.8.3&gt; &gt; &gt; use jmeter;Using database jmeter&gt; select * from jmeter limit 3;name: jmetertime application avg count countError endedT hit max maxAT meanAT min minAT pct90.0 pct95.0 pct99.0 rb responseCode responseMessage sb startedT statut transaction---- ----------- --- ----- ---------- ------ --- --- ----- ------ --- ----- ------- ------- ------- -- ------------ --------------- -- -------- ------ -----------1614435482883000000 test666 0 0 0 0 0 internal1614435483240000000 test666 0 0 0 0 1 internal1614435485281000000 test666 0 0 0 0 1 internal&gt; &gt; select * from events;name: eventstime application text title---- ----------- ---- -----1614437117192000000 test666 test started ApacheJMeter1614437488496000000 test666 test ended ApacheJMeter1614437552834000000 test666 test started ApacheJMeter1614437566732000000 test666 test ended ApacheJMeter1614437586119000000 test666 test started ApacheJMeter1614437722290000000 test666 test ended ApacheJMeter&gt; --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Grafana</tag>
        <tag>Jmeter</tag>
        <tag>InfluxDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker搭建持续集成平台Jenkins]]></title>
    <url>%2Fposts%2Fcontainer-docker-for-jenkins-install%2F</url>
    <content type="text"><![CDATA[本文介绍使用docker来安装Jenkins服务的步骤。 Docker搭建Jenkins1. 安装Jenkins docker hub地址: https://hub.docker.com/r/jenkins/jenkins1docker pull jenkins/jenkins1234567891011121314151617181920212223242526[root@server /]# docker pull jenkins/jenkinsUsing default tag: latestlatest: Pulling from jenkins/jenkins3192219afd04: Already exists 17c160265e75: Already exists cc4fe40d0e61: Already exists 9d647f502a07: Already exists d108b8c498aa: Already exists 1bfe918b8aa5: Already exists dafa1a7c0751: Already exists c69d355c63ac: Pull complete b15898bb1800: Pull complete a51ccfc981f7: Pull complete 49f46bd4bf74: Pull complete efa670fd97de: Pull complete 1565294bcba3: Pull complete 4c51bcfbed1e: Pull complete 49f4fafbfbf2: Pull complete 28a75541fa5f: Pull complete c3c03c2d5564: Pull complete ace64d1af7cf: Pull complete f1960af3b8ab: Pull complete 6fd1a5a6d017: Pull complete Digest: sha256:e4630b9084110ad05b4b51f5131d62161881216d60433d1f2074d522c3dcd6dcStatus: Downloaded newer image for jenkins/jenkins:latestdocker.io/jenkins/jenkins:latest 2. 创建docker的文件影射卷创建docker的文件影射卷，用于存储数据1234567891011121314[root@server tmp]# docker volume create jenkins_test[root@server tmp]# docker volume inspect jenkins_test[ &#123; &quot;CreatedAt&quot;: &quot;2020-07-18T10:49:17+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: &#123;&#125;, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/jenkins_test/_data&quot;, &quot;Name&quot;: &quot;jenkins_test&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Scope&quot;: &quot;local&quot; &#125;][root@server tmp]# 3. 运行: 创建实例创建一个挂载目录jenkins，添加可执行权限：chmod 777 jenkins 1docker run --name=jenkins -d -p 8080:8080 -p 50000:50000 -v jenkins_test:/var/jenkins_home jenkins/jenkins 运行：123456[root@server /]# docker run --name=jenkins -d -p 8080:8080 -p 50000:50000 -v jenkins_test:/var/jenkins_home jenkins/jenkinsc7fb87aec99402febd95edddda5cf1dc7ad15437f674bf71a09692d93369ccb9[root@server /]# [root@server /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc7fb87aec994 jenkins/jenkins &quot;/sbin/tini -- /usr/…&quot; 9 minutes ago Up 9 minutes 0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:50000-&gt;50000/tcp jenkins浏览器输入电脑IP地址+端口号：http://192.168.0.103:8080/ docker logs -f jenkins 查看输出日志 注意：jenkins默认启动后的时区为美国，通过以下命令启动中国时区：1234# 先删除已经构建的jenkins实例docker rm -f jenkins# 重新创建实例并设置时区docker run --name=jenkins -d -p 8080:8080 -p 50000:50000 -v jenkins_test:/var/jenkins_home -e JAVA_OPTS=-Duser.timezone=Asia/Shanghai jenkins/jenkins 4. 查看默认密码：1docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword 5. 输入密码等待初始化完成后，输入密码 6. 安装推荐的插件 7. 设置用户名密码 8. Jenkins URL配置 配置成功后，进入欢迎界面 Windows安装Jenkinswar文件启动方法 下载地址：https://www.jenkins.io/download/ 进入war包所在路径执行命令：1java -jar jenkins.war --httpPort=8081 可以直接下载jenkins.msi文件安装 配置方法和Linux类似 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试开发</category>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器技术介绍：Docker常用命令]]></title>
    <url>%2Fposts%2Fcontainer-docker-command%2F</url>
    <content type="text"><![CDATA[本文介绍常用Docker命令，以搭建Web服务器Nginx为例介绍docker相关命令。 基本命令查看Docker版本信息:1$ docker version查看Docker系统信息:1$ docker info从Docker Hub查找镜像123$ docker search 镜像名# 搜索nginx镜像$ docker search nginx 拉取镜像1$ docker pull nginx123456789101112[root@server server]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxa076a628af6f: Pull complete 0732ab25fa22: Pull complete d7f36f6fe38f: Pull complete f72584a26f32: Pull complete 7125e4df9063: Pull complete Digest: sha256:10b8cc432d56da8b61b070f4c7d2543a9ed17c2b23010b43af434fd40e2ca4aaStatus: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest[root@server server]# 下载指定版本的镜像1$ docker pull nginx:1.19.6镜像的可用版本可在docker hub中查看：https://hub.docker.com/ ： 镜像管理查看所有已下载镜像1$ docker images123456789101112[root@server server]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f6d0b4767a6c 3 weeks ago 133MBapp v1 db282454f6b3 7 months ago 83.1MB&lt;none&gt; &lt;none&gt; 1acc89e1a291 7 months ago 152MBbitnami/mariadb latest 08498502c6b7 7 months ago 319MBbitnami/testlink latest 41feee91d195 7 months ago 826MBprom/prometheus latest 39d1866a438a 7 months ago 142MBmysql 5.7 9cfcce23593a 7 months ago 448MBpython 3.7-alpine 6a5ca85ed89b 8 months ago 72.5MBjenkins/jenkins lts 5d1103b93f92 8 months ago 656MB[root@server server]# 删除镜像12345$ docker rmi nginx:latest# 或者使用IMAGE ID$ docker rmi f6d0b4767a6c# 强制删除镜像$ docker rmi -f f6d0b4767a6c 标记本地镜像123$ docker tag nginx:latest nginx:test# 修改镜像名称$ docker tag nginx:latest nginx_test12345678910111213[root@server server]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f6d0b4767a6c 3 weeks ago 133MBnginx test f6d0b4767a6c 3 weeks ago 133MB[root@server server]# docker tag nginx:latest nginx_testREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f6d0b4767a6c 3 weeks ago 133MBnginx test f6d0b4767a6c 3 weeks ago 133MBnginx_test latest f6d0b4767a6c 3 weeks ago 133MB[root@server server]# docker rmi nginx:testUntagged: nginx:test[root@server server]# docker rmi nginx_test:latestUntagged: nginx_test:latest 将指定镜像打包成 tar 归档文件12$ docker save nginx &gt; nginx_test.tar$ docker save nginx -o nginx_test.tar导入打包的镜像1$ docker load &lt; nginx_test.tar 查看镜像创建历史1$ docker history nginx 容器管理运行容器12# 开启nginx服务$ docker run -p 80:80 -d --name=nginx nginx:latest -d: 后台运行容器，并返回容器ID—name: 为容器指定一个名称-p: 指定端口映射：主机(宿主)端口:容器端口-v：挂载目录，将主机的目录映射到容器目录 123[root@server server]# docker run -p 80:80 -d --name=nginx nginx:latest651ce76dd80fa58e3cdf2abeb9c08662bfcf68176738bb3881d0bcb851aa1a11[root@server server]# 浏览器输入服务器IP地址 挂载目录12# 将主机目录/home/server/nginx/html映射到容器目录/usr/share/nginx/html$ docker run -p 80:80 -d --name=nginx -v /home/server/nginx/html:/usr/share/nginx/html nginx:latest 在主机目录/home/server/nginx/html下新建一个index.html文件，输入内容：&lt;h1&gt;Hello World !&lt;/h1&gt;12345[root@server server]# cd /home/haiyong/nginx/html[root@server html]# vim index.html[root@server html]# cat index.html &lt;h1&gt;Hello World !&lt;/h1&gt;[root@server html]# 浏览器刷新 查看运行的容器:12$ docker ps$ docker ps -a 123456789[root@server server]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES651ce76dd80f nginx:latest &quot;/docker-entrypoint.…&quot; 6 minutes ago Up 6 minutes 0.0.0.0:80-&gt;80/tcp nginx[root@server server]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES651ce76dd80f nginx:latest &quot;/docker-entrypoint.…&quot; 8 minutes ago Up 7 minutes 0.0.0.0:80-&gt;80/tcp nginx3bab7ac2a2af jenkins/jenkins:lts &quot;/sbin/tini -- /usr/…&quot; 6 months ago Exited (255) 8 days ago 0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:50000-&gt;50000/tcp jenkins2c5ae10a7543 mysql:5.7 &quot;docker-entrypoint.s…&quot; 6 months ago Exited (255) 8 days ago 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql-test[root@server server]# 查看容器中运行的进程1$ docker top nginx1234[root@server server]# docker top nginxUID PID PPID C STIME TTY TIME CMDroot 118225 118205 0 22:58 ? 00:00:00 nginx: master process nginx -g daemon off;101 118284 118225 0 22:58 ? 00:00:00 nginx: worker process 实时监控容器资源消耗1$ docker stats nginx12345678[root@server server]# docker stats nginxCONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS651ce76dd80f nginx 0.00% 1.492MiB / 1.777GiB 0.08% 3.97kB / 3.66kB 73.7kB / 24.6kB 2CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS651ce76dd80f nginx 0.00% 1.492MiB / 1.777GiB 0.08% 3.97kB / 3.66kB 73.7kB / 24.6kB 2CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS651ce76dd80f nginx 0.00% 1.492MiB / 1.777GiB 0.08% 3.97kB / 3.66kB 73.7kB / 24.6kB 2CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 查看容器日志1$ docker logs -f nginx获取容器/镜像的元信息12$ docker inspect nginx$ docker inspect -f &#x27;&#123;&#123;.Id&#125;&#125;&#x27; nginx-f ： 格式化字符串，输出格式使用Go语言模板。123456789101112131415161718192021222324252627282930[root@server server]# docker inspect nginx[ &#123; &quot;Id&quot;: &quot;651ce76dd80fa58e3cdf2abeb9c08662bfcf68176738bb3881d0bcb851aa1a11&quot;, &quot;Created&quot;: &quot;2021-02-02T14:58:47.047835997Z&quot;, &quot;Path&quot;: &quot;/docker-entrypoint.sh&quot;, &quot;Args&quot;: [ &quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 118225, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2021-02-02T14:58:48.290043299Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;,............................[root@server server]# docker inspect -f &#x27;&#123;&#123;.Id&#125;&#125;&#x27; nginx651ce76dd80fa58e3cdf2abeb9c08662bfcf68176738bb3881d0bcb851aa1a11[root@server server]# docker inspect -f &#x27;&#123;&#123;.State.StartedAt&#125;&#125;&#x27; nginx2021-02-02T14:58:48.290043299Z 查看容器内文件结构及更改1$ docker diff nginx1234567891011121314151617[root@server server]# docker diff webserverC /etcC /etc/nginxC /etc/nginx/conf.dC /etc/nginx/conf.d/default.confC /rootA /root/.bash_historyC /varC /var/cacheC /var/cache/nginxA /var/cache/nginx/client_tempA /var/cache/nginx/fastcgi_tempA /var/cache/nginx/proxy_tempA /var/cache/nginx/scgi_tempA /var/cache/nginx/uwsgi_tempC /runA /run/nginx.pidA：添加了文件或目录B：文件或目录被删除C：文件或目录被修改 启动，停止容器1234567891011121314151617181920212223# 启动已经被停止的容器$ docker start nginx# 重启容器$ docker restart nginx# 暂停容器中所有的进程$ docker pause nginx# 恢复容器中所有的进程$ docker unpause nginx# 杀掉一个运行中的容器$ docker kill nginx# 停止一个运行中的容器$ docker stop nginx# 删除容器$ docker rm nginx# 强制删除容器$ docker rm -f nginx 1234567891011121314151617181920212223[root@server server]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES651ce76dd80f nginx:latest &quot;/docker-entrypoint.…&quot; 21 hours ago Up 21 hours 0.0.0.0:80-&gt;80/tcp nginx[root@server server]# docker stop nginxnginx[root@server server]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@server server]# docker start nginxnginx[root@server server]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES651ce76dd80f nginx:latest &quot;/docker-entrypoint.…&quot; 21 hours ago Up 1 second 0.0.0.0:80-&gt;80/tcp nginx[root@server server]# docker rm nginxError response from daemon: You cannot remove a running container 651ce76dd80fa58e3cdf2abeb9c08662bfcf68176738bb3881d0bcb851aa1a11. Stop the container before attempting removal or force remove[root@server server]# docker stop nginxnginx[root@server server]# docker rm nginx nginx[root@server server]# docker start nginxError response from daemon: No such container: nginxError: failed to start containers: nginx[root@server server]# docker run -p 80:80 -d --name=nginx nginx:latest e0abbac7464794b5f2fbd328b841aaa83ffeff6c2072324b584cbbee4c68c36f 容器交互在容器中执行命令12345$ docker exec -it nginx ls# 开启一个交互模式的终端，exit退出$ docker exec -it nginx bash# 使用root账号进入容器$ docker exec -it -u root nginx bash 12345678910111213[root@server server]# docker exec -it nginx ls bin docker-entrypoint.d home media proc sbin tmpboot docker-entrypoint.sh lib mnt root srv usrdev etc lib64 opt run sys var[root@server server]# docker exec -it nginx echo &quot;test&quot;test[root@server server]# docker exec -it nginx bashroot@ad4c10c7cec2:/# lsbin dev docker-entrypoint.sh home lib64 mnt proc run srv tmp varboot docker-entrypoint.d etc lib media opt root sbin sys usrroot@ad4c10c7cec2:/# exitexit[root@haiyong haiyong]# 复制文件12345# 将容器文件拷贝到主机$ docker cp nginx:/etc/hosts hosts# 将主机文件拷贝到容器中$ docker cp hosts nginx:/etc/hosts --THE END--]]></content>
      <categories>
        <category>测试开发</category>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter性能测试：JMeter多用户并发模拟及压测结果分析]]></title>
    <url>%2Fposts%2Fperformance-testing-jmeter-concurrency%2F</url>
    <content type="text"><![CDATA[JMeter多用户并发模拟 JMeter设置多用户并发数的多少与计算机内存有关，设置 jmeter.bat (Windows) 或者 jmeter.sh (Linux)：Windows设置：编辑jmeter.bat文件，设置HEAP Linux设置：编辑jmeter.sh文件，设置变量，JVM_ARGS=&quot;-Xms1g-Xmx2g&quot; 以Windows为例，设置set HEAP=-Xms1g -Xmx2g -XX:MaxMetaspaceSize=256m ，重新开启JMeter，打开Java监控工具Jconsole：参数设置生效。 JMeter线程组JMeter性能测试任务都是基于线程组的，是性能测试的资源调度池，控制性能测试的运行调度、虚拟用户数(并发数)、执行策略。JMeter线程组主要有三类： setUp Thread Group：普通线程组执行之前执行，相当于pytest测试框架的setup方法。 Thread Group：普通线程 tearDown Thread Group：普通线程组之后执行。 JMeter压测实例首先使用python开启一个http服务:123(base) C:\Users\10287&gt;python -m http.server 80Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 新建线程组，设置线程数，点击运行 View Results TreeThread Group -&gt; Add -&gt; Listenter -&gt; View Results Tree支持各种测试器：正则表达式、CSS选择器、XPath测试、JSON Tester等 Aggregate Report查看Aggregate Report，聚合报告Thread Group -&gt; Add -&gt; Listenter -&gt; Aggregate Report 参数: Average：平均响应时间，所有请求的平均响应时间。 Median：中位数，50%的用户响应时间不超过这个值。 99%line：99%的用户响应时间不超过这个值。 Error%：异常百分比。(错误请求的数量/请求的总数) Throughput：吞吐量，默认情况下每秒完成的请求数。 Received KB/sec：接收数据。 命令行方式执行压测使用图形界面会消耗部分内存，可以直接使用命令行方式运行。 先保存压测脚本为test_http.jmx，执行如下命令：jmeter.bat -n -t test_http.jmx -l test_result.jtl1234567891011D:\testing_tools\apache-jmeter-5.3\bin&gt;jmeter.bat -n -t D:/ProgramWorkspace/TestingDemo/test_jmeter/test_http.jmx -l result.jtlCreating summariser &lt;summary&gt;Created the tree successfully using D:/ProgramWorkspace/TestingDemo/test_jmeter/test_http.jmxStarting standalone test @ Sun Jan 24 17:48:59 CST 2021 (1611481739136)Waiting for possible Shutdown/StopTestNow/HeapDump/ThreadDump message on port 4445summary + 23 in 00:00:01 = 43.6/s Avg: 35 Min: 11 Max: 91 Err: 0 (0.00%) Active: 3 Started: 25 Finished: 22summary + 27 in 00:00:01 = 52.7/s Avg: 68 Min: 9 Max: 612 Err: 0 (0.00%) Active: 0 Started: 50 Finished: 50summary = 50 in 00:00:01 = 47.9/s Avg: 53 Min: 9 Max: 612 Err: 0 (0.00%)Tidying up ... @ Sun Jan 24 17:49:00 CST 2021 (1611481740529)... end of run jtl文件解析解析命令行方式运行脚本生成的 jtl文件：1jmeter.bat -g result.jtl -e -o D:/resultReport 打开index.html文件，可以查看性能报告： --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium/appium 等待方式介绍]]></title>
    <url>%2Fposts%2Fselenium-appium-webdriver-wait%2F</url>
    <content type="text"><![CDATA[UI自动化测试过程中，执行某个动作后，页面元素的加载（ajax动态加载）需要一定的时间，selenium WebDriver提供了几种等待方式，Appium也继承了WebDriver API，所以selenium和appium 等待的实现方式相同。下面介绍WebDriver的等待方式。 HTML 页面加载HTML 页面加载、解析过程： 浏览器向服务器发起请求，浏览器先查询本地（浏览器或者本机）DNS缓存，如果没有，向DNS 服务器发起 域名解析请求 浏览器拿到域名对应的IP地址后，建立与服务器的 TCP/IP 连接（3次握手，断开连接进行4次挥手） 向服务器发送 http / https 请求，服务器进行后台内部处理，进行HTTP响应，返回状态和浏览器请求的内容 浏览器接收到http数据包后进行解析 解析HTML页面代码，遇到静态资源（js、css、图片等）则发起请求，过程和前面的步骤一样。 顺序是从上到下进行加载、渲染，下载和渲染同时进行 js文件的加载会阻塞HTML内容的加载 CSS样式表下载完成之后会跟之前的样式表一起进行解析，会对之前的元素重新渲染 渲染过程主要包括以下步骤： 解析HTML，生成 DOM Tree 同时解析CSS，生成CSS规则树CSSOM 合并 DOM 和 CSSOM，生成 Render Tree 根据Render Tree进行渲染和展示 如果遇到Javascript代码会阻塞渲染，JS执行完成后，浏览器重新渲染 遇到&lt;/html&gt;后结束渲染。 强制等待强制等待，线程休眠一定时间，一般不推荐：1time.sleep(3) 隐式等待在服务端等待，设置一个等待时间，轮询查找(默认0.5秒)元素是否出现，如果达到设置的等待时间还没出现就抛出异常。1driver.implicitly_wait(TIMEOUT) # TIMEOUT单位为秒 显式等待在客户端等待，在代码中自定义等待条件，可针对于某个特定的元素或者条件设置等待时间，满足条件时继续执行代码。使用WebDriverWait类和expected_conditions类来实现，WebDriverWait类包括了until()和 until_not两种方法，通过判断条件是否为真进行等待，每隔一段时间(默认为0.5秒)进行条件判断，如果条件成立，则执行下一步,否则继续等待，直到超过设置的最长时间。 1WebDriverWait(self.driver, timeout, poll_frequency=0.5, ignored_exceptions=None).until(expected_conditions. visibility_of_element_located(LOCATOR)) timeout：超时时间，单位为秒 poll_frequency：检测的间隔步长，默认为0.5s ignored_exceptions：超时后的抛出的异常信息，默认抛出NoSuchElementExeception异常。 until：当某元素出现或什么条件成立则继续执行。 until_not：与until相反, 当某元素消失或什么条件不成立则继续执行。 expected_conditions类提供了很多期望条件：1234567891011121314151617title_istitle_containspresence_of_element_locatedvisibility_of_element_locatedvisibility_ofpresence_of_all_elements_locatedtext_to_be_present_in_elementtext_to_be_present_in_element_valueframe_to_be_available_and_switch_to_itinvisibility_of_element_locatedelement_to_be_clickablestaleness_ofelement_to_be_selectedelement_located_to_be_selectedelement_selection_state_to_beelement_located_selection_state_to_bealert_is_present 也可以使用lambda表达式1WebDriverWait(driver, timeout).until(lambda x:x.find_element_by_id(&quot;someld&quot;) 示例代码：12345678910111213141516from selenium.webdriver.support import expected_conditionsfrom selenium.webdriver.support.wait import WebDriverWaitdef test_wait(self): self.driver.find_element(By.XPATH,&#x27;the_xpath_path1&#x27;).click() ## 方法1 def wait(x): # 定义等待条件 return self.driver.find_elements(By.XPATH,&#x27;the_xpath_path2&#x27;) WebDriverWait(self.driver, 10).until(wait) WebDriverWait(self.driver, 10).until_not(wait) ## 方法2 WebDriverWait(self.driver, 10).until(expected_conditions.presence_of_element_located(By.XPATH, &#x27;the_xpath_path2&#x27;)) ## 方法3 WebDriverWait(self.driver, 10).until(lambda x:x.find_element_by_id(&quot;someld&quot;) 总结WebDriver隐式等待和显式等待可参考官方文档：https://selenium-python.readthedocs.io/waits.html， 本文介绍了三种等待方式： 强制等待：一般不推荐 隐式等待：尽量默认都加上，时间限定在3-6s，不要太长。 显式等待：用来处理隐式等待无法解决的一些问题，显式等待时间可以设置长一点 除了上面介绍的三种等待方式，WebDriver还有两个等待方法：set_script_timeout和set_page_load_timeout。set_script_timeout设置等待execute_async_script（Javascript / AJAX 调用 ）执行完成，set_page_load_timeout设置等待页面加载完成。12driver.set_script_timeout(5)driver.set_page_load_timeout(5) --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>selenium</tag>
        <tag>WebDriverWait</tag>
        <tag>UI自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter性能测试：JMeter安装及脚本录制回放]]></title>
    <url>%2Fposts%2Fperformance-testing-using-jmeter%2F</url>
    <content type="text"><![CDATA[除了功能测试以外，服务端的性能测试也非常重要，比如产品功能测试通过，那么在大负载的情况下，可能会导致服务器崩溃，影响用户体验。虽然不同服务对负载要求不同，但性能测试还是很有必要的。本文简要介绍性能测试相关知识，然后介绍如何使用JMeter来进行性能测试。 性能测试基本概念为什么要做性能测试? 模拟真实的用户场景，提前发现并修复问题。 最小化成本：新服务上线不知道部署多少台服务器。 评估应用系统性能，给运维做系统容量规划提供依据、给开发提供应用调优参考。 什么是性能测试?性能测试模拟多个用户的操作对服务器硬件性能的影响，用于检查软件和硬件的响应速度、稳定性、可靠性和资源使用等情况。常见性能指标包括： TPS(Transaction per Second)：每秒事物处理能力 RT(Response Time)：响应时间 延迟 吞吐量 并发用户数 …… 负载测试是一种性能测试，检查系统在固定时间段内为大量并发虚拟用户提供服务下的运行情况。压力测试通过在极端负载下测试系统的上限。 常见性能测试工具常见的性能测试工具如下，其中JMeter 是应用最广泛的。 Apache JMeter：开源免费，使用Java语言开发，有很多第三方插件，具有脚本录制功能，https://jmeter.apache.org/ apache bench: ab工具是apache HTTP服务器性能测试工具，http://httpd.apache.org/docs/2.4/programs/ab.html LoadRunner：收费，使用C语言开发。 Locust：开源免费，使用Python语言开发。https://www.locust.io/ nGrinder：Naver公司基于 Grinder开发的性能测试平台。 Grinder是一个能运行 jython(在JVM上运行的 Python)、 groovy编写测试脚本的应用程序。免费软件，使用Java语言开发。 JMeterApache JMeter开源免费，使用Java开发，可用于测试Web性能，也可以测试数据库性能（通过JDBC）。 支持插件开发扩展功能，可以二次开发定制协议，支持录制、回放方式获取测试脚本，下面介绍JMeter压测脚本的录制与编写。 JMeter安装-windows 安装Java jdk下载地址：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html加入环境变量，具体安装过程参考：App自动化测试 | Appium 介绍及环境安装 JMeter下载安装下载地址：https://jmeter.apache.org/download_jmeter.cgi下载后解压缩，双击打开jmeter.bat批处理文件打开JMeter 123456789D:\testing_tools\apache-jmeter-5.3\bin&gt;jmeter -v _ ____ _ ____ _ _ _____ _ __ __ _____ _____ _____ ____ / \ | _ \ / \ / ___| | | | ____| | | \/ | ____|_ _| ____| _ \ / _ \ | |_) / _ \| | | |_| | _| _ | | |\/| | _| | | | _| | |_) | / ___ \| __/ ___ \ |___| _ | |___ | |_| | | | | |___ | | | |___| _ &lt;/_/ \_\_| /_/ \_\____|_| |_|_____| \___/|_| |_|_____| |_| |_____|_| \_\ 5.3Copyright (c) 1999-2020 The Apache Software Foundation JMeter插件安装下载 jmeter-plugins.org：https://jmeter-plugins.org/install/Install/ 将jmeter-plugins-manager-1.6.jar 文件放到JMeter lib/ext目录下，重新打开JMeter，在Options中可以看到Plugins Manager选项。安装可用插件 JMeter脚本录制添加线程组添加Recording ControllerTest Plan -&gt; Thread Group -&gt; Add -&gt; Logic Controller -&gt; Recording Controller添加HTTp(s) Test Script Recorder （代理服务）Test Plan -&gt; Add -&gt; Non-Test Elements -&gt; HTTp(s) Test Script Recorder 浏览器配置代理使用SwitchyOmega插件添加JMeter代理 配置HTTp(s) Test Script Recorder，点击Start弹出提示框，需要安装证书（HTTPs请求抓取需要证书）在JMeter目录下会生成两个证书文件，点击证书安装证书安装成功后，浏览器就可以访问百度了。浏览器刷新百度页面，在JMeter页面可以看到抓取到的请求可以看到有各种请求数据，我们可以对这些进行过滤，比如过滤gif、png等文件选择HTTp(s) Test Script Recorder，点击Requests Filtering，添加过滤条件（包含或者排除），过滤条件使用正则表达式。 录制完成后，点击停止录制 Thread Group -&gt; Add -&gt; Listenter -&gt; View Results Tree选择View Results Tree，点击运行，可以看到每一步请求的响应结果。 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[容器技术介绍：Docker简介及安装]]></title>
    <url>%2Fposts%2Fcontainer-docker-guide%2F</url>
    <content type="text"><![CDATA[容器技术（Linux Container，LXC）是一种轻量级的虚拟化技术，容器镜像运行在一个隔离环境中，像集装箱一样，把应用封装起来，应用之间互不干扰，实现进程的隔离。Docker 是常用的一种容器技术，本文将简要介绍Docker及Docker安装方法。 Docker简介Docker是什么Docker基于Go语言开发，在2013年正式发布，是一个是用于构建、部署和管理容器化应用程序的开源平台，Docker 允许开发人员将应用程序打包到容器中，容器将应用程序源代码、操作系统库以及所需的依赖结合在一起，可以发布到任何流行的系统中。Docker具有以下优点： 使开发人员能够使用简单命令自动化构建、部署、运行、更新容器，缩短开发及运行代码之间的周期，快速交付应用。 应用隔离：不同软件运行环境兼容依赖问题，每个容器都可以看作是一个不同的微服务，容器之间互不影响。 轻量级，比创建虚拟机快得多 运行环境可移植，容器镜像将应用运行环境，包括代码、依赖、资源文件等打包。 Docker与虚拟机的区别虚拟机（Virtual machine, VM)是对计算机系统的仿真，操作系统(OS)及其应用程序共享单个主机服务器的硬件资源，硬件是虚拟化的，每个虚拟机都有自己的底层操作系统。管理程序(hypervisor)位于硬件和虚拟机之间，负责创建和运行 VM 的软件、固件或硬件。 前面讲过，Docker也是一种虚拟化技术，它只虚拟化操作系统，而不像虚拟机那样虚拟化操作系统和硬件资源。主要区别如下： 容器与容器之间只是进程的隔离，通过名称空间隔离，而虚拟机是完全的资源隔离，可能更安全。 虚拟机的启动可能需要几分钟，Docker启动只需几秒钟甚至更短。 容器共享宿主操作系统的内核，而虚拟机使用完全独立的内核，需虚拟化内核。 虚拟机是操作系统和硬件的虚拟化，Docker是操作系统的虚拟化 Docker EngineDocker Engine 是一个客户机/服务器 (C/S架构) 应用，主要包括三个部分： server：守护进程(dockerd 命令)，Docker Daemon REST API：客户端与守护进程间的通信接口 CLI：command line interface (CLI) ，命令行接口客户端（docker 命令） CLI 使用 REST API 与 Docker Daemon 进行通信，实现对Docker Daemon的控制和交互。也可以使用 UNIX 套接字、网络接口进行通信。守护进程构建、运行和管理 Docker 对象（镜像、容器、网络和volumes）。Docker 客户机和守护进程可以在同一个系统上运行，也可以将 Docker 客户机连接到远程 Docker 守护进程。 https://docs.docker.com/get-started/overview/ Docker daemonDocker 守护进程(dockerd)是后台服务进程，是生存期较长的进程，负责监听 Docker API 请求，管理 Docker 对象。守护进程还可以与其他守护进程通信来管理 Docker 服务。 Docker clientDocker 客户端(docker)是 Docker 用户与 Docker 交互的主要方式，客户端将命令发送给守护进程，然后守护进程执行这些命令，Docker 客户端可以与多个守护进程进行通信。 Docker ImagesDocker镜像是一个只读模板，其中包含创建 Docker 容器的说明。通常，一个镜像都可能依赖一个或多个下层的镜像组成的另一个镜像。Docker镜像可以从Docker仓库中下载，也可以自己创建（Dockerfile）。 Docker RegistryDocker仓库是集中存放Docker镜像的地方，默认公共仓库为 Docker Hub，也可以自己配置私人仓库。当使用 docker pull 或 docker run 命令时，将从配置的仓库中提取所需的镜像。使用 docker push 命令时，镜像将被推送到配置的仓库中。 Docker ContainersDocker容器是镜像运行后的进程，是镜像的可运行实例，默认情况下，容器之间是隔离的。 Docker安装Docker安装可参考官方文档：https://docs.docker.com/engine/install/ Windows 10下载地址 : https://hub.docker.com/editions/community/docker-ce-desktop-windows Linux安装方法有两种，一种是设置docker源进行安装（推荐方法），另一种是是下载安装包（CentOS和Ubuntu对应RPM、DEB包）进行手动安装，一般在安装主机没有网络的情况下使用这种方法。（RPM、DEB包介绍及安装方法可参考Linux系统介绍） 下面介绍一下CentOS下的docker安装方法（也可参考官方文档：https://docs.docker.com/engine/install/centos/），Ubuntu系统下docker的安装参考官方文档：https://docs.docker.com/engine/install/ubuntu/ 要求CentOS 7 或者 CentOS 8 1. 卸载旧版本12345678$ sudo yum remove docker \docker-client \docker-client-latest \docker-common \docker-latest \docker-latest-logrotate \docker-logrotate \docker-engine 2. 安装依赖、添加源1234# 安装yum-utils包$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 设置yum源$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 3. 安装Docker Engine安装最新版本的Docker Engine 和 containerd1$ sudo yum install docker-ce docker-ce-cli containerd.io或者安装制定版本：12345678# 列出可用版本$ yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 3:20.10.2-3.el7 docker-ce-stable docker-ce.x86_64 3:20.10.2-3.el7 @docker-ce-stabledocker-ce.x86_64 3:20.10.1-3.el7 docker-ce-stable docker-ce.x86_64 3:20.10.0-3.el7 docker-ce-stable # 安装指定版本$ sudo yum install docker-ce-20.10.2 docker-ce-cli-20.10.2 containerd.io 4. 启动Docker1234# 启动$ sudo systemctl start docker# 开机启动$ sudo systemctl enable docker 5. 检验Docker Engine是否安装成功1234# 运行hello-world镜像$ sudo docker run hello-world# 或者 查看docker版本$ docker version 配置阿里云镜像加速器默认是从Docker Hub下载镜像，为了更快的下载docker镜像，可以配置国内的镜像服务器，下面介绍阿里云镜像配置方法。 阿里云控制台地址：https://homenew.console.aliyun.com/ 进入容器镜像服务 设置登陆密码 首次使用需要设置密码： 设置镜像加速 点击进入镜像加速器：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 选择对应的操作系统，按照操作步骤进行操作。 参考： https://docs.docker.com/get-started/overview/ --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试开发</category>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Scapy 报文构造和解析]]></title>
    <url>%2Fposts%2Fpython-scapy-for-packet-build-and-parser%2F</url>
    <content type="text"><![CDATA[Scapy是一款强大的交互式数据包处理工具、数据包生成器、网络扫描器、网络发现、攻击工具和包嗅探工具。能灵活地构造各种数据包、发送数据包、包嗅探、应答和反馈匹配等功能。它可以实现Nmap扫描工具、tcpdump抓包工具 、 tshark工具、Netdiscover网络扫描工具的功能。 Nmap、Netdiscover、tcpdump和tshark介绍可参考： Nmap：Nmap扫描工具介绍 tcpdump和tshark：tcpdump抓包及tshark解包方法介绍 Netdiscover：Netdiscover网络扫描工具 本文主要介绍Scapy进行报文构造，报文发送和报文解析。 下载安装官网：https://scapy.net/github地址：https://github.com/secdev/scapy官方文档：https://scapy.readthedocs.io/en/latest/ 1pip install scapy Scapy 的使用lsc() 命令：列出scapy通用的操作方法，常用的函数包括： arpcachepoison（用于arp毒化攻击，也叫arp欺骗攻击） arping（用于构造一个ARP的who-has包） send：发送3层报文（ 如TCP/UDP 协议），不接收数据包 sendp：发送2层报文(通过mac地址转发)，不接收 sniff：用于网络嗅探，类似Wireshark和tcpdump抓包 sr：发送，接收3层报文，返回有回应的数据包和没有回应的数据包。 sr1：发送，只接收1个响应包 srp：发送，接收2层报文 srp1：发送，只接收1个响应包 rdpcap：读取报文 wrpcap：保存报文 123456789101112131415&gt;&gt;&gt; lsc()arpcachepoison : Poison target&#x27;s cache with (your MAC,victim&#x27;s IP) couplearping : Send ARP who-has requests to determine which hosts are upchexdump : Build a per byte hexadecimal representationls : List available layers, or infos on a given layer class or name.send : sendp : sendpfast : Send packets at layer 2 using tcpreplay for performancesniff : split_layers : Split 2 layers previously bound.sr : sr1 : sr1flood : Flood and receive packets at layer 3 and return only the first answersrp : srp1 : ls()：查看支持的协议 ls(IP)：查看IP包的默认参数 报文嗅探sniff() 函数参数Scapy使用 sniff() 函数进行报文嗅探， sniff() 方法有以下参数：1234567def _run(self, count=0, store=True, offline=None, quiet=False, prn=None, filter=None, lfilter=None, L2socket=None, timeout=None, opened_socket=None, stop_filter=None, iface=None, started_callback=None, session=None, session_args=[], session_kwargs=&#123;&#125;, *arg, **karg):部分参数定义： count：抓包数量，默认为0，表示无限制 store：是否保存抓取的数据包 offline：读取 pcap 文件 quiet：设置为True时，会丢弃stderr进程 prn：对对每个数据包进行某个操作的函数。例如：prn = lambda x: x.summary()； filter：BPF(Berkeley Packet Filter)过滤规则，wireshark过滤也使用的是BPF过滤器。 timeout：指定嗅探时间 stop_filter：定义一个函数，在抓到指定数据包后停止抓包 iface：抓包的接口 filter参数的BPF语法可参考 https://biot.com/capstats/bpf.html https://www.tcpdump.org/manpages/pcap-filter.7.html BPF语法示例： dst host 192.168.0.1：目的IP为192.168.0.1的报文 host 192.168.0.1：IP地址为192.168.0.1的报文 tcp port 80：TCP端口号为80的报文（HTTP报文） tcp and not port 80：除了80端口的TCP报文 tcp portrange 1-25：TCP端口范围1-25的报文 not broadcast：排除广播报文 !arp：排除arp报文 sniff() 抓包1234from scapy.all import *package = sniff(iface=&#x27;WLAN&#x27;, timeout=10)wrpcap(&quot;test.pcap&quot;, package) # 将抓取的包保存为test.pcap文件 查看保存的报文：12345678910111213141516171819&gt;&gt;&gt; pkts = sniff(offline=&#x27;test.pcap&#x27;)&gt;&gt;&gt; pkts[17].show()###[ Ethernet ]### dst= ff:ff:ff:ff:ff:ff src= fc:4d:d4:f8:84:f8 type= ARP###[ ARP ]### hwtype= 0x1 ptype= IPv4 hwlen= 6 plen= 4 op= who-has hwsrc= fc:4d:d4:f8:84:f8 psrc= 192.168.101.156 hwdst= 00:00:00:00:00:00 pdst= 192.168.101.1###[ Padding ]### load= &#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27; 过滤报文：1234&gt;&gt;&gt; sniff(iface=&#x27;WLAN&#x27;, timeout=10, filter=&quot;tcp port 80&quot;, prn=lambda x:x.sprintf(&quot;&#123;IP:%IP.src% -&gt; %IP.dst%&#125;&quot;))183.232.231.174 -&gt; 192.168.0.167192.168.0.167 -&gt; 183.232.231.174&lt;Sniffed: TCP:2 UDP:0 ICMP:0 Other:0&gt; 除了使用scapy抓包外，也可以使用tcpdump（Linux）和tshark（Windows）进行抓包。 DHCPv6报文构造我们首先用Scapy打开一个真实抓到的DHCPv6 Request报文，查看一下报文结构：123from scapy.all import *pkts = rdpcap(&#x27;packet.pcap&#x27;)pkts[1021].show() # 序号为1022的报文为DHCPv6 Request报文（通过wireshark查看）报文打印如下： 下面开始构造每一层报文：123456789101112from scapy.all import *ethernet = Ether(dst=&#x27;00:0c:29:47:f3:2f&#x27;,src=&#x27;c8:3a:35:09:ef:a1&#x27;,type=0x86dd)ip = IPv6(src =&#x27;2001:db8:3333::16&#x27;,dst=&#x27;ff02::2&#x27;)udp =UDP(sport=546,dport=547)# dhcpv6 = DHCP6(msgtype = 1)dhcpv6 = DHCP6_Solicit()cid = DHCP6OptClientId()iana = DHCP6OptIA_NA()iapd_p = DHCP6OptIAPrefix()iapd = DHCP6OptIA_PD(iapdopt=[iapd_p])packet = ethernet/ip/udp/dhcpv6/cid/iana/iapdpacket.show()注意DHCP6 Option - IA Prefix option 的构造方法， IA Prefix选项是包含在IAPD选项内的，所以要赋值给iapdopt，多个option字段用逗号隔开。 其中，字段名称通过 ls() 命令查看：12ls(DHCP6OptIA_PD)ls(DHCP6OptIA_NA) 运行上面程序，打印构造的报文：构造成功！ 发送报文1. 只发不收 send：发送3层报文（ 如TCP/UDP 协议），不接收数据包 sendp：发送2层报文(通过mac地址转发)，不接收12send(packet, iface=&#x27;eth1&#x27;, count=2) sendp(packet, iface=&#x27;eth0&#x27;) count，发送报文数，默认发送一个报文iface，指定接口 2. 发且收 sr：发送，接收3层报文，返回有回应的数据包和没有回应的数据包。 sr1：发送，只接收1个响应包 srp：发送，接收2层报文 srloop()：循环发送 srp1：发送，只接收1个响应包 srploop：循环发送1sr(packet, iface=&#x27;eth1&#x27;) 报文过滤在网络协议的测试中，我们需要检测某个报文字段是否存在，对抓取到的报文进行解析，可以使用tshark命令解析报文解析(参考文章tcpdump抓包及tshark解包方法介绍)。 当然，Scapy也可以解析数据包，下面查找DHCPv6 Solicit报文，且目的MAC为00:0c:29:d9:98:c71234567891011from scapy.all import *import repackage = &quot;package.pcap&quot;field = &#x27;dst=00:0c:29:d9:98:c7&#x27;pkts = rdpcap(package)for packet in pkts: if packet.haslayer(&#x27;DHCP6_Solicit&#x27;): packet_text = repr(packet) if re.search(field, packet_text, re.IGNORECASE): print(&quot;666&quot;)其中，repr内置函数用于返回对象的 string 格式。除了rdpcap()方法读取报文文件外，也可以使用嗅探函数sniff()：1pkts = sniff(offline=&#x27;packet_solicit.pcap&#x27;) 如果不知道目标字段写法，可以先打印一下：1234&gt;&gt;&gt; from scapy.all import *&gt;&gt;&gt; pkts = rdpcap(&#x27;packet_solicit.pcap&#x27;)&gt;&gt;&gt; pkts[3]&lt;Ether dst=ff:ff:ff:ff:ff:ff src=00:0c:29:d9:98:c7 type=IPv6 |&lt;IPv6 version=6 tc=0 fl=0 plen=46 nh=UDP hlim=64 src=fe80::20c:29ff:fed9:98c7 dst=ff02::1:2 |&lt;UDP sport=dhcpv6_client dport=dhcpv6_server len=46 chksum=0x764d |&lt;DHCP6_Solicit msgtype=SOLICIT trid=0x0 |&lt;DHCP6OptClientId optcode=CLIENTID optlen=14 duid=&lt;DUID_LLT type=Link-layer address plus time hwtype=Ethernet (10Mb) timeval=Sat, 01 Jan 2000 00:00:00 +0000 (946684800) lladdr=00:0c:29:d9:98:c7 |&gt; |&lt;DHCP6OptIA_NA optcode=IA_NA optlen=12 iaid=0x0 T1=0 T2=0 |&gt;&gt;&gt;&gt;&gt;&gt; --THE END--]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>tcpdump</tag>
        <tag>wireshark</tag>
        <tag>scapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记：属性值设置和判断变量是否存在]]></title>
    <url>%2Fposts%2Fpython-notes-for-variable-and-attribute%2F</url>
    <content type="text"><![CDATA[介绍Python设置属性值方法setattr()和判断变量是否存在的方法 以属性名为变量的方式给一个对象添加属性使用 setattr 方法12345obj = SomeClass()key = &#x27;key_name&#x27;val = &#x27;key_value&#x27;setattr(obj, key, val)print(obj.key_name) 示例：给报文字段赋值12345678from scapy.all import *layer = &#123;&quot;ether&quot;:&quot;dst=&#x27;33:33:00:01:00:02&#x27;,src=&#x27;00:0c:29:d9:98:c7&#x27;&quot;&#125;Ethernet_field = layer.setdefault(&#x27;ether&#x27;)ethernet = Ether(type=0x86dd)fields = dict(((lambda a:(a[0].strip(&quot;&#x27;&quot;),a[1].strip(&quot;&#x27;&quot;))) (field.split(&#x27;=&#x27;)) for field in Ethernet_field.split(&#x27;,&#x27;)))for key, val in fields.items(): setattr(ethernet, key, val) ethernet.show()out:12345&gt;&gt;&gt; ethernet.show()###[ Ethernet ]### dst = 33:33:00:01:00:02 src = 00:0c:29:d9:98:c7 type = IPv6 判断变量是否存在三种方法： locals().keys() dir() vars() 12345678910ethernet = &#x27;Ether&#x27;dhcpv6 = &#x27;dhcpv6_solicit&#x27;message = [&#x27;ethernet&#x27;,&#x27;ip&#x27;,&#x27;udp&#x27;,&#x27;dhcpv6&#x27;]del_message = []for layer_i, value in enumerate(message): if message[layer_i] not in locals().keys(): del_message.append(value)for m in del_message: message.remove(m)print(f&#x27;message:&#123;message&#125;&#x27;) 运行结果：12C:\Users\DELL&gt;python3 test_locals.pymessage:[&#x27;ethernet&#x27;, &#x27;dhcpv6&#x27;] --THE END--]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>setattr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记：字符串操作]]></title>
    <url>%2Fposts%2Fpython-notes-for-string%2F</url>
    <content type="text"><![CDATA[字符串相关操作 统计字符串中某个单词的出现的次数123456a = &#x27;test 123 dfg test&#x27;## 方法1len([i for i in a.split(&#x27; &#x27;) if i == test])## 方法2len(a.split(&#x27;test&#x27;))-1 Python提取两个字符串之间的内容123456789101112import re str = &#x27;&#x27;&#x27;/begin MEASUREMENT100LINKDISPLAYSYMBOL/end MEASUREMENT&#x27;&#x27;&#x27; regex = r&#x27;/begin MEASUREMENT([\s\S]*)/end MEASUREMENT&#x27;matches = re.findall(regex, str)for match in matches: print(match) 12345import re str = &#x27;test:100 end&#x27; regex = r&#x27;test:([\s\S]*)/end&#x27;matches = re.findall(regex, str)test = matches[0].strip() 字符删除、替换删除空格123456789101112s = &#x27; 123abcd456 &#x27;# 删除两边的空格print(s.strip())# 删除右边空格print(s.rstrip()) # 删除左边空格print(s.lstrip())# 删除两边的数字print(s.strip(&#x27; &#x27;).strip(&#x27;123456&#x27;))# 删除两边的引号s = &quot;&#x27;123abcd456&#x27;&quot;print(s.strip(&quot;&#x27;&quot;)) 分割并去除空格12string = &quot; hello , world !&quot;string = [x.strip() for x in string.split(&#x27;,&#x27;)] 将格式化字符转换为字典123string = &quot;dst=&#x27;192.168.0.1&#x27;,src=&#x27;192.168.1.2&#x27;&quot;fields = dict((field.split(&#x27;=&#x27;) for field in string.split(&#x27;,&#x27;)))fields = dict(((lambda a:(a[0].strip(&quot;&#x27;&quot;),a[1].strip(&quot;&#x27;&quot;))) (field.split(&#x27;=&#x27;)) for field in string.split(&#x27;,&#x27;))) 12&gt;&gt;&gt; fields&#123;&#x27;dst&#x27;: &quot;&#x27;192.168.0.1&#x27;&quot;, &#x27;src&#x27;: &quot;&#x27;192.168.1.2&#x27;&quot;&#125; 删除(替换)任意位置字符123456s = &#x27;11233aabcdd41556&#x27;# 删除某个特定字符print(ss.replace(&#x27;1&#x27;, &#x27;&#x27;))# 同时删除不同字符import reprint(re.sub(&#x27;[1a]&#x27;, &#x27;&#x27;, s)) --THE END--]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记：List相关操作]]></title>
    <url>%2Fposts%2Fpython-notes-for-list%2F</url>
    <content type="text"><![CDATA[List相关操作小例子 获取list的下标和值123456789&gt;&gt;&gt; mylist = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; for index, value in enumerate(mylist):... print(index, value)...0 a1 b2 c3 d&gt;&gt;&gt; 删除list中的空字符12345678list1 = [&#x27;1&#x27;, &#x27;&#x27;,&#x27;2&#x27;, &#x27;3&#x27;, &#x27; &#x27;, &#x27; 4 &#x27;, &#x27; 5&#x27;, &#x27; &#x27;,&#x27;6 &#x27;, &#x27;&#x27;, &#x27; &#x27;,None, &#x27;7&#x27;]print(list1)list2 = list(filter(None, list1)) print(list2) # [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27; &#x27;, &#x27; 4 &#x27;, &#x27; 5&#x27;, &#x27; &#x27;, &#x27;6 &#x27;, &#x27; &#x27;, &#x27;7&#x27;]list3 = [x.strip() for x in list2]print(list3) # [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;&#x27;, &#x27;6&#x27;, &#x27;&#x27;, &#x27;7&#x27;]list4 = list(filter(None, list3)) print(list4) # [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;] 删除list元素使用remove、pop和del方法参删除list中的某个元素1234567891011121314151617181920&gt;&gt;&gt; mylist = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27;]&gt;&gt;&gt; mylist.remove(&#x27;a&#x27;)&gt;&gt;&gt; mylist[&#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;]&gt;&gt;&gt; mylist.pop(0)&#x27;b&#x27;&gt;&gt;&gt; mylist[&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;]&gt;&gt;&gt; del mylist[0]&gt;&gt;&gt; mylist[&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;]&gt;&gt;&gt; del mylist[0:2]&gt;&gt;&gt; mylist[&#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;]&gt;&gt;&gt; del mylist&gt;&gt;&gt; mylistTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;mylist&#x27; is not defined&gt;&gt;&gt; 计算中位数1234def get_median(data): data.sort() half = len(data) // 2 return (data[half] + data[~half]) / 2 将字符串list转换为int12345&gt;&gt;&gt; test_list = [&#x27;1&#x27;, &#x27;4&#x27;, &#x27;3&#x27;, &#x27;6&#x27;, &#x27;7&#x27;]&gt;&gt;&gt; test_list = list(map(int, test_list))&gt;&gt;&gt; test_list[1, 4, 3, 6, 7]&gt;&gt;&gt; 合并、连接字符串list12345&gt;&gt;&gt; test_list = [&#x27;192&#x27;, &#x27;168&#x27;, &#x27;0&#x27;, &#x27;1&#x27;]&gt;&gt;&gt; test_list = &#x27;.&#x27;.join(test_list)&gt;&gt;&gt; test_list&#x27;192.168.0.1&#x27;&gt;&gt;&gt; 取多个字符串/list交集123456&gt;&gt;&gt; a = [&#x27;123&#x27;,&#x27;234&#x27;,&#x27;1253&#x27;]&gt;&gt;&gt; list(reduce(lambda x,y : set(x) &amp; set(y), a))[&#x27;2&#x27;, &#x27;3&#x27;]&gt;&gt;&gt; b = [[1,2,3],[1,2],[1,2,3,4],[12,1,2]]&gt;&gt;&gt; list(reduce(lambda x,y : set(x) &amp; set(y), b))[1, 2] 合并字典value值1234567891011&gt;&gt;&gt; mydict = &#123;0:&quot;hello &quot;, 1:&quot;world&quot;&#125;&gt;&gt;&gt; mylist =reduce(lambda x, y : x + y, mydict.values())&gt;&gt;&gt; mylist&#x27;hello world&#x27;&gt;&gt;&gt; mydict = &#123;0:[1,2,3,4], 1:[2,3,4,5,6]&#125;&gt;&gt;&gt; mylist = list(reduce(lambda x, y : x + y, mydict.values()))&gt;&gt;&gt; mylist[1, 2, 3, 4, 2, 3, 4, 5, 6]&gt;&gt;&gt; field_counters = dict(Counter(mylist))&gt;&gt;&gt; field_counters&#123;1: 1, 2: 2, 3: 2, 4: 2, 5: 1, 6: 1&#125; 注意在python3中reduce需要导入：1from functools import reduce --THE END--]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mitmproxy 代理工具介绍：rewrite和map local实现]]></title>
    <url>%2Fposts%2Fapi-test-mitmproxy-guide%2F</url>
    <content type="text"><![CDATA[在接口测试中，会用到抓包工具或者代理工具，常用代理工具包括charles、 burpsuite、 fiddler、mitmproxy等，ssh -D参数 可实现socks5代理。网络嗅探工具可以使用tcpdump 和 wireshark。Charles工具可以实现mock测试（参考接口测试代理工具charles mock测试），如果要自动化实现这些功能，mitmproxy工具是个不错的选择，本文主要内容包括简要介绍mitmproxy代理工具、mitmproxy安装、SSL 证书安装以及实现和charles一样的功能：rewrite和map local。 mitmproxy简介mitm(man-in-the-middle) 即中间人攻击，mitmproxy是主要基于Python平台开发的代理工具，功能强大，可满足高度定制化需求。它是一个用于跟踪流量的中间代理工具，具有截获、篡改、重放等功能。 插件是mitmproxy非常强大的一部分，提供了一系列API，mitmproxy扩展：https://docs.mitmproxy.org/stable/addons-overview/插件例子：https://docs.mitmproxy.org/stable/addons-examples/ mitmproxy支持5种代理模式： 正向代理（regular proxy） 反向代理（reverse proxy） 上行代理（upstream proxy） 透明代理（transparent proxy） socks5代理（socks Proxy） 本文主要介绍mitmproxy的正向代理使用过程mitmproxy套装包括3个工具： mitmproxy：命令行交互工具 mitmdump：命令行非交互工具，提供类似 tcpdump的功能 mitmweb：基于Web的用户界面 mitmproxy的代理流程： 图片来源：https://docs.mitmproxy.org/stable/concepts-howmitmproxyworks/ mitmproxy安装mitmproxy官网：https://mitmproxy.org/mitmproxy安装方法参考：https://docs.mitmproxy.org/stable/overview-installation/ macOS：1brew install mitmproxyLinux和Windows：在官网mitmproxy.org下载安装 检查是否安装成功mitmdump --version123456C:\Users\10287&gt;mitmdump --versionMitmproxy: 5.1.1 binaryPython: 3.7.6OpenSSL: OpenSSL 1.1.1f 31 Mar 2020Platform: Windows-10-10.0.18362-SP0C:\Users\10287&gt;python包安装：注意python版本 &gt;= 3.6123python3 -m pip install --user pipxpython3 -m pipx ensurepathpipx install mitmproxydocker 安装方法：https://hub.docker.com/r/mitmproxy/mitmproxy/1docker pull mitmproxy/mitmproxy SSL 证书安装和charles代理工具一样，如果要抓取HTTPs报文，客户端（APP 或浏览器）需要安装SSL证书。 启动服务 12C:\Users\10287&gt;mitmdump -p 8999Proxy server listening at http://*:8999 浏览器设置代理使用SwitchyOmega插件添加mitmproxy代理，代理服务器地址设置为主机IP地址，代理端口8999SwitchyOmega插件下载地址：https://github.com/FelisCatus/SwitchyOmega/releases 浏览器输入 mitm.it选择对应系统的证书安装 手机证书安装方法同charles（地址为mitm.it）参考 charles SSL证书安装手机浏览器访问百度，命令行窗口显示https报文解析成功 mitmproxy录制回放录制回放参考：https://docs.mitmproxy.org/stable/tute-clientreplay/ 开始录制，保存到文件baidusearch中1D:\ProgramWorkspace\TestingDemo\test_mitmproxy&gt;mitmdump -p 8999 -w baidusearch 手机浏览baidu，进行百度搜索 停止录制：Ctrl+c 停止 回放cmd命令行输入如下命令：1mitmweb -p 8999 打开生成的baidusearch文档，可以查看报文交互过程 Rewrite要求：和charles一样，修改招商银行名称及股票价格。见接口测试代理工具charles mock测试 启动 mitmproxy 服务 12C:\Users\10287&gt;mitmdump -p 8999 Proxy server listening at http://*:8999 手机（或者模拟器）安装ssl证书，设置代理见 charles SSL证书安装 抓取雪球APP行情页面数据包 123C:\Users\10287&gt;mitmweb -p 8999Web server listening at http://127.0.0.1:8081/Proxy server listening at http://*:8999 开启抓包后，刷新雪球APP行情页面，找到行情页面报文，查看URL特征，用于下一步写脚本来找到它。 写一个脚本处理响应数据：test_mitmproxy_response.py 123456789101112131415#!/usr/bin/python3#-*-coding:utf-8-*-import jsondef response(flow): &quot;&quot;&quot; 1. 找到行情页面相关URL 2. 修改第一条记录（招商银行）的名称和股票价格 3. 将数据写入响应数据中 &quot;&quot;&quot; if &quot;quote.json&quot; in flow.request.pretty_url and &quot;x=&quot; in flow.request.pretty_url: data = json.loads(flow.response.content) data[&#x27;data&#x27;][&#x27;items&#x27;][0][&#x27;quote&#x27;][&#x27;name&#x27;] = data[&#x27;data&#x27;][&#x27;items&#x27;][0][&#x27;quote&#x27;][&#x27;name&#x27;] + &quot;test&quot; data[&#x27;data&#x27;][&#x27;items&#x27;][0][&#x27;quote&#x27;][&#x27;current&#x27;] = &#x27;50&#x27; flow.response.text = json.dumps(data) 运行脚本 1D:\ProgramWorkspace\TestingDemo\test_mitmproxy&gt;mitmdump -p 8999 -s test_mitmproxy_response.py 刷新雪球APP行情页面修改成功 Map Local要求和接口测试代理工具charles mock测试一样，我们直接使用数据倍增后的数据stock2.json，如果要实现自动化，可以使用python脚本对响应数据进行处理。 股票数据可以在上一节Rewrite 第3步中直接保存，或者通过charles获取数据。 参考官方文档提供的mitmproxy插件http-reply-from-proxy.py：https://docs.mitmproxy.org/stable/addons-examples/#http-reply-from-proxy ， 编写响应数据处理脚本test_request.py 12345678910111213141516#!/usr/bin/python3#-*-coding:utf-8-*-&quot;&quot;&quot;Send a reply from the proxy without sending any data to the remote server.&quot;&quot;&quot;from mitmproxy import httpdef request(flow: http.HTTPFlow) -&gt; None: if &quot;quote.json&quot; in flow.request.pretty_url and &quot;x=&quot; in flow.request.pretty_url: with open(&quot;D:/ProgramWorkspace/TestingDemo/test_mitmproxy/stock2.json&quot;,encoding=&quot;utf-8&quot;) as f: flow.response = http.HTTPResponse.make( 200, # (optional) status code f.read(), # (optional) content &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125; # (optional) headers ) 开启服务，运行脚本 123D:\ProgramWorkspace\TestingDemo\test_mitmproxy&gt;mitmdump -p 8999 -s test_request.pyLoading script test_request.pyProxy server listening at http://*:8999 刷新雪球APP行情页面修改成功 开启服务后，可以直接修改stock2.json内容，不需要重新拉起 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>接口测试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>mitmproxy</tag>
        <tag>mock</tag>
        <tag>接口测试</tag>
        <tag>代理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口测试代理工具charles mock测试]]></title>
    <url>%2Fposts%2Fapi-test-charles-guide%2F</url>
    <content type="text"><![CDATA[charles代理工具支持分析http/https协议，其中https包需要安装SSL证书。charles可用于mock测试，拦截请求与响应，支持对请求和响应进行动态修改，还可用于模拟慢速网络。本文介绍charles 的mock测试方法。 环境准备 首先需要安装Charles 的 CA 证书，安装方法参考charles SSL证书安装。 手机（或者模拟器）配置charles代理 手机安装雪球APP 确认charles可以抓取雪球APPhttps报文 Rewrite要求：修改招商银行名称及股票价格 选择【Tools】&gt; 【Rewrite】 勾选【Enable Rewrite】，添加一条规则雪球xueqiu，Location配置为所有报文 添加重写规则：“招商银行”改为“招商银行test”，股票价格改为”50“，添加完成后点击确认 刷新雪球APP行情页面，发现重写成功 Map Local要求： 修改股票名 “招商银行” 为 “招商银行test” 数据倍增 选择【Tools】&gt; 【Mirror】保存数据或者直接保存响应数据 修改文件股票名 “招商银行” 为 “招商银行test” jq命令数据倍增123stockdata=$(cat stock.json)stockdata=$(echo $stockdata | jq &#x27;.data.items+=.data.items&#x27; | jq &#x27;.data.items_size+=.data.items_size&#x27;)echo $stockdata &gt; stock2.json 设置maplocal选择刷新股票信息的报文，右键 &gt; 选择Map Local配置参数，导入生成的文件stock2.json 刷新雪球APP行情页面 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>接口测试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>mock</tag>
        <tag>接口测试</tag>
        <tag>代理工具</tag>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github/Gitee 搭建个人博客]]></title>
    <url>%2Fposts%2Fpersonal-blog-hexo-construction-guide%2F</url>
    <content type="text"><![CDATA[如果你有总结整理的习惯，可以考虑搭建一个个人博客，把文章发布在上面，相比于其它平台，个人博客的好处是你可以随便折腾，没有太多限制。搭建个人博客的框架有很多，比如wordpress、Hexo、Vuepress、Jekyll、Django等，Hexo博客简洁高效，配置简单，文章可以使用markdown语法编写，下面介绍 hexo博客搭建步骤。 准备条件为了节约成本，选择GitHub Pages或者Gitee Pages服务来部署博客，GitHub Pages 是GitHub提供的静态网站部署服务，Gitee Pages是gitee提供的服务，考虑到有时候GitHub有时候无法访问，我的博客是搭建在gitee上的。 如果没有账号，注册一个github或者gitee账号，注册完成后安装git客户端，推荐安装Git for Windows，安装方法可以参考：Git简易教程-安装及简单使用 1. 配置Git SSH公钥通过ssh keys将本地的项目与Github/gitee关联起来，配置方法参考：同一台电脑配置Gitee、Github 的 Git SSH公钥 2. GitHub Pages在 GitHub 新建一个名称为 {username}.github.io的仓库，username是你的github用户名 3. Gitee PagesGitHub Pages 和Gitee Pages选一个就好，Gitee和GitHub有点不一样，建一个和你的博客项目名一样仓库： 4. 安装 Node.jsNode.js安装方法参考Appium 介绍及环境安装，命令行窗口中运行node -v查看是否安装成功。使用如下命令更新：1$ npm install npm@latest -g准备工作做好后，下面开始Hexo博客的搭建和部署。 安装 Hexo首先安装 Hexo 的命令行工具，用于快速创建项目、页面、编译、部署 Hexo 博客。命令如下：npm install -g hexo-cli安装完成后，查看hexo版本：12345678910111213141516171819$ hexo versionhexo-cli: 4.2.0os: Windows_NT 10.0.19041 win32 x64node: 12.19.0v8: 7.8.279.23-node.44uv: 1.39.0zlib: 1.2.11brotli: 1.0.9ares: 1.16.0modules: 72nghttp2: 1.41.0napi: 7llhttp: 2.1.2http_parser: 2.9.3openssl: 1.1.1gcldr: 37.0icu: 67.1tz: 2019cunicode: 13.0安装成功！ 初始化项目创建项目先cd 进入你要创建博客项目的目录下：hexo init &#123;name&#125;name为博客项目名，注意如果使用Gitee Pages部署服务，创建的仓库名和这里初始化的博客项目名相同。 Hexo 编译进入新生成的博客目录下，调用 Hexo 的 generate 命令，将 Hexo 博客（Markdown文件，在source\_posts目录下，后面会详细介绍）编译生成 HTML 代码：hexo generate生成的public 文件夹里面包含了 js、css、font 等内容，博客文章在public /posts文件夹下 本地运行博客利用 Hexo 提供的 serve 命令在本地运行博客：hexo serve 浏览器访问http://localhost:4000，就可以打开博客了，有一篇默认文章： 这是博客的默认配置，可以修改配置文件来修改样式，我们先部署到GitHub Pages 上，看看效果。 部署配置将编译好的博客发布到github，需要配置github的项目仓库地址。 打开根目录下的 _config.yml 文件，找到 Deployment ，修改如下：123456# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.htmldeploy: type: git repo: git@github.com:ZHHAYO&#x2F;ZHHAYO.github.io.git branch: master仓库地址为你在准备条件中新建的仓库地址，查看方式如下： gitee类似： HTTPs或者SSH地址都可以。 注意冒号后面要加空格 安装hexo-deployer-git插件支持 Git 的部署插件，用于将blog部署到 GitHub 上面安装命令：npm install hexo-deployer-git --save 部署部署命令：hexo deploy 在 blog 目录下，分别输入如下三条命令： hexo clean //清除缓存 hexo g //生成静态文件 hexo d //部署 其中 clean 用于清除缓存，g 是 generate 生成网站资源，d 就是 deploy 部署网站。 启动GitHub Pages进入GitHub仓库可以看到public里面的内容传到了仓库里面： 在博客仓库的Settings界面，下拉找到GitHub Pages，生成博客网址 部署成功后就可以通过https://{github用户名}.github.io/ 访问个人博客了 启动Gitee Pages如果部署到Gitee，也可以在博客仓库下看到上传的资源： Gitee的启动方式类似：目前就完成了博客的初始构建，下面就进行博客的基本配置，设置主题等 部署完成后，通过https://{gitee用户名}.gitee.io/ 访问个人博客 Hexo的初步部署就完成了，下一篇文章介绍博客文章创建方法和博客主题的简单配置。 注意：博客更新到GitHub后，GitHub Pages会自动部署更新后的博客，而Gitee需要手动更新一下。 标签页添加标签页命令：hexo new page tags 执行这个命令之后会自动帮我们生成一个 source/tags/index.md 文件：1234---title: tagsdate:2019-09-2616:44:17--- 然后再在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下：123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 分类页添加分类页命令：hexo new page categories 同样地，会生成一个 source/categories/index.md 文件。 在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下：123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 创建博客文章博客最核心部分还是你输出的的文章，Hexo博客文章可以使用Markdown语法编写，下面介绍文章创建方法。参考文档：https://hexo.io/zh-cn/docs/writing.html 新建文章在博客根目录命令行输入1hexo new [layout] &lt;title&gt;layout指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 新建一篇名为「HelloWorld」的文章，在博客目录下打开命令行：hexo new hello-world 创建的文章会出现在 source/_posts 文件夹下，是 MarkDown 格式：HelloWorld.md。使用 MarkDown 编辑HelloWorld.md文件就可以了，markdown 语法参考http://www.markdown.cn/#inline-html， 文章编辑好后，执行：1234hexo clean //清除缓存hexo g //生成静态文件hexo s //本地查看效果 访问 http://localhost:4000hexo d //部署创建的文章HelloWorld.md会编译到 \public\posts\HelloWorld目录下，编译为html文件。 草稿箱也可以新建draft page，顾名思义就是草稿，在博客执行编译操作时，草稿文章不会编译。 创建方法：1$ hexo new draft HelloWorld创建的草稿文章会出现在 source/_drafts 文件夹下，可以通过如下命令在本地查看草稿文章：123$ hexo server --draft# 或者$ hexo s --draft完成草稿文章后，可以通过如下命令发布：1$ hexo publish HelloWorld草稿HelloWorld会移到_posts目录里面去。 当然，新建文章和草稿可以采用手动的方式，最对应的目录下新建Markdown文件即可。 文章标签、分类在新建的文章开头编辑文章的题目，作者，日期，标签等。12345678910---title: testdate: 2020-10-17 17:24:36author: hiyocopyright: truetags: - 标签1 - 标签2categories: 分类--- 子分类将该文章放到 Sports/Baseball 这个分类下。123categories: - Sports - Baseball 或者：12categories: - [Sports,Baseball] 多个分类将文章同时分到两个或者多个不同的类目下123categories: - [Sports] - [Play] 123categories: - [Sports,Baseball] - [Play] 博客插入图片介绍三种方法 src 链接外部的 src 链接地址，存放在 CDN 上，或某图床上 本地绝对路径将图片统一放在 source/images 文件夹中，在博客中使用如下方式引用图片：1![img](/images/test.jpg) 本地相对路径将放在文章自己的目录中，配置项目配置文件 _config.yml ：1post_asset_folder: true执行命令 $ hexo new post_name，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name 。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了。1![img](test.jpg)也可以手动创建博客文件和同名文件夹。 搜索页先安装一个插件 hexo-generator-searchdb：npm install hexo-generator-searchdb --save 修改项目的 _config.yml 配置文件：12345search: path: search.xml field: post format: html limit:10000 修改主题的 _config.yml 配置文件：1234567891011local_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 5 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false --THE END--]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
        <tag>Gitee Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客主题配置]]></title>
    <url>%2Fposts%2Fpersonal-blog-hexo-construction-guide2%2F</url>
    <content type="text"><![CDATA[本文介绍Hexo博客Next主题配置，博客配置效果：https://hiyong.gitee.io/。 配置站点信息修改根目录下的 _config.yml 文件，找到 Site 区域，配置站点标题 title、副标题 subtitle 、关键字 keywords，语言等内容：12345678\# Sitetitle: HiYongsubtitle: XXXXXXXXXXXXXXXXXXdescription: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXkeywords: “技术分享，计算机网络，自动化测试，python，Java，机器学习”author: HiYolanguage: zh-CNtimezone: 修改主题Hexo有各种炫酷的主题，可以去 https://hexo.io/themes/ 查看，选择自己喜欢的主题，个人比较喜欢简洁的，比如Next主题，下面介绍Next主题配置方法。 Next 主题GitHub地址：https://github.com/theme-next/hexo-theme-next 命令行进入到项目的根目录，执行如下命令，下载到themes/next 文件夹下：1git clone https://github.com/theme-next/hexo-theme-next.git themes/next或者直接下载 修改项目根目录下的_config.yml 文件，找到 theme 字段，修改为 next 即可，修改如下：1theme: next 然后本地重新开启服务，访问刷新下页面，就可以看到 next 主题就切换成功了123hexo clean hexo g hexo serve Next主题配置主题设置可以参考官方文档：https://theme-next.org/docs/， 修改 themes/next/_config.yml 文件 样式Next 主题提供了多种样式，选择Pisces 样式，其它样式123456# Schemesscheme: Pisces# scheme: Muse# scheme: Mist# scheme: Pisces# scheme: Gemini直接刷新页面 faviconFavicon(favorites icon)，是与某个网站或网页相关联的图标，也被称为 website icon（网页图标）、page icon（页面图标）或 url icon（URL 图标）。 favicon 就是站点标签栏的小图标，默认使用的 Hexo 图标，可以自己定制小图标。可以使用https://realfavicongenerator.net 生成各种尺寸的图标，上传你制作好的图片，打包下载各种尺寸和适配不同设备的小图标。 图标下载下来之后把它放在 themes/next/source/images 目录下面。然后在配置文件里面找到 favicon 配置项，把一些相关路径配置进去即可，示例如下：12345favicon: small: /images/logo_favicon-16x16.png medium: /images/logo_favicon-32x32.png apple_touch_icon: /images/logo_apple-touch-icon.png safari_pinned_tab: /images/logo.svg配置完成之后刷新页面，整个页面的标签图标就被更新了。 avataravatar 为站点的头像，显示在作者信息旁边 将头像放置到 themes/next/source/images/avatar.png 路径 然后在主题 _config.yml 文件下编辑 avatar 的配置，修改为正确的路径。 12345678# Sidebar Avataravatar: # url: #/images/avatar.gif url: /images/logo_android-chrome-192x192-wechat.png # If true, the avatar would be dispalyed in circle. rounded: false # If true, the avatar would be rotated with the cursor. rotated: false rounded：是否显示圆形rotated：是否带有旋转效果 rss 简易信息聚合 (Really Simple Syndication或Richsite summary)是站点用来和其他站点之间共享内容的一种简易方式。 1. 安装插件hexo-generator-feed在项目根目录下运行命令：npm install hexo-generator-feed --save 安装完成之后，站点会自动生成 RSS Feed 文件 2. 编辑项目配置文件在项目根目录下的 _config.yml 文件中添加以下代码12345678910feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &quot; &quot; order_by: -date icon: icon.png将 url 修改为自己博客的域名1url: https://hiyong.gitee.io 3. 修改 Next 主题配置文件修改Next 主题配置文件_config.yml：1234social: GitHub: https://github.com/hiyongz/|| fa fa-github # E-Mail: zhiyo2016@163.com/|| envelope RSS: /atom.xml || fa fa-rss 代码块修改Next 主题配置文件 _config.yml ，设置代码块样式，比如设置为类似 Mac 的样式：123456789codeblock: highlight_theme: normal # Add copy button on codeblock copy_button: enable: true # Show text copy result. show_result: true # Available values: default | flat | mac style: mac 回到页面顶部修改Next 主题配置文件 _config.yml 的 back2top 字段：123456back2top: enable: true # Back to top in sidebar. sidebar: true # Scroll percent label in b2t button. scrollpercent: true 阅读进度条在文章上侧显示阅读进度条，修改Next 主题配置文件 _config.yml：123456reading_progress: enable: true # Available values: top | bottom position: top color: &quot;#37c6c0&quot; height: 2px GitHub 图标右上角 GitHub 图标1234github_banner: enable: true permalink: https://github.com/hiyongz title: Follow me on GitHub 数学公式渲染公式，配置如下：12345678910111213math: enable: true per_page: true mathjax: enable: true # See: https://mhchem.github.io/MathJax-mhchem/ mhchem: true katex: enable: false # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex copy_tex: false mathjax 需要安装插件 hexo-renderer-kramed，也可以安装 hexo-renderer-pandoc，命令如下：12npm un hexo-renderer-marked --savenpm i hexo-renderer-kramed --save 添加自定义 Page博客根目录运行：1hexo new page name //name为新增Page名称 执行成功后，在 source 目录会生成了一个 name目录，编辑目录下index.md 文件： 1234567---title: booksdate: 2020-11-22 22:05:40type: bookscomments: false---正文：。。。。。 编辑主题配置文件 themes/next/_config.yml： 图标名book可以在 https://fontawesome.dashgame.com/ 中查找，home、tags、th等图标都是在这个网站上获取的。 编辑 themes/next/languages/zh-CN.yml 文件 重新编译部署后，刷新页面，配置成功： Valine 评论系统 Valine 评论系统不需要登录便可以评论 支持 MarkDown 语法 无后端实现，快速高效 1. 注册 LeanCloudhttps://leancloud.cn/dashboard/login.html#/signin 2. 创建应用访问控制台，创建应用，选择开发版，创建好之后就生成了 App ID 和 App Key 创建完成后，打开应用，点击存储，创建 Counter 和 Comment 两个 Classes： 点击设置 -&gt; 安全中心 -&gt; 在服务开关，打开数据存储，在 Web 安全域名输入框填写博客的域名地址： 3. 设置 Next 主题配置文件在主题的配置文件中，修改 valine 配置 修改 valine.min.js 的 cdn 文件地址，到 https://www.jsdelivr.com/package/npm/valine 这个地址查看最新版本的Valine， 复制最新cdn地址，修改主题配置文件_config.yml 。1valine: https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js 文章末尾添加公众号订阅1. 准备公众号二维码图片将二维码图片放到\source\uploads目录下 2. 修改主题文件找到 themes\next\layout_macro\post.swig 文件，在 footer前面添加以下代码：1234&lt;div id=&quot;wechat_subscriber&quot; style=&quot;display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;&quot;&gt; &lt;img id=&quot;wechat_subscriber_qcode&quot; src=&quot;/uploads/wechat.jpg&quot; style=&quot;width: 200px; max-width: 100%;&quot;&gt; &lt;div&gt;关注微信公众号，及时接收最新技术文章！&lt;/div&gt;&lt;/div&gt; 修改主题配置文件_config.yml ，添加如下代码：12345# Wechat Subscriberwechat_subscriber: enable: true qcode: /uploads/wechat.jpg description: &quot;欢迎您扫一扫上面的微信公众号，订阅我的博客！&quot; 文章底部版权声明1. my-copyright.swig在目录 themes/next/layout/_macro/ 下添加 my-copyright.swig ，内容如下：12345678910111213141516171819202122232425262728293031&#123;% if page.copyright %&#125;&lt;div class=&quot;my-post-copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css&quot;&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;本博客文章除特别声明外，均采用&lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;CC BY-NC-ND 4.0&lt;/a&gt; 许可协议。转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&#x27;.fa-clipboard&#x27;); clipboard.on(&#x27;success&#x27;, $(function()&#123; $(&quot;.fa-clipboard&quot;).click(function()&#123; swal(&#123; title: &quot;&quot;, text: &#x27;复制成功&#x27;, html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 2. my-post-copyright.styl在目录 themes/next/source/css/_common/components/post/ 下添加 my-post-copyright.styl，内容如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546.my-post-copyright &#123; //width: 85%; //max-width: 45em; //margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; border-left: 3px solid #ff1700; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my-post-copyright p&#123;margin:0;&#125;.my-post-copyright span &#123; display: inline-block; width: 5.2em; color: #333333; // title color font-weight: bold;&#125;.my-post-copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my-post-copyright a &#123; color: #808080; border-bottom:0;&#125;.my-post-copyright a:hover &#123; color: #0593d3; // link color text-decoration: underline;&#125;.my-post-copyright:hover .fa-clipboard &#123; color: #000;&#125;.my-post-copyright .post-url:hover &#123; font-weight: normal;&#125;.my-post-copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my-post-copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 3. post.swig修改 themes/next/layout/_macro/post.swig，在前面添加公众号的位置上面添加：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &#x27;my-copyright.swig&#x27; %&#125; &#123;% endif %&#125;&lt;/div&gt; 4. post.styl 文件打开 themes/next/source/css/_common/components/post/post.styl 文件，在最后一行增加代码：1@import &#x27;my-post-copyright&#x27; 5. 修改主题配置文件1234post_copyright: enable: true license: CC BY-NC-ND 4.0 license_url: https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh 字数统计、阅读时间统计安装 hexo-wordcount 插件12npm i hexo-wordcount --savenpm install hexo-symbols-count-time --save在主题配置文件 _config.yml 中打开 wordcount 统计功能123456789101112131415post_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: truesymbols_count_time: separated_meta: true # 是否另起一行（true的话不和发表时间等同一行） item_text_post: true # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长） item_text_total: false # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长） awl: 4 # Average Word Length wpm: 275 # Words Per Minute（每分钟阅读词数） suffix: mins. hexo d 部署失败问题hexo d 部署失败问题：原因是没有配置git仓库同户名和邮箱地址，因为我电脑上配置了github和gitee，所以删除了全局的同户名和邮箱地址。 解决方案是添加本地用户名和邮箱：12git config user.name &quot;github或者gitee用户名&quot;git config user.email &quot;github或者gitee采用的邮箱&quot;注意前提是已经配置了SSH公钥，如果没有配置可参考同一台电脑配置Gitee、Github 的 Git SSH公钥 --THE END--]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
        <tag>Gitee Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口测试框架Requests]]></title>
    <url>%2Fposts%2Fapi-test-requests%2F</url>
    <content type="text"><![CDATA[python内置了HTTP库 urllib，可以用于发送http请求。基于Python的第三方库Requests是对urllib的再次封装，相比urllib更加简洁易用。Requests库不仅用于接口测试，还用在Python爬虫、量化交易等。本文介绍Requests库的使用方法。 RequestsHTTP接口测试涉及到以下几个方面： 构造请求方法：get、post、put、 delete、head …… 构造请求体：form、json、xml、 binary 分析响应结果：status code、 response body、 json path、 xpath 下面介绍使用Requests怎么实现这些步骤。 Requests安装Github地址：Python HTTP Requests for Humansrequests官方文档: https://requests.readthedocs.io/zh_CN/latest/index.html 安装：1pip install requests http请求响应测试接口：https://httpbin.testing-studio.com/也可以自己本地搭建，GitHub地址：https://github.com/postmanlabs/httpbin Requests常见接口请求方法构造常见接口请求方法：123456r = requests.get(&#x27;https://api.github.com/events&#x27;) #get请求r = requests.post(&#x27;http://httpbin.org/post&#x27;, data = &#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;) #post请求r = requests.put(&#x27;http://httpbin.org/put&#x27;, data = &#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)r = requests.delete(&#x27;http://httpbin.org/delete&#x27;)r = requests.head(&#x27;http://httpbin.org/get&#x27;)r = requests.options(&#x27;http://httpbin.org/get&#x27;) 请求目标构造请求URL123import requestsr = requests.get(&#x27;https://api.github.com/events&#x27;) #get请求print(r.status_code)输出：1200 header构造普通的 header123url = &#x27;https://api.github.com/some/endpoint&#x27;headers =&#123;user-agent&#x27;: &#x27;my-app/0.0.1&#x27;&#125;r= requests.get(url, headers=headers) cookie123url = &#x27;http://httpbin.org/cookies&#x27;cookies = dict(cookies_are=&#x27;working&#x27;)r = requests.get(url, cookies=cookies) 构造请求体请求体通过键值对的形式编码，有多种形式的请求体，比如query参数、form请求、binary请求（上传文件）以及结构化请求：json、xml、 json rpc等。 Get Query请求12payload= &#123;&#x27;key&#x27;:&#x27;valuel&#x27;,&#x27;key2&#x27;:&#x27;value2&#x27;&#125;r = requests.get(&#x27;https://httpbin.org/get&#x27;, params=payload) Form请求参数12payload = &#123;&#x27;key&#x27;:&#x27;valuel&#x27;,&#x27;key2&#x27;:&#x27;value2&#x27;&#125;r = requests.post(&quot;https://httpbin.org/post&quot;, data=payload) JSON请求体构造123url = &#x27;https://api.github.com/some/endpoint&#x27;payload = &#123;&#x27;some&#x27;: &#x27;data&#x27;&#125;r = requests.post(url, json=payload) xml请求1234import requests xml =&quot;&quot;&quot;&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;&lt;a&gt;6&lt;/a&gt;&quot;&quot;&quot; headers=&#123;&#x27;Content-type&#x27;:&#x27;application/xml&#x27;&#125; r = requests.post(&#x27;http://httpbin.org/post&#x27;, data=xml, headers=headers).text binary请求上传文件123url = &#x27;http://httpbin.org/post&#x27;files = &#123;&#x27;file&#x27;: open(&#x27;report.xls&#x27;, &#x27;rb&#x27;)&#125;r = requests.post(url, files=files) 接口测试断言接口测试中需要通过检查响应是否符合预期来测试接口有效性，也就是对接口响应进行断言。 响应 r.url： r.status_code r.headers r.cookies r.encoding r.content r.text r.json() 123456import requestsclass TestRequest(): def test_get(self): r = requests.get(&#x27;https://api.github.com/events&#x27;) #get请求 assert r.status_code == 200 结构化响应断言下面是请求Github项目仓库API，GitHub API可参考：https://docs.github.com/cn/rest/overview。 123456import requestsimport jsonr = requests.get(&#x27;https://api.github.com/repos/hiyongz/DjangoDemo&#x27;)json_data = r.json()print(json.dumps(json_data, indent=4)) 响应的部分json数据如下：1234567891011121314&#123; &quot;id&quot;: 272401302, &quot;node_id&quot;: &quot;MDEwOlJlcG9zaXRvcnkyNzI0MDEzMDI=&quot;, &quot;name&quot;: &quot;DjangoDemo&quot;, &quot;full_name&quot;: &quot;hiyongz/DjangoDemo&quot;, &quot;private&quot;: false, &quot;owner&quot;: &#123; &quot;login&quot;: &quot;hiyongz&quot;, &quot;id&quot;: 20513021, &quot;node_id&quot;: &quot;MDQ6VXNlcjIwNTEzMDIx&quot;, &quot;avatar_url&quot;: &quot;https://avatars0.githubusercontent.com/u/20513021?v=4&quot;, &quot;gravatar_id&quot;: &quot;&quot;, ...................&#125;接下来介绍不同方法对这个json响应进行断言。 json断言json断言12345import requestsdef test_json(self): r = requests.get(&#x27;https://api.github.com/repos/hiyongz/DjangoDemo&#x27;) assert r.json()[&#x27;owner&#x27;][&#x27;login&#x27;] == &quot;hiyongz&quot; JSONPath断言JSONPath文档：https://goessner.net/articles/JsonPath/JSONPath表达式与XPath类似，是XPath在json中的应用，全称XPath for JSON，用于从JSON文档中提取数据。 JSONPath表达式和XPath语法对比如下： XPath JSONPath Description / $ 跟节点 . @ 当前节点 / . or [] 儿子节点 .. N/A 父节点 // .. 子孙节点 * * 匹配所有节点 @ N/A 属性 [] [] 下标操作符 \ [,] 多选 N/A [start​ : end : ​step] 切片 [] ?() 过滤表达式 N/A () script 表达式 () N/A 分组 Python中有个jsonpath库可用于处理json数据：https://pypi.org/project/jsonpath/安装：pip install jsonpath 和前面一样，断言登录名：123456import requestsfrom jsonpath import jsonpathdef test_json(self): r = requests.get(&#x27;https://api.github.com/repos/hiyongz/DjangoDemo&#x27;) assert jsonpath(r.json(), &#x27;$..login&#x27;)[0] == &quot;hiyongz&quot; schema断言JSON Schema可以用来注释和验证 JSON 文档，官网：http://json-schema.org/。 JSON Schema可用来添加自定义规则，可以自定义数据类型：1234567schema = &#123; &quot;type&quot; : &quot;object&quot;, &quot;properties&quot; : &#123; &quot;price&quot; : &#123;&quot;type&quot; : &quot;number&quot;&#125;, &quot;name&quot; : &#123;&quot;type&quot; : &quot;string&quot;&#125;, &#125;,&#125;可以看到，除了字段值断言外，可以使用JSON Schema来断言接口返回值的类型。 把json格式转成schema，在线生成schema网址：https://jsonschema.net/ jsonschema是使用JSON Schema的Python库，通过 pip install jsonschema 命令安装。1234567891011121314import requestsfrom jsonschema import validatedef test_get_login_jsonschema(self): url = &quot;https://api.github.com/repos/hiyongz/DjangoDemo&quot; r = requests.get(url) data = r.json() schema = &#123; &quot;name&quot; : &quot;DjangoDemo&quot;, &quot;owner&quot; : &#123; &quot;login&quot; : &quot;hiyongz&quot;, &#125;, &#125; validate(data, schema=schema) JSON Schema可以用来进行自动校验：在接口测试中，每次运行的时候自动保存当前的 schema，下次运行对比上次的 schema，如果发现变更就报错 xml解析断言xml文件解析可以使用requests_xml，参考：https://github.com/erinxocon/requests-xml 也可以使用Python xml.etree.ElementTree模块解析xml数据，可以使用Xpath定位，使用方法参考：Web自动化测试：xpath &amp; CSS Selector定位 xml.etree.ElementTree模块xml解析举例：1234567import xml.etree.ElementTree as ETroot = ET.fromstring(countrydata)root.findall(&quot;.&quot;)root.findall(&quot;./country/neighbor&quot;)root.findall(&quot;.//year/..[@name=&#x27;Singapore&#x27;]&quot;)root.findall(&quot;.//*[@name=&#x27;Singapore&#x27;]/year&quot;)root.findall(&quot;.//neighbor[2]&quot;) 和JSON Schema一样，也有一个XML Schema，用于解析xml文档，文档参考：https://www.w3.org/2001/XMLSchema Python库安装： pip install xmlschema hamcrest断言除了常用的Assert断言以外，有一个功能更加强大的断言方法叫Hamcrest 断言，具有丰富的断言匹配器，支持多种语言，官网地址：http://hamcrest.org/ 下面简单介绍一下Python中的hamcrest断言使用方法 PyHamcrest GitHub仓库地址：https://github.com/hamcrest/PyHamcrest文档：https://pyhamcrest.readthedocs.io/en/v2.0.2/tutorial/ 安装PyHamcrest：1pip install PyHamcrest断言登录名：1234567import requestsfrom hamcrest import *def test_hamcrest(self): r = requests.get(&#x27;https://api.github.com/repos/hiyongz/DjangoDemo&#x27;) data = r.json() assert_that(data[&#x27;owner&#x27;][&#x27;login&#x27;], equal_to(&quot;hiyongz&quot;)) --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>Requests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python PEP—Python增强提案]]></title>
    <url>%2Fposts%2FPython-Enhancement-Proposals%2F</url>
    <content type="text"><![CDATA[PEP的全称是Python Enhancement Proposals，Python增强提案。描述了Python的语言特性、功能、编程规范等，包括了技术规范和功能的基本原理说明，是了解Python语言的详细指南。PEP官网：https://www.python.org/dev/peps/ PEP创建于2000年，到目前已经有上千个提案了，下面介绍几个值得仔细阅读了解的提案。 1. PEP 8 - 编码规范PEP 8 — Style Guide for Python Code：定义了编写 Python 代码的规范和编码原则 2. PEP 257 - 文档注释PEP 257 — Docstring Conventions文档注释规范 3. PEP 20 - Python之禅PEP 20 — The Zen of PythonPython之禅，在Python终端导入this模块查看： 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&#x27;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&#x27;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&#x27;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&#x27;s do more of those! 4. PEP 202 - 列表PEP 202 — List Comprehensions列表生成式 5. PEP 274 - 字典PEP 274 — Dict Comprehensions字典生成式 6. PEP 234 - 迭代器PEP 234 — Iterators迭代器 7. PEP 279 - enumeratePEP 279 — The enumerate() built-in functionenumerate枚举函数 8. PEP 282 - 日志PEP 282 — A Logging System日志模块 9. PEP 289 - 生成器PEP 289 — Generator Expressions生成器表达式 10. PEP 318 - 装饰器PEP 318 — Decorators for Functions and Methods装饰器 11. PEP 309 - 偏函数PEP 309 — Partial Function Application：Python 偏函数 12. PEP 333 - web 服务PEP 333 — Python Web Server Gateway Interface v1.0：Web开发相关，WSGI协议，描述 web 服务器和 Python web 应用程序\框架之间的标准接口。PEP 3333 — Python Web Server Gateway Interface v1.0.1：PEP 333的更新版本 13. PEP 343 - with语句PEP 343 — The “with” Statementwith语句 14. PEP 484 - 类型提示PEP 484 — Type Hints：Python类型提示（Type Hints），在Python3.5.0中引入，允许开发者指定变量类型。 15. PEP 342 - 协程PEP 342 — Coroutines via Enhanced Generators：协程和yield 16. PEP 498 - 字符串插值PEP 498 — Literal String InterpolationPython3.6新提出的字符串插值方法：12345678&gt;&gt;&gt; import datetime&gt;&gt;&gt; name = &#x27;Fred&#x27;&gt;&gt;&gt; age = 50&gt;&gt;&gt; anniversary = datetime.date(1991, 10, 12)&gt;&gt;&gt; f&#x27;My name is &#123;name&#125;, my age next year is &#123;age+1&#125;, my anniversary is &#123;anniversary:%A, %B %d, %Y&#125;.&#x27;&#x27;My name is Fred, my age next year is 51, my anniversary is Saturday, October 12, 1991.&#x27;&gt;&gt;&gt; f&#x27;He said his name is &#123;name!r&#125;.&#x27;&quot;He said his name is &#x27;Fred&#x27;.&quot; 17. PEP 3101 - 字符串格式化PEP 3101 — Advanced String Formatting字符串格式化 --THE END--]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PEP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同一台电脑配置Gitee、Github 的 Git SSH公钥]]></title>
    <url>%2Fposts%2Fgit-generate-ssh-public-key-guide%2F</url>
    <content type="text"><![CDATA[为了安全，远程登录上传项目需要通过认证，Git 服务器基本都使用 SSH 公钥进行认证登录，为了减去每次登录需要输入秘钥的麻烦，可以事先配置ssh公钥，SSH 密钥默认存储在 ~/.ssh 目录下。 下面介绍一台电脑上配置 Gitee 和 GithubSSH公钥的方法。 1. 清除 git 的全局设置如果已经配置Git，需要先清除git 的全局设置，如果没有就跳过这一步。git config --global --list 查看是否设置： 删除设置1234git config --global --unset user.namegit config --global --unset user.emailgit config --global --unset yser.namegit config --global --unset yser.email 2. 创建 ssh key进入 .ssh 文件夹下，生成 key123cd ~/.ssh # 进入 .ssh 文件夹下# 生成 key，邮件地址为 Gitee 或者 Github 使用的邮件地址 ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot; 配置Github 的 ssh key1ssh-keygen -t rsa -C &quot;Github 使用的邮件地址&quot; 设置 Github 的 ssh key 为 id_rsa_github 配置Gitee 的 ssh key1ssh-keygen -t rsa -C &quot;Gitee 使用的邮件地址&quot; 设置 Gitee 的 ssh key 为 id_rsa_gitee 完成后会在~/.ssh / 目录下生成以下文件 id_rsa.github id_rsa.github.pub id_rsa.gitee id_rsa.gitee.pub 3. 在 Github 和 Gitee 中添加 public key进入 .ssh 文件夹下1cd ~/.ssh 配置GitHub 的public key复制 public key12# 查看 id_rsa_github.pub 文件内容 cat id_rsa_github.pub 点击新增 SHH key 粘贴复制的public key 配置Gitee 的public key复制 public key，新增 SHH key12# 查看 id_rsa_github.pub 文件内容 cat id_rsa_gitee.pub 4. 创建配置文件 解决ssh冲突在 .ssh 文件夹中创建 config 文件12cd ~/.ssh vim config 添加以下内容以区分两个 ssh key：1234567891011# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_github# giteeHost gitee.comHostiName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_gitee 5. 测试连接是否正常1ssh -T git@github.com 查看是否连接成功 1ssh -T git@gitee.com 连接成功 --THE END--]]></content>
      <categories>
        <category>版本管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[charles SSL证书安装]]></title>
    <url>%2Fposts%2Fapi-test-charles-ca-certificate-install%2F</url>
    <content type="text"><![CDATA[charles抓取https协议报文需要配置SSL通用证书，否则会导致乱码，本文介绍Charles 的 CA 证书安装方法。 1. 电脑安装SSL证书选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate” 2. 浏览器安装SwitchyOmega插件插件下载地址：https://github.com/FelisCatus/SwitchyOmega/releases 设置代理：charles默认代理端口为8888 设置完成后，浏览器开启charles代理。 3. 配置SSL的抓取域名选择 “Proxy” -&gt; “SSL Proxying Settings”启用SSL代理，配置location 4. 浏览器安装SSL证书选择 “Help” -&gt; “SSL Proxying” -&gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”弹出如下提示框 浏览器地址栏输入“chls.pro/ssl” 下载证书 chrome浏览器安装： 5. 手机安装SSL证书设置手机代理 手机浏览器输入“chls.pro/ssl” 下载证书 点击下载的证书文件进行安装设置PIN码后安装成功 手机浏览器访问baidu，charles查看https报文：证书安装成功 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>charles</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode + Python环境配置]]></title>
    <url>%2Fposts%2Fpython-vscode-jupyter-notebook%2F</url>
    <content type="text"><![CDATA[VSCode Python开发环境配置 Visual Studio Code 下载安装Visual Studio Code下载地址: https://code.visualstudio.com/Download 安装Visual Studio Code后，打开Visual Studio Code，安装python： 设置 Python 环境Ctrl+Shift+P 输入>python select Interpreter 会列出系统所有python解释器，选择对应的解释器： 安装code runner插件配置code runner 运行代码方式： 键盘快捷键 Ctrl+Alt+N 快捷键 Ctrl+Shift+P调出 命令面板, 然后输入 Run Code 在编辑区，右键选择 Run Code 在左侧的文件管理器，右键选择 Run Code 右上角的运行小三角按钮 停止代码运行： 键盘快捷键 Ctrl+Alt+M 快捷键 Ctrl+Shift+P调出 命令面板, 然后输入 Stop Code Run 在Output Channel，右键选择 Stop Code Run Run in Terminal可以把代码放到 VS Code 内置的 Terminal 来运行 选择 文件 -&gt; 首选项 -&gt; 设置，打开VS Code设置页面，找到 Run Code configuration，勾上 Run In Terminal 选项。设置之后，代码就会在 Terminal 中运行了。 配置VSCode自动保存进入设置界面 Jupyter Notebook插件Jupyter Notebook （https://jupyter.org/）几乎支持所有语言，把代码、输出、解释文档、多媒体资源整合在了一起。 Jupyter Notebook应用广泛，Google的Google Colab平台就是基于 Jupyter Notebook改进的。 Jupyter 主要优点包括： 将代码、文档整合到一起，这样更加方便，提高效率。 Cell 的概念，代码可以一块一块的运行，实现交互编程。 Jupyter 官方的 Binder 、Google Colab平台可以直接运行代码，不需要重新安装依赖。 VSCode Jupyter Notebook插件安装：搜索Jupyter，安装插件安装成功后，新建*.ipynb文件： 快捷键显示所有函数列表Shift+Ctl+O 向下复制：设置为Ctl+D点击File -&gt; Preferences -&gt; Keyboard Shortcuts，找到copy line down，设置为Ctrl+D --THE END--]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>VSCode</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口测试简介及 Web 服务架构]]></title>
    <url>%2Fposts%2Fapi-test-and-web-protocol%2F</url>
    <content type="text"><![CDATA[API (Application Programming Interface，应用程序接口)是支持两个相互独立的软件系统之间进行通信和数据交换的计算机接口，它定义了两个软件系统之间可以发出什么请求、如何发出请求、可用的数据格式等。 接口测试什么是接口测试？接口测试是一种验证应用程序接口(API)的软件测试类型，目的是检查系统组件间接口的功能、可靠性、性能和安全性。在 API 测试中，不使用标准的用户输入(键盘)和输出，而是使用软件向 API 发送调用，获取输出，并记录系统的响应。API 测试与 GUI 测试不同，不关注应用程序的外观和使用体验，专注于软件架构的业务逻辑层。 接口测试必要性使用接口测试可以更早的发现问题，让Bug提前暴露出来，提高测试效率，实现更快的质量反馈接口测试保证的是后端工程师的产出质量，不能解决移动端的质量，所以接口测试不能取代UI测试。大前端工程师的产出质量只能通过UI测试保证。 Web APIAPI架构有REST，XML-RPC, SOAP ，JSON-RPC等，REST和RPC是常用的两种方式，XML-RPC 和 SOAP使用xml存储数据，进行数据传输，REST基于JSON作为传输格式，使用起来比较简单，学习成本低。下面简要介绍REST和RPC这两种架构。 RPCRPC(Remote Procedure Call, 远程过程调用 ) 由Bruce Jay Nelson 在 1984 年提出，在客户端通过参数传递的方式调用远程服务器，以本地代码调用的方式实现远程执行，采用C/S模式。由阿里开发的基于java的Apache Dubbo就是采用的RPC框架，通讯协议是RPC协议。底层应用层协议支持 tcp http, hessian, thrift, grpc等。 RESTREST(representational state transfer，表现层状态转移)由Roy Thomas Fielding在他的博士论文中提出，REST 是一种架构设计风格，不是架构，也不是协议。主要特征： 每一个URL代表一种资源 客户端和服务器之间，传递这种资源的某种表现层 客户端通过四个HTTP动词，对服务器端资源进行操作，实现表现层状态转化 借助于http协议的基本请求方法代表资源的状态切换，将所有 Web 服务抽象为资源： post：新增或者更新资源 get：获取资源 put：更新资源 delete：删除资源 REST API文档：https://developer.github.com/v3/ HTTP协议HTTP 请求方法 请求方法 描述 HEAD 获取服务器的响应头信息 GET 请求指定的资源 POST 向指定资源提交数据，请求服务器进行处理 PATCH 与PUT请求类似，一般用于资源的部分更新 PUT 将指定资源的最新数据传送给服务器取代指定的资源 DELETE 用于删除所请求URI所标识的资源 请求/响应模型HTTP请求报文Request客户端向服务器发送一个HTTP请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。 HTTP1.0定义了三种请求方法：GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 HTTP响应报文Response服务器接收并处理客户端发过来的请求后会返回一个HTTP响应消息。 服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 工作原理 客户与服务器建立连接；建立连接-TCP三次握手 客户向服务器提出请求；发送请求信息 服务器接受请求，并根据请求返回相应的文件作为应答；发送响应信息 客户与服务器关闭连接。关闭连接 客户端浏览器解析HTML内容 URL：统一资源定位符URL是互联网上用来标识某一处资源的地址，一个完整的URL包括以下几部分： https://www.google.com/search?q=request&amp;source=lnms#imgrc=Lz-GAoSvIgYOlM 协议：https 域名：www.google.com 端口：位于域名后面，冒号连接 虚拟目录：从域名后的第一个“/”开始到最后一个“/”为止 文件名：从域名后的最后一个“/”开始到“？”为止；若没有“?”,则是到“#”为止；若没有“？”和“#”，则是到结束 锚：从“#”开始到最后 参数：从“？”开始到“#”为止之间的部分为参数部分，参数与参数之间用“&amp;”作为分隔符 REST API测试REST API测试用于测试 web 应用程序的 RESTful API，目的是通过发送各种 HTTP/S 请求来记录 REST API的响应，以检查 rest api 是否工作正常。主要包括 GET、 POST、 PUT 和 DELETE 方法。 协议分析工具抓包解包分析推荐使用tcpdump+ WireShark，参考 使用tshark命令解析tcpdump抓取的数据包 代理工具推荐： 手工测试 charles、安全测试 burpsuite 自动化测试：mitmproxy 其他代理：fiddler[仅windows]、 Any Proxy[全平台] 客户端模拟请求工具： curl：最常使用的http请求工具 postman：http协议测试工具 nc工具：tcp/udp协议发送，全名netcat，被誉为网络安全界的‘瑞士军刀’ --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>接口测试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>REST架构</tag>
        <tag>RPC协议</tag>
        <tag>SOAP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用tshark命令解析tcpdump抓取的数据包]]></title>
    <url>%2Fposts%2Fnetwork-tcpdump-and-wireshark%2F</url>
    <content type="text"><![CDATA[tshark是wireshark的命令行工具，通过shell命令抓取、解析报文。tcpdump是Linux系统下的抓包工具。wireshark和tcpdump都共同使用 libpcap作为其底层抓包的库，tshark也可以抓取报文。 有时候需要在linux系统或者ARM开发板中进行抓包，使用tcpdump抓包更加方便，在这种场景下，一般使用tcpdump进行抓包，然后在Windows中使用wireshark来分析生成的包文件，在自动化分析或者自动化测试中，可以使用tshark来进行包解析。本文介绍使用tcpdump抓取报文后使用tshark进行报文解析。 安装wireshark下载安装wireshark官网：https://www.wireshark.org/download.html 123# linuxyum -y install wiresharkyum -y install tcpdump 帮助信息1$ tcpdump -h查看可用端口：123456$ tcpdump -D1.ens332.ens373.veth2424bf44.any (Pseudo-device that captures on all interfaces)5.lo [Loopback] tcpdumptcpdump官方文档：https://www.tcpdump.org/index.html#documentation 常用参数 -i interface ：指定抓包接口，tcpdump -i eth1 -c count：抓取包个数，tcpdump -c 5 -i eth0 仅抓取5个包 -w file：保存 -A：ASCII码形式打印报文 -XX：HEX 和 ASCII形式显示报文 抓包抓取eth1网卡数据包，数据写入文件/tmp/packet.pcap1tcpdump -i eth1 -w /tmp/packet.pcap &gt;/dev/null 2&gt;&amp;1 &amp;其中 >/dev/null：将标准输出（控制台输出）重定向到/dev/null中，/dev/null代表 linux 的空设备文件。表示不输出内容 2&gt;&amp;1：重定向绑定，错误输出（2）和标准输出（1）输出到同一个地方 >/dev/null 2&gt;&amp;1的作用就是丢弃标准输出和错误输出，不会输出任何信息到控制台。 也可以只抓取特定协议的报文，比如过滤tcp报文：1tcpdump -i eth1 tcp抓取指定端口的报文1tcpdump -i eth1 port 22抓取指定源IP的报文1tcpdump -i src 192.168.0.1抓取指定目的IP的报文1tcpdump -i dst 192.168.0.1 停止抓包如果没有限制 tcpdump 抓包的数量（-c 参数），tcpdump 会持续抓包。可以通过 Ctrl+C 来停止抓包，或者杀掉tcpdump进程：1killall -9 tcpdump杀掉tcpdump进程后会停止抓包。 读取报文1234567$ tcpdump -r packet.pcapreading from file packet.pcap, link-type EN10MB (Ethernet)20:47:07.732570 IP 192.168.2.103.53074 &gt; 69.173.159.48.https: Flags [F.], seq 2534329882, ack 3470120544, win 1027, length 020:47:08.789990 IP 192.168.2.103.50544 &gt; tm-in-f188.1e100.net.https: Flags [.], seq 708023523:708023524, ack 4093529409, win 1027, length 120:47:09.037350 IP tm-in-f188.1e100.net.https &gt; 192.168.2.103.50544: Flags [.], ack 1, win 265, options [nop,nop,sack 1 &#123;0:1&#125;], length 020:47:09.195077 IP 192.168.2.103.50920 &gt; 118.178.135.232.https: Flags [P.], seq 1760992480:1760992516, ack 2403978898, win 1023, length 3620:47:09.222742 IP 118.178.135.232.https &gt; 192.168.2.103.50920: Flags [P.], seq 1:62, ack 36, win 1024, length 61 tshark抓包完成后对数据包进行解析，下面介绍使用tshark解析数据包。 tshark工具介绍tshark参考文档：https://www.wireshark.org/docs/man-pages/tshark.html 如果要在windows命令行窗口使用tshark需要将Wireshark安装路径 C:\Program Files\Wireshark 添加到环境变量。 查看帮助信息：1$ tshark -h列出可用网卡接口：1234567$ tshark -D1. \Device\NPF_&#123;4B48290B-6C8B-4A93-A942-A7E565B02F09&#125; (Npcap Loopback Adapter)2. \Device\NPF_&#123;D8F1F103-9733-422C-A521-77C678EEAFFC&#125; (WLAN)3. \Device\NPF_&#123;AB52B03B-45ED-43C9-B88F-C7499A78AED0&#125; (kc)4. \Device\NPF_&#123;64EA0097-AE33-49AD-9F42-959017C397FA&#125; (WAN)5. \Device\NPF_&#123;257F23D0-E615-4656-AB32-5338DB62843C&#125; (以太网 2)6. \Device\NPF_&#123;B5376652-68BB-45DA-A822-086E401773BB&#125; (本地连接* 10)前面提到过tcpdump -D也可以列出网卡信息，功能类似于Linux中的netstat -i 、ifconfig -a和ip link命令查看网卡接口信息。在windows中，除了在网络连接中查看网卡信息以外，也可以在命令行中通过如下命令查看： ipconfig (/all) wmic nic list brief Linux系统和windows系统tshark使用方法一样 tshark命令抓包常用参数： -i | --interface &lt;capture interface&gt; ：指定抓包接口 -f &lt;capture filter&gt;：抓包过滤，BPF(Berkeley Packet Filter)过滤规则，tcpdump和scapy(filter参数)都使用这个过滤规则，参考Python Scapy 报文构造和解析。 -w &lt;outfile&gt;：将数据包写入文件 -O &lt;protocols&gt;：打印数据包详细信息 -V：打印数据包详细视图 -P：写入文件过程中，打印数据包简略信息 -c &lt;capture packet count&gt;：设置抓取最大的包个数 -a|--autostop &lt;autostop condition&gt;：duration:5—5秒后停止抓包；files:2—写了2个文件后停止；filesize:100—包大小达到100KB后停止， tshark抓包示例：1234567891011121314151617181920212223242526$ tshark -i &quot;WLAN&quot; -f &quot;tcp port 80&quot; -w &quot;test.pcap&quot;$ tshark -i &quot;WLAN&quot; -f &quot;tcp port 80&quot; -w &quot;test.pcap&quot; -P -a duration:10Capturing on &#x27;WLAN&#x27;15 0.000000 08:ed:ed:3e:9e:f3 -&gt; Broadcast ARP 60 Who has 192.168.1.1? Tell 192.168.1.244 0.001051 fe80::4983:bddb:14e0:f9c4 -&gt; ff02::1:2 DHCPv6 157 Solicit XID: 0xd2726a CID: 00010001272da3902c534a01104e 0.065122 TendaTec_21:73:e1 -&gt; Broadcast ARP 60 Who has 192.168.1.1? Tell 192.168.1.126省略......$ capinfos test.pcapFile name: test.pcapFile type: Wireshark - pcapngFile encapsulation: EthernetPacket size limit: file hdr: (not set)Number of packets: 155File size: 29 kBData size: 23 kBCapture duration: 9 secondsStart time: Sun Apr 25 16:44:23 2021End time: Sun Apr 25 16:44:33 2021Data byte rate: 2595 bytes/sData bit rate: 20 kbpsAverage packet size: 153.96 bytesAverage packet rate: 16 packets/secSHA1: 2b4a555a362301156ff26a7f295b4d609dd97a33RIPEMD160: e34a63f4bcfe805d220f73dea78a8f4b63074a80MD5: cc560fd267886a596ed72397a73625e3Strict time order: True tshark解析数据包常用参数： -r：指定需要解析的数据包 -T：指定数据包解析输出格式，支持格式见解码所有数据，这里介绍 -T fields，一般与-e 选项连用。 -e：指定过滤的字段 -E：可用于指定分隔符：separator=,：默认分隔符为缩进（\t） -Y：过滤指定报文 12tshark [ -r &lt;infile&gt; ] -T fields [ -e &lt;field&gt; ] -E &lt;field print option&gt; -Y &lt;displaY filter&gt;tshark -r packet.pcap -T fields -e 解析的字段 -E separator=, 需要解析的字段可以通过Wireshark查看：选择要过滤的内容 -&gt; 右键 -&gt; Apply as Filter -&gt; Selected 例1：过滤具有源IP和目的IP字段的所有报文1tshark -r packet.pcap -T fields -e ip.src -e ip.dst 例2：过滤源地址为fe80::ca3a:35ff:fe09:efa1的报文，并读取UDP源端口号和IPv6目的地址。123456789$ tshark -r packet.pcap -T fields -E separator=, -Y ipv6.src==fe80::ca3a:35ff:fe09:efa1 -e udp.srcport -e ipv6.dst,ff02::2,ff02::2,ff02::16546,ff02::1:2546,ff02::1:2546,ff02::1:2546,ff02::1:2$ 注意：-Y参数中，多个条件用||，&amp;&amp;，and或者or连接，如果使用多个-Y参数，只有最后一个生效，下面过滤源地址为fe80::ca3a:35ff:fe09:efa1的DHCPv6 Solicit报文：12345678910111213$ tshark -r packet.pcap -T fields -E separator=, -Y dhcpv6.msgtype==1 -Y ipv6.src==fe80::ca3a:35ff:fe09:efa1 -e udp.srcport -e ipv6.dst,ff02::2,ff02::2,ff02::16546,ff02::1:2546,ff02::1:2546,ff02::1:2546,ff02::1:2$ tshark -r packet1.pcap -T fields -E separator=, -Y &quot;dhcpv6.msgtype==1 and ipv6.src==fe80::ca3a:35ff:fe09:efa1&quot; -e udp.srcport -e ipv6.dst546,ff02::1:2546,ff02::1:2546,ff02::1:2546,ff02::1:2 过滤完成后进行进一步的分析比如可以使用grep命令进一步提取满足条件的报文过滤源地址或者目的地址为192.168.5.38的报文1234# linuxtshark -r packet.pcap -T fields -e ip.src -e ip.dst | grep 192.168.5.38 # windowstshark -r packet.pcap -T fields -e ip.src -e ip.dst | findstr 192.168.5.38 也可以使用python、Java等高级语言进行进一步的分析，Python示例如下：12345result = os.popen(&quot;tshark -r packet.pcap -T fields -e ip.src -e ip.dst“)ret = result.read() # for i, value in enumerate(ret.split(&quot;\n&quot;)): # 处理value值 pass 解码所有数据某些字段可能无法使用tshark过滤，这种情况下，可以先将pcap文件解码，tshark支持如下文件格式：1ek|fields|json|jsonraw|pdml|ps|psml|tabs|text解码成xml和text格式文件：12tshark -r packet.pcap -V -T pdml &gt; packet.xmltshark -r packet.pcap -V -T text &gt; packet.txt -V：输出数据包详细信息 -T pdml：指定数据包解码输出格式为xml格式 xml文档可以使用python的ElementTree工具解析：1234try: import xml.etree.cElementTree as ETexcept ImportError: import xml.etree.ElementTree as ET 问题：windows tshark命令无效系统：windows10tshark已加入环境变量中输入tshark，显示：1234C:\Users\DELL&gt;tsharkThe NPF driver isn&#x27;t running. You may have trouble capturing orlisting interfaces.Capturing on &#x27;鏈湴杩炴帴* 9&#x27; WIreshark安装需要安装WinPcap，查看电脑已经安装了WinPcap。 接下来以管理员身份运行命令行串口，输入net start npf 启动NPF，出现如下报错信息：1234C:\WINDOWS\system32&gt;net start npf服务名无效。请键入 NET HELPMSG 2185 以获得更多的帮助。 卸载WinPcap10，下载安装winpcap4.1.3：https://www.winpcap.org/install/default.htm 重新输入net start npf 启动NPF：1234C:\WINDOWS\system32&gt;net start npf请求的服务已经启动。请键入 NET HELPMSG 2182 以获得更多的帮助。启动成功！tshark命令也可以正常使用了 --THE END--]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcpdump</tag>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cURL工具介绍及简单使用]]></title>
    <url>%2Fposts%2Fapi-test-curl-guide%2F</url>
    <content type="text"><![CDATA[curl命令是个功能强大的网络工具，可用来请求 Web 服务器，支持通过FTP、FTPS、HTTP、HTTPS、SMTP、Telnet、TFTP等协议，底层使用的是 libcurl 库。可用于文件上传、下载，还可以用来模拟客户端请求，抓取网页、网络监控等。本文介绍使用curl来发送请求。 curl安装Windows: 下载解压：https://curl.haxx.se/download.html 加入环境变量 curl -V 查看版本信息： Linux:12yum install curl # CentOS apt-get install curl # Ubuntu curl常见用法 get请求：curl url post请求：curl -d ‘xxx’ -X POST $url proxy使用：curl -x ‘http://127.0.0.1:8080‘ $url ：指定 HTTP 请求通过http://127.0.0.1:8080 代理发出。 其他参数用法： -H： “Content-type: application/json” 添加 HTTP 请求头 curl -H &#39;Content-type: application/json&#39; $url -G： 把data数据当成get请求的参数发送，用来构造 URL 的查询字符串，与—data-urlencode结合使用 -X：指定 HTTP 请求的方法 curl -X POST $url -d： 发送post请求数据，@file表示来自于文件 —data-urlencode：发送post请求数据，会对内容进行url编码 -u： username:password用户认证 -o： 写文件，将服务器的响应保存成文件 -v： verbose，打印更详细日志 -s： 关闭一些提示输出，不输出错误和进度信息。 -S：只输出错误信息 curl实例 请求 http://www.baidu.com， 将服务器的响应保存为html文件。 1curl -o /tmp/baidu.html http://www.baidu.com curl设置自定义 header 信息 1curl -H &#x27;Content-type: application/json&#x27; -H &#x27;Accept-Language:US&#x27; -H &#x27;Cookie:ID=1234&#x27; -v https://www.baidu.com/ copy as curl打开chrome浏览器的开发者工具： 12345678910111213curl &quot;https://clients5.google.com/pagead/drt/ne?di=^%^5B^%^2220140509-01^%^22^%^2C320^%^2C0^%^2C550^%^5D&quot; ^ -H &quot;authority: clients5.google.com&quot; ^ -H &quot;user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot; ^ -H &quot;x-requested-with: XMLHttpRequest&quot; ^ -H &quot;accept: */*&quot; ^ -H &quot;x-client-data: CK21yQEIjrbJAQijtskBCMS2yQEIqZ3KAQiWrMoBCJfCygEIrsLKAQisx8oBCPbHygEI98fKAQi0y8oBCKTNygEIos/KAQjc1coBCMKcywEIxZzLAQjVnMsBGOy4ygE=&quot; ^ -H &quot;sec-fetch-site: same-origin&quot; ^ -H &quot;sec-fetch-mode: cors&quot; ^ -H &quot;sec-fetch-dest: empty&quot; ^ -H &quot;referer: https://clients5.google.com/pagead/drt/dn/&quot; ^ -H &quot;accept-language: zh-CN,zh;q=0.9&quot; ^ -H &quot;cookie: CONSENT=YES+GB.zh-CN+V14+BX; HSID=ApIaHMWrytTvjqMEY; SSID=AygJZayBnP28BxFf8; APISID=UmyTkS9N9ChWmnBG/AiX66wI9xuFNodxDq; SAPISID=2RDZPon8mmYFUeFe/AH2H3UhsBS56EVzlz; __Secure-3PAPISID=2RDZPon8mmYFUeFe/AH2H3UhsBS56EVzlz; SID=3wecPbBT_8ICWEMZ5LIHO8U6mUJK2S89ijFYUnIkyW21xGDb-NBvF2GLkodON3gjyG3pTA.; __Secure-3PSID=3wecPbBT_8ICWEMZ5LIHO8U6mUJK2S89ijFYUnIkyW21xGDbqY5AvmtkqB83SkM4W5Afuw.; NID=204=FqAz385UbUYitAfQlLxpoWdqs1wFoatEH6GwJPuJ4Am0zybAYk_jUN1hCp7sSUxQ9g2XpEJ6pXByvz4z9p9V4dYnFhsSJ48mVJite-Zz1-vhgXewIS3NeK8_rnW6BT0X6dxcKDd5GiG6A3EdN7YuWZXCWVOi_QmARqfLrqzROWzk0u54chsvJOc0MQjKQX3eQUgNM9ATMFDgayrkUu95mRETP5XiqGkL--jPKV49482QfQFjL-oomZ7yzJpzax3h62uOkqP3m0k; 1P_JAR=2020-12-15-13; SIDCC=AJi4QfGElscF8CoJohJbugG-XFh1nPnYTmwvm-mnyMsiq0BVDeYqfb-JgqXBhoGNBTTjYv3hUw; __Secure-3PSIDCC=AJi4QfF2K4Rz5-Sl_Q6p9GM8H-h_4Q43LiFHs9mLuqsP1lYjpNoH7KTpTJDgAIApoafgbq8ZNtc&quot; ^ --compressed --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>接口测试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>cURL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman安装与使用]]></title>
    <url>%2Fposts%2Fapi-test-postman-guide%2F</url>
    <content type="text"><![CDATA[Postman是可以用于API调试的工具，支持各种请求类型： get、post、put、patch、delete 等，可以用来模拟HTTP请求，测试API接口功能。 安装官网地址：https://www.postman.com/ http请求响应测试接口：https://httpbin.testing-studio.com/也可以自己本地搭建，GitHub地址：https://github.com/postmanlabs/httpbin 发送请求发送Get请求 填写请求方式: Get 填写请求urL：https://httpbin.testing-studio.com/get 填写请求参数 发送Post请求Post请求可以发送key -value-,json,file等格式的数据案例: 请求 URL: https://httpbin.testing-studio.com/post 请求方式: Post URL可以通过设置环境变量来调用： 断言Tests主要用来做断言，可以测试返回结果是否含有某一字符串。123456789101112pm.test(&quot;Status code is 200&quot;, function () &#123; pm.response.to.have.status(200);&#125;);pm.test(&quot;Body matches string&quot;, function () &#123; pm.expect(pm.response.text()).to.include(&quot;json&quot;);&#125;);pm.test(&quot;url success&quot;, function () &#123; var jsonData = pm.response.json(); pm.expect(jsonData.url).to.eql(&quot;http://httpbin.testing-studio.com/post&quot;);&#125;); 测试结果： 变量 环境变量与全局变量 变量引用方法: 添加 Cookie Cookie可以用来鉴权 Postman可以自动保存 Cookie信息URL：https://httpbin.testing-studio.com/cookies/set 参数传递获取需要的值， 将获取到的值设置为环境变量，可以 在需要验证的接口中引用环境变量中保存的值 用例集 选择环境变量 选择执行次数 选择延迟时间 选择测试数据 点击Run按钮即可开始执行 代码导出 在接口页面点击code按钮进入code页面 选择需要导出的脚本 数据驱动json和 CSV格式数据文件：data.json1234567891011121314151617[ &#123; &quot;username&quot;:&quot;test1&quot;, &quot;password&quot;:&quot;123&quot;, &quot;token&quot;:&quot;token1&quot; &#125;, &#123; &quot;username&quot;:&quot;test2&quot;, &quot;password&quot;:&quot;123&quot;, &quot;token&quot;:&quot;token2&quot; &#125;, &#123; &quot;username&quot;:&quot;test3&quot;, &quot;password&quot;:&quot;123&quot;, &quot;token&quot;:&quot;token3&quot; &#125;]data.csv1234username,password,tokentest1,123,token1test2,123,token2test3,123,token3接口配置： 导入数据：运行： --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>接口测试</category>
      </categories>
      <tags>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Bash编程]]></title>
    <url>%2Fposts%2Flinux-shell-bash-programing%2F</url>
    <content type="text"><![CDATA[在《Linux系统介绍》中，介绍了shell的多个版本，现在的Linux发行版基本都默认使用bash（Bourne Again shell），兼容Bourne shell (sh)，本文将简要介绍Bash编程语法。 变量命名规则 只能使用英文字母，数字和下划线，首个字符不能以数字开头 中间不能有空格，可以使用下划线(_) 不能使用标点符号 不能使用bash里的关键字(可用help命令查看保留关键字)img 定义与使用变量定义变量12your_name=&quot;abc&quot;echo $your_name拼接字符串123your_name=&quot;world&quot;your_name2=&quot;hello,$your_name!&quot;echo $your_name2数组123array_name=(value0 value1 value2 value3)valuen=$&#123;array_name[n]&#125; # 数组取值array_name[0]=value0 # 赋值 数组实例：12345my_array=(A B &quot;C&quot; D)echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;my_array[1]=becho &quot;数组的元素为:$&#123;my_array[*]&#125;&quot; # 打印所有元素echo &quot;数组的元素为:$&#123;my_array[@]&#125;&quot;输出：123第一个元素为: A数组的元素为:A b C D数组的元素为:A b C D 只读变量12a=&quot;123&quot;readonly a 删除变量1unset variable_name #不能删除只读变量 不能删除只读变量1234567# b=10# readonly b# echo $b10# unset b-bash: unset: b: cannot unset: readonly variable# 环境变量显示所有环境变量123env# 或者printenv显示环境变量值123printenv LANG# 或者echo $LANG 控制语句条件分支：ifif定义1234567if conditionthen command1 command2 ... commandNfi if和then写在同一行时，用分号分隔。 12345if [ 2==2 ]; then echo &quot;true&quot;; else echo &quot;false&quot;; fi 判断条件写法123456# 写法一test expression# 写法二[ expression ]# 写法三[[ expression ]] 1234if test 2==2; then echo &quot;true&quot;; fiif [ 2&gt;1 ]; then echo &quot;true&quot;; fiif [[ 2&gt;1 ]]; then echo &quot;true&quot;; fi 实例比较两个变量的大小123456789a=10b=20if [ $a -eq $b ]; then echo&quot;equal&quot;; elif [ $a -lt $b ]; then echo &quot;small&quot;; elif [ $a -gt $b ]; then echo &quot;big&quot;; fi 循环：forfor定义1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 实例for和do写在同一行时，用分号分隔。123456789for Ioop in 1 2 3 4 5do echo &quot;hello&quot;donefor Ioop in 1 2 3 4 5;do echo &quot;hello&quot;done 循环读取文件内容并输出1for i in $(cat test.txt); do echo $i; done 循环: whilewhile定义1234while conditiondo commanddone 实例123456int=1while(( $int&lt;=5))do echo $int let &quot;int++&quot;done 循环读取文件内容并输出1while read line; do echo $line; done&lt;test.txt输出：12345test1test222test3test4test5 read命令 read命令是用于从终端或者文件中读取输入的内部命令 读取整行输入 每行末尾的换行符不被读入 read命令使用从标准输入读取输入并赋值给变量1read var从标准输入读取多个内容1read varl var2 var3不指定变量(默认赋值给 REPLY)1read 实例12345678910111213# read a123# echo $a123# read a b c1 2 3# echo $a 1# echo $b2# echo $c3# 默认变量12345# read456# echo $REPLY456# 注释123456# 注释# 多行注释:&lt;&lt;EOF内容.......EOF 脚本参数传递 $0 脚本名称 $1~$n 获取第n个参数： $# 传递到脚本的参数个数 $$ 脚本运行的当前进程ID号 $* 以一个单字符串显示所有向脚本传递的参数 $? 显示最后命令的退出状态。0表示没有错误,其他任何值表明有错误 vim param.sh：12345678#!/bin/bashecho &quot;脚本名称：$0&quot;echo &quot;脚本运行的当前进程ID号：$$&quot;echo &quot;参数个数：$#&quot;echo &quot;所有参数：$*&quot;echo &quot;第1个参数：$1&quot;echo &quot;第10个参数：$&#123;10&#125;&quot;echo &quot;return &quot;$?执行：12345678910# chmod +x param.sh# ./param.sh 1 2 3 4 5 6 7 8 9 10 1 脚本名称：./param2.sh脚本运行的当前进程ID号：21097参数个数：11所有参数：1 2 3 4 5 6 7 8 9 10 1第1个参数：1第10个参数：10return 0# 基本运算bash会把反引号里面当作一条命令来执行In: 1234# echo `date +%y/%m/%d` 20/12/27# echo `expr 2 + 2` 4 12345678910111213# a=10# b=20# echo expr $a + $b 30# echo $(($a+$b))30# echo expr $a - $b-10# echo expr $a \* $b200# echo expr $b / $a2# % 取余 = 赋值 a=$b 将把变量b的值赋给a == 相等 相同则返回true != 不相等 不相同则返回true 123456789# a=10# b=20# echo `expr $b % $a`0# echo $[$a == $b] 0# echo $[$a != $b] 1# -eq 检测相等 -ne 检测不相等 -gt 检测左边是否大于右边 -lt 检测左边是否小于右边 -ge 检测左边是否大于等于右边 -le 检测左边是否小于等于右边 1234567891011121314# vim test.sh # cat test.sh#!/bin/basha=10b=20if [ $a -lt $b ]then echo &quot;equal&quot;fi# chmod +x test.sh# ./test.shequal# 其它实例内存统计123456789#!/bin/bash# 内存使用百分比free | sed -n &#x27;2p&#x27; | gawk &#x27;x = int(( $3 / $2 ) * 100) &#123;print x&#125;&#x27; | sed &#x27;s/$/%/&#x27;# 统计内存for i in `ps aux | awk &#x27;&#123;print $6&#125;&#x27; | grep -v &#x27;RSS&#x27;`; do count=$[$count+$i]doneecho &quot;$count/kb&quot; 123# ./test.sh 16%474608/kb 求阶乘vim test.sh1234567read -p &quot;Enter a number:&quot;factorial=1for (( count=1; count&lt;=$REPLY; count++))do factorial=$[ $factorial * $count ]doneecho &quot;The factorial of $REPLY is $factorial&quot; 1234# chmod +x test.sh# ./test.sh Enter a number:6The factorial of 6 is 720 --THE END--]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux三剑客grep、awk和sed介绍]]></title>
    <url>%2Fposts%2Flinux-shell-programming-grep-sed-awk%2F</url>
    <content type="text"><![CDATA[grep，sed 和 awk是Linux/Unix 系统中常用的三个文本处理的命令行工具，称为文本处理三剑客。本文将简要介绍这三个命令并给出基本用法。 管道在介绍这两个命令之前，有必要介绍一下Unix/Linux中管道（pipe）的概念。管道将一个命令/程序/进程的输出发送到另一个命令/程序/进程，以进行进一步处理。是一种进程间通信机制，使用管道符”|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。 管道实现了数据在多个命令之间传递，不需要创建临时文件来传递，它是单向的，数据通过管道从左向右流动。 实例1：cat test.txt | grep test1 12345678$ cat test.txt | grep test1test1test111test3 test1test111$ cat test.txt | grep test1 | grep test3test3 test1$ 实例2：1234567891011$ cat test.txt | head -3test1test2test3$ cat test.txt | tail -5testtesttestrrrr$ grep定义grep(Global Regular Expression Print) 命令用于搜索文件的特定模式，它不能增加、修改、删除文本内容，通常用于搜索过滤文本，显示被模式匹配到的行。使用正则表达式进行文本匹配（正则表达式参考文章《Python正则表达式》），它的使用权限是所有用户。 命令形式：grep [OPTIONS] PATTERN [FILE...] 扩展正则表达式（egrep）添加 -E 参数：grep -E [OPTIONS] PATTERN [FILE...] -P参数可以让grep使用perl的正则表达式语法选项参数 -v 或 —invert-match ： 显示不被 pattern匹配到的行 -n 或 —line-number ： 显示匹配的行号 -o 或 —only-matching ：仅显示匹配到的字符串 -c 或 —count ： 统计匹配的行数 -i 或 —ignore-case ：忽略字符大小写 -m或—max-count：-m 1 : 匹配到1行后停止匹配 -A&lt;显示行数&gt; 或 —after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -B&lt;显示行数&gt; 或 —before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。 -C&lt;显示行数&gt; 或 —context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前和之后的内容。 or操作： grep &#39;pattern1\|pattern2&#39; grep -E &#39;pattern1|pattern2&#39; egrep &#39;pattern1|pattern2&#39; 实例1：查找文件内容，显示行号查找文件内容包含’test1’的行，显示行数123456789101112131415$ grep -n test1 test.txt 1:test17:test1119:test3 test111:test111$ grep -o test1 test.txt test1test1test1test1$ grep -no test1 test.txt1:test17:test19:test111:test1 实例2：查找文件内容，不包含test1的行12345678$ grep -nv test1 test.txt2:test23:test34:test45:test56:test68:test210:test 实例3：grep 正则表达式查找test1开头的行1234$ grep -n ^test1 test.txt1:test17:test11111:test111 查找以1结尾的行12345$ grep -n 1$ test.txt 1:test17:test1119:test3 test111:test111 实例4：判断或者提取数字提取文本中的数字12345678910111213141516$ cat test.txttest123456test66$ grep -Eo &#x27;[0-9]&#123;1,&#125;&#x27; test.txt12345666$ grep -o &#x27;[[:digit:]]*&#x27; &lt;&lt;&lt; cat test.txt12345666$ cat test.txt | grep -o &#x27;[[:digit:]]*&#x27;12345666打印全为数字的行：123456$ grep -Eo &#x27;^[0-9]&#123;1,&#125;*$&#x27; test.txt66$ grep -o &#x27;^[[:digit:]]*$&#x27; &lt;&lt;&lt; cat test.txt66$ cat test.txt | grep -o &#x27;^[[:digit:]]*$&#x27;66判断某个变量是否为数字：123$ num=&#x27;123&#x27;$ grep &#x27;^[[:digit:]]*$&#x27; &lt;&lt;&lt; $num123 查看进程123456$ ps -aux | grep chromeroot 5425 0.4 1.8 869280 34200 pts/0 Sl Dec22 11:31 /opt/google/chrome/chrome --no-sandboxroot 5439 0.0 0.0 563592 1132 pts/0 S Dec22 0:00 /opt/google/chrome/chrome --type=zygote --no-zygote-sandbox --no-sandboxroot 5440 0.0 0.1 563592 2836 pts/0 S Dec22 0:06 /opt/google/chrome/chrome --type=zygote --no-sandboxroot 5441 0.0 0.0 26452 208 pts/0 S Dec22 0:00 /opt/google/chrome/nacl_helper --no-sandboxroot 5442 0.0 0.0 26452 144 pts/0 S Dec22 0:00 /opt/google/chrome/nacl_helper --no-sandbox sed定义sed（Stream Editor）是一种流编辑器，一次处理一行内容，将行存储在模式空间（临时缓冲区），然后用sed命令处理模式空间中的内容，处理完成后将内容送入屏幕，然后清除模式空间，继续读入下一行，执行下一个循环，直到文件末尾。这个过程中不会改变文件内容（除了 -i 选项）。 命令形式：sed [选项] [sed命令] [-f &lt;script FILE&gt;] [FILE]查看帮助文档：12man sedsed -h 选项 -h： 显示帮助信息 -n： 仅显示 script处理后的结果，常与sed命令p连用：sed -n &#39;p&#39; test.txt 打印test.txt文件内容 -e：直接在指令列模式上进行 sed 的动作编辑，不修改原文件，输出到终端 -i：修改文件内容，而不输出到终端 -f filename ： sed 动作写在filename 内，执行 filename 内的sed 动作 -r∶扩展正规表达式 常用命令 a：append，新增： sed -e &#39;4 a newline&#39; test.txt c：change，取代： sed -e &#39;2,5c No 2-5 number&#39; test.txt d：delete，删除： sed -e &#39;2,5d&#39; test.txt sed -e &#39;/^$/d&#39; test.txt：删除test.txt文件空行 i：insert，插入： sed -e &#39;2i newline&#39; test.txt p：print，打印：sed -n &#39;p&#39; test.txt s：substitute，替换：sed -e &#39;s/old/new/g&#39; test.txt sed -e &#39;s/$/%/&#39; test.txt：在每行末尾添加% sed -e &#39;s/ *//g&#39; test.txt： 删除test.txt文件空格 sed -e &quot;4s;old;new;g&quot; test.txt 或者 sed -e &#39;4s/old/new/g&#39; test.txt：替换第4行 N：将下一行添加到pattern space中，将当前读入行和用N命令添加的下一行看成“一行” 注意： 在替换操作中，替换时用的分割符 ‘/‘ 可以使用其它符号代替，特别是替换的内容中有 ‘/‘ 时，可以使用@、#、%等符号代替。 grep和sed命令的正则表达式中不支持 \d ,可使用如下方式匹配数字： sed -re &#39;s/[0-9]+//g&#39; test.txt egrep &#39;[0-9]+&#39; test.txt 或 grep -E &#39;[0-9]+&#39; test.txt 实例1：打印并输出数据打印并输出第5行数据12345$ sed -n &#x27;5p&#x27; test.txttest5$ cat -n test.txt | sed -n &#x27;5p&#x27; 5 test5$ 打印并输出第3-5行数据1234$ sed -n &#x27;3,5p&#x27; test.txttest3test4test5取反，不选择第3到5行数据123$ sed -n &#x27;3,5!p&#x27; test.txttest1test2隔行输出12345678$ sed -n &#x27;1~2p&#x27; test.txttest1test3test5$ sed -n &#x27;1~3p&#x27; test.txttest1test4$ 实例2：将匹配的行数据输出到指定文件1234$ 累加sed -n &#x27;1~2p&#x27; test.txt &gt;&gt; a.log$ 覆盖sed -n &#x27;1~3p&#x27; test.txt &gt; a.log 12345678910$ sed -n &#x27;1~2p&#x27; test.txt&gt;&gt; a.log$ cat a.logtest1test3test5$ sed -n &#x27;1~3p&#x27; test.txt &gt; a.log $ cat a.logtest1test4$ 实例3：新增、插入字符串在第2行后加上 newLine12345678$ sed &#x27;2 a newline&#x27; test.txttest1test2newlinetest3test4test5$ 在第2行前加上 newline1234567$ sed &#x27;2 i newline&#x27; test.txttest1newlinetest2test3test4test5 实例4：全局替换将所有的test2替换为test222123456789101112$ sed -e &#x27;s/test2/test222/g&#x27; test.txttest1test222test3test4test5$ sed -e &#x27;s/test2/test222/&#x27; test.txttest1test222test3test4test5替换某一行：替换test1开头的所在行test2.txt内容：123456$ cat test2.txthello world !test1 test2 test2test1test2test3 1234567891011121314151617181920# 方法1：c参数，替换某一行$ sed &quot;2c hello&quot; test2.txthello world !hellotest1test2test3 $ sed &quot;3c hello&quot; test2.txthello world !test1 test2 test2hellotest2test3 # 方法2：s参数替换$ sed &#x27;s/^test1.*$/hello/&#x27; test2.txthello world !hellohellotest2test3 实例5：修改文件前面的新增、替换操作都没有改变文件内容，如果要使文件修改生效，需要使用 -i 选项。12345678$ sed -i &#x27;s/test2/test222/&#x27; test.txt$ cat test.txt test1test222test3test4test5$ 实例6：横向连接将匹配到的对象横向连接 比如我们需要杀掉某个服务有多个进程：123[root@Server ~]# ps -ef | grep named | grep -v greproot 7136 1 0 1月22 ? 00:00:54 /var/bin/named -c /var/named/named.confroot 7690 1 0 1月21 ? 00:01:02 /var/bin/named -c /var/named/named.conf使用命令 kill -9 7136 7690来杀掉这两个进程，使用如下命令实现连接这两个进程的ID：1kill -9 $(ps -ef | grep named | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;) | sed &#x27;:1;N;s/\n/ /g;t1&#x27;关键命令为 sed &#39;:1;N;s/\n/ /g;t1&#39;，将换行替换为空格。 awk定义awk是一种文本模式扫描和处理的编程语言，由 Aho, Weinberger 和 Kernighan开发。awk功能强大，可用于数据提取和统计，常用在shell脚本中。awk逐行读入文件，以空格为默认分隔符将每行切片，切开的部分再进行后续处理。 命令形式：awk [options] &#39;pattern action&#39; [FILE(s)] pattern：正则表达式 action：对匹配到的内容执行的命令(默认为输出每行内容) 常用参数 $0： 整条记录（当前行） $1 - $n： 表示当前行的第n个域 FILENAME： awk浏览的文件名 BEGIN： 处理文本之前要执行的操作 END： 处理文本之后要执行的操作 FS： 设置输入域分隔符，等价于命令行 -F 选项，默认为空格“ ” awk -F: &#39;&#123;print $1&#125;&#39; test.txt 或者 awk &#39;BEGIN &#123;FS = &quot;:&quot;&#125; &#123;print $1&#125;&#39; test.txt NF： 浏览记录的域的个数/列数 NR： 已读的记录数/行数 FNR： 当前输入文件的记录数 OFS： 输出域分隔符，默认为空格“ ” ORS： 输出记录分隔符，默认为“\n” RS： 控制记录分隔符 exit：匹配到第一行内容后退出：awk -F: &#39;&#123;print $2;exit&#125;&#39; test.txt ，grep使用 -m 参数 实例1：查找、打印搜索/etc/passwd有root关键字的所有行1234567$ awk -F : &#x27;/root/ &#123;print $0&#125;&#x27; /etc/passwdroot:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin$$ awk -F : &#x27;/root/ &#123;print $7&#125;&#x27; /etc/passwd/bin/bash/sbin/nologin打印etc/passwd/的第二行信息123$ awk -F : &#x27;NR==2 &#123;print $0&#125;&#x27; /etc/passwdbin:x:1:1:bin:/bin:/sbin/nologin$ 实例2：BEGIN、END制表使用 begin加入标题123456789101112131415$ awk -F : &#x27;BEGIN &#123;print &quot;No&quot;, &quot;User&quot;, &quot;Auth&quot;&#125; &#123;print NR &quot;|&quot; $1 &quot;|&quot; $2&#125; END &#123;print FILENAME&#125;&#x27; /etc/passwdNo User Auth1|root|x2|bin|x3|daemon|x4|adm|x5|lp|x6|sync|x7|shutdown|x8|halt|x9|mail|x.................28|nscd|x29|exim|x/etc/passwd 实例3：自定义分割符123456$ echo &quot;123|456|789&quot;123|456|789$ echo &quot;123|456|789&quot; | awk &#x27;BEGIN&#123;RS=&quot;|&quot;&#125;&#123;print $0&#125;&#x27;123456789 综合实例找出log中的404 500的报错有多少条1234567891011$ grep -E &#x27; 404 | 500 &#x27; nginx.log | wc -l267$ grep -P &#x27; 404 | 500 &#x27; nginx.log | wc -l267$ grep -Pc &#x27; 404 | 500 &#x27; nginx.log 267$ awk &#x27;$9~/404|500/&#x27; nginx.log | wc -l # &#123;print&#125;省略267$ awk &#x27;$9~/404|500/&#123;print&#125;&#x27; nginx.log | wc -l267 $9表示查找第9列 波浪号～表示用来匹配后面的正则表达式，告诉awk后面开始是正则语法。 wc -l ：和-c参数一样，统计匹配到的行数 访问量最高的ip使用awk命令查找123456789$ awk &#x27;&#123;print$1&#125;&#x27; nginx.log | sort | uniq -c | sort -nr | head -3 282 216.244.66.241 130 136.243.151.90 110 127.0.0.1$ awk &#x27;&#123;print$1&#125;&#x27; nginx.log | sort | uniq -c | sort -nr | head -3 | awk &#x27;&#123;print $2&#125;&#x27;216.244.66.241136.243.151.90127.0.0.1 sort命令用于排序： -r：sort默认为升序，-r参数表示降序 -n：以数值来排序，如果不使用这个参数就会出现10比2小的情况，因为把10当做字符来进行比较了。 uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用 -c：在每列旁边显示该行重复出现的次数 head命令用于查看文件的开头部分的内容 使用grep查找123456789101112131415161718192021$ grep &#x27;^[0-9]*.[0-9]*.[0-9]*.[0-9]*&#x27; nginx.log #其中的点“.”为正则语法，表示匹配任意字符123.127.112.18 - - [05/Dec/2018:00:09:18 +0000] &quot;GET /cable HTTP/1.1&quot; 101 1017 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&quot; 70.577 70.577 .139.180.132.174 - - [05/Dec/2018:00:09:20 +0000] &quot;GET /bbs.zip HTTP/1.1&quot; 404 1264 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot; 0.011 0.011 .139.180.132.174 - - [05/Dec/2018:00:09:12 +0000] &quot;GET /__zep__/js.zip HTTP/1.1&quot; 500 2183 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&quot; 0.018 0.018 .$ grep -o &#x27;^[0-9]*.[0-9]*.[0-9]*.[0-9]*&#x27; nginx.log216.244.66.241223.71.41.98113.87.161.17216.244.66.241216.244.66.241144.76.81.72............$ grep -o &#x27;^[0-9]*.[0-9]*.[0-9]*.[0-9]*&#x27; nginx.log | wc -l2000$ grep -o &#x27;^[0-9]*.[0-9]*.[0-9]*.[0-9]*&#x27; nginx.log | sort | uniq -c | sort -nr |head -3 282 216.244.66.241 130 136.243.151.90 110 127.0.0.1 ......................$ 将 topics 后面的数字替换成numer12$ grep &#x27;topics&#x27; nginx.log | sed &#x27;s#topics/[0-9]*#topics/number#g&#x27; 将ip地址横向打印12[root@centos7 tmp]# awk &#x27;&#123;print $1&#125;&#x27; nginx.log | sed &#x27;:1;N;s/\n/|/g;t1&#x27; 216.244.66.241|216.244.66.241|216.244.66.241|216.244.66.241|216.244.66.241|216.244.66.241|216.244.66.241|223.71.41.98|113.87.161.17|216.244.66.241|216.244.66.241|144.76.81.72 # :1 ：标记 t1 ;：把不同的命令分开 参考资料 正则表达式30分钟入门教程：https://deerchao.cn/tutorials/regex/regex.htm Python正则表达式 --THE END--]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux三剑客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python正则表达式]]></title>
    <url>%2Fposts%2Fregular-expression-and-python-regex%2F</url>
    <content type="text"><![CDATA[正则表达式（Regular expression）是组成搜索模式的一组字符序列，是记录文本规则的代码，用来检查文本中是否包含指定模式的字符串，通过定义一个规则来匹配字符串。正则表达式广泛应用于在字符串查找和处理中，大多文本编辑器基本都支持正则表达式查找。本文将简要介绍正则表达式语法，然后介绍Python语言中正则表达式使用方法。 正则表达式Unix之父Ken Tompson将正则表达式引入Unix，后面发展成了grep（Global Regular Expression Print）命令，由于grep不支持+、|与? ，且分组比较麻烦，AT&amp;T的Alfred Aho开发了egrep命令。随着Unix的版本不断演化，Unix中的程序（比如Linux三剑客中的awk、sed）所支持的正则表达式有差异，比较混乱。在1986年制定了POSIX（Portable Operating System Interface）标准，其中统一了正则表达式的语法。 POSIX标准把正则表达式分为两种：BRE（Basic Regular Expressions）和ERE（Extended Regular Expressions ）。BRE就是unix系统使用的grep命令，ERE对应egrep命令，是BRE的扩展。而linux系统使用的是GNU标准，linux发行版集成了GNU（Gnu’s Not Unix）套件，GNU在实现了POXIS标准的同时，做了一定的扩展。也包括GNU Basic Regular Expressions 和GNU Extends Regular Expressions。 正则表达式除了POSIX标准之外还有一个Perl分支，Perl与sed和awk兼容，后来演化成为PCRE（Perl Compatible Regular Expressions），是一个用C语言编写的正则表达式函数库，功能很强大，性能比POSIX正则表达式好。PCRE被引入了其他语言中，比如PHP, Tcl, Python, Ruby, C++, Java, R语言等等。 普通正则 代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 * 重复零次或更多次 扩展正则扩展正则：grep加 -E 参数 grep -E ‘ 404 | 500’ nginx.log 代码/语法 说明 + 重复一次或更多次 ？ 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 \ 表示或 零宽断言 语法 说明 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 正则表达式实例正则表达式在线测试工具： https://regex101.com/ http://c.runoob.com/front-end/854 https://tool.oschina.net/regex 1. 匹配以字母a开头的单词\ba\w*\b 2. 匹配刚好6个字符的单词\b\w&#123;6&#125;\b 3. 匹配1个或更多连续的数字\d+ 4. 5位到12位QQ号\d&#123;5,12&#125;^\d&#123;5,12&#125;$ 5. 匹配电话号码0\d&#123;2&#125;-\d&#123;8&#125; 6. 只匹配3位数字^\d&#123;3&#125;$ 7. 查找单词‘GET’\bGET\b ^GET$ 8. 查找‘Hello World’\bHello\b.*\bWorld\b Python正则表达式Python有一个内置正则表达式模块 re ，可以使用它来进行字符串操作：1import rere模块提供了以下4种方法： findall：返回所有匹配项 search：如果匹配到目标字符，返回一个匹配对象，用于判断是否存在目标字符串 split：分割 sub：替换 匹配数字、字母123text = &#x27;1&amp;\nbsp;hour(s) 2&amp;\nbsp;min 25&amp;\nbsp;s&#x27;re.findall(r&#x27;\d+&#x27;,text) # 匹配时间（数字）re.findall(r&#x27;\d+|(?&lt;=;)\w+&#x27;,text) # 匹配时间和单位 output:12[&#39;1&#39;, &#39;2&#39;, &#39;25&#39;][&#39;1&#39;, &#39;hour&#39;, &#39;2&#39;, &#39;min&#39;, &#39;25&#39;, &#39;s&#39;] 1re.findall(r&#x27;\d&#123;2&#125;+&#x27;,text) # 匹配2位数字 查找替换两个字符串之间内容替换字符target_text：123xpath_path = &#x27;//*[contains(text(),&quot;target_text&quot;)]/../td[5]/span&#x27; # xpath路径repl = &quot;需要替换成的字符串&quot;re.sub(r&quot;(?&lt;=\&quot;).*?(?=\&quot;)&quot;, repl, xpath_path) # 替换要查找的文本output:1&#39;&#x2F;&#x2F;*[contains(text(),&quot;需要替换成的字符串&quot;)]&#x2F;..&#x2F;td[5]&#x2F;span&#39; 添加千位分割符123number = &#x27;12345678&#x27; re.sub(r&quot;\B(?=(?:\d&#123;3&#125;)+(?!\d))&quot;, &quot;,&quot;,number) # 替换要查找的文本re.sub(r&quot;\B(?:(?:\d&#123;3&#125;)+(?!\d))&quot;, &quot;,&quot;,number) output:12&#39;12,345,678&#39;&#39;12,&#39;(?:\d&#123;3&#125;)+(?!\d): 查找3n(数字) + 非数字 组合 (?:exp) : 匹配exp,不捕获匹配的文本(非获取匹配)，也不给此分组分配组号，当执行了第一次匹配时，匹配到了行尾，直接将345678替换成了“,”。 参考文档 正则表达式30分钟入门教程：https://deerchao.cn/tutorials/regex/regex.htm github项目learn-regex：https://github.com/ziishaned/learn-regex https://www.w3schools.com/python/python_regex.asp --THE END--]]></content>
      <categories>
        <category>编程语言</category>
        <category>Linux</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令：性能命令]]></title>
    <url>%2Fposts%2Flinux-shell-performance-command-guide%2F</url>
    <content type="text"><![CDATA[本文介绍Linux常用性能统计分析命令，监控进程或者系统性能。主要包括CPU（top、mpstat）、内存（vmstat、free）、I/O（iostat）、网络性能（sar）、系统日志信息（demsg）、查看进程状态（pidstat）。下面简要介绍这些命令的使用方法。 mpstat、iostat、pidstat和sr命令需要安装sysstat软件包，sysstat包含了系统性能监测工具，安装方法如下：12yum install sysstat # CentOSsudo apt-get install sysstat # Ubuntu 负载CPU负载（cpu load）指的是某个时间点进程对系统产生的压力。表示特定时间间隔内运行队列中的平均进程数，如果一个进程满足以下条件则其就会位于运行队列中: 它没有在等待IO操作的结果 它没有主动进入等待状态(也就是没有调用’wait’) 没有被停止(例如：等待终止) 单CPU满负荷运行时cpu_load为1，当多个CPU或多核时，相当于大桥有多个车道，满负荷运行时cpu_load值为CPU数或多核数；CPU负载的计算（以单CPU为例），假设一分钟内执行10个任务代表满负荷，当一分钟给出30个任务时，CPU只能处理10个，剩余20个不能处理，cpu_load=3； 单核CPU cpu load = 1，满负载运行 cpu load = 0.5，半负载运行 cpu load = 1.7，超负载运行 一般来说，每个CPU内核当前活动进程数不大于3，则系统运行表现良好! 如果多核cpu，需要累加 4核cpu&lt;12uptimeuptime命令显示的平均负载包括了正在或准备运行在CPU上的进程和阻塞在不可中断睡眠状态(uninterruptible) I/O(通常是磁盘I/O)上的进程。1234[root@server ~]# uptime 16:54:53 up 29 days, 2:02, 1 user, load average: 0.03, 0.03, 0.00[root@server ~]# cat /proc/loadavg0.03 0.03 0.00 3/166 16903 显示最近1分钟、5分钟、15分钟系统负载的移动平均值，它们共同展现了负载随时间变动的情况。 3：正在运行的进程数，166：总的进程数，16903：最近运行进程的ID。 ps和top命令ps命令ps命令是Process Status的缩写，用于查看系统进程信息 -e，-A：显示所有进程，包括其他用户的进程 -f：显示完整格式 -l：显示长列表 -a：所有进程，加上-x参数会显示没有控制终端的进程 -u：username，显示指定用户的进程，例如ps -u root -x：显示当前用户在所有终端下的进程 -aux：显示所有进程，包括所有用户，分组情况 ps常用用法，通常与grep组合使用 显示dhcpd进程1ps ax | grep dhcpd | grep -v grep ps -ef显示所有进程 ps -aux显示所有进程 1ps -aux 按照CPU或者内存用量来筛选进程： 123ps -aux --sort -pcpu# 或ps -aux --sort -pmem 终止进程 1234567# 强制中断正在执行的命令，如，命令长时间没有响应的情况下Ctrl+C组合键# kill命令kill -9 进程ID# killall命令：终止指定名称的所有进程killall -9 dhclient top命令ps命令列出的是当前进程的快照，top可用于持续监视系统性能，动态显示进程信息。 -n 获取多次cpu的执行情况，top -n 4：只更新4次 -d 间隔时间，top -d 4：每隔4秒更新一次 -p 获取指定端口进程的数据，top -p 22 每隔1秒检测指定进程的cpu，检测20次 1top -d 1 -n 20 示例打印指定pid进程的cpu信息，间隔时间为1s，打印20次 查看进程的pid： 1ps -ef | grep systemd 循环打印 123456# 打印一次top -p 1 -n 1 | grep systemd | awk &#x27;&#123;print $10&#125;&#x27;# 循环打印20次for i in &#123;1..20&#125;;do top -p 1 -n 1 | grep systemd | awk &#x27;&#123;print $10&#125;&#x27;;sleep 1s;donefor((i=0;i&lt;20;i++));do top -p 1 -n 1 | grep systemd | awk &#x27;&#123;print $10&#125;&#x27;;sleep 1s;done dmesg | tail默认显示最新的10个系统信息，可以查看导致性能问题的错误信息。 1. 显示最新的20个系统信息12345678910111213141516171819202122[root@centos7 ~]# dmesg | tail -20[ 15.356358] RPC: Registered named UNIX socket transport module.[ 15.356360] RPC: Registered udp transport module.[ 15.356361] RPC: Registered tcp transport module.[ 15.356362] RPC: Registered tcp NFSv4.1 backchannel transport module.[ 15.551529] type=1305 audit(1584428235.986:4): audit_pid=1054 old=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:auditd_t:s0 res=1[ 19.223990] NET: Registered protocol family 40[ 23.857606] ip6_tables: (C) 2000-2006 Netfilter Core Team[ 24.130255] Ebtables v2.0 registered[ 24.366128] Netfilter messages via NETLINK v0.30.[ 24.418582] ip_set: protocol 7[ 24.517273] IPv6: ADDRCONF(NETDEV_UP): ens33: link is not ready[ 24.521156] e1000: ens33 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: None[ 24.524658] IPv6: ADDRCONF(NETDEV_UP): ens33: link is not ready[ 24.524669] IPv6: ADDRCONF(NETDEV_CHANGE): ens33: link becomes ready[ 24.528687] IPv6: ADDRCONF(NETDEV_UP): ens34: link is not ready[ 24.532350] e1000: ens34 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: None[ 24.535760] IPv6: ADDRCONF(NETDEV_UP): ens34: link is not ready[ 24.574912] IPv6: ADDRCONF(NETDEV_UP): ens34: link is not ready[ 25.391535] nf_conntrack version 0.5.0 (16384 buckets, 65536 max)[ 25.525351] IPv6: ADDRCONF(NETDEV_CHANGE): ens34: link becomes ready[root@centos7 ~]# 2. 显示开始的20个系统信息12345678910111213141516171819202122[root@centos7 ~]# dmesg | head -20[ 0.000000] Initializing cgroup subsys cpuset[ 0.000000] Initializing cgroup subsys cpu[ 0.000000] Initializing cgroup subsys cpuacct[ 0.000000] Linux version 3.10.0-1062.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) ) #1 SMP Wed Aug 7 18:08:02 UTC 2019[ 0.000000] Command line: BOOT_IMAGE=/vmlinuz-3.10.0-1062.el7.x86_64 root=UUID=d7dc0c9e-a27d-4239-aba4-7c2e51d9fc93 ro crashkernel=auto spectre_v2=retpoline rhgb quiet LANG=en_US.UTF-8[ 0.000000] Disabled fast string operations[ 0.000000] e820: BIOS-provided physical RAM map:[ 0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009ebff] usable[ 0.000000] BIOS-e820: [mem 0x000000000009ec00-0x000000000009ffff] reserved[ 0.000000] BIOS-e820: [mem 0x00000000000dc000-0x00000000000fffff] reserved[ 0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000007fedffff] usable[ 0.000000] BIOS-e820: [mem 0x000000007fee0000-0x000000007fefefff] ACPI data[ 0.000000] BIOS-e820: [mem 0x000000007feff000-0x000000007fefffff] ACPI NVS[ 0.000000] BIOS-e820: [mem 0x000000007ff00000-0x000000007fffffff] usable[ 0.000000] BIOS-e820: [mem 0x00000000f0000000-0x00000000f7ffffff] reserved[ 0.000000] BIOS-e820: [mem 0x00000000fec00000-0x00000000fec0ffff] reserved[ 0.000000] BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reserved[ 0.000000] BIOS-e820: [mem 0x00000000fffe0000-0x00000000ffffffff] reserved[ 0.000000] NX (Execute Disable) protection: active[ 0.000000] SMBIOS 2.7 present.[root@centos7 ~]# vmstat 1全称 virtual memory stat，逐行输出虚拟内存状态统计信息1234[root@centos7 ~]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r b swpd free buff cache si so bi bo in cs us sy id wa st1 0 0 1424832 2084 195100 0 0 47 4 45 55 0 0 99 1 0vmstat 1 ：每隔一秒打印一次1234567[root@centos7 ~]#[root@centos7 ~]# vmstat 1 #1s打印一个procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r b swpd free buff cache si so bi bo in cs us sy id wa st1 0 0 1424472 2084 195120 0 0 28 2 30 37 0 0 99 1 00 0 0 1424456 2084 195120 0 0 0 0 38 53 0 0 100 0 00 0 0 1424456 2084 参数解释： r: 运行队列中进程数量 b: 等待IO的进程数量 swpd：使用的虚拟内存 free：可用内存 buff：用作缓冲的内存大小 cache：用作缓存的内存大小 us：用户进程执行时间(user time) sy：系统进程执行时间(system time id：空闲时间(包括IO等待时间)，中央处理器的空闲时间 wa：等待IO时间 free -m查看linux内存使用情况1234[root@centos7 ~]# free -m total used free shared buff/cache availableMem: 1819 199 1471 9 148 1470Swap: 4095 0 4095 Mem：物理内存 totel：总的物理内存 单位为：M used：用掉的内存 free：空闲的物理内存 shared：共享内存 buff/cache：缓存内存 mpstat -P ALL 1mpstat是Multiprocessor Statistics的缩写，实时监控CPU性能。mpstat -P ALL 1 2：间隔1s打印报告，共打印2个 -P ALL：监控所有CPU 1：间隔时间1s 2：打印次数2次 12345678910111213[root@centos7 ~]# mpstatLinux 3.10.0-1062.el7.x86_64 (centos7) 03/18/2020 _x86_64_ (4 CPU)04:41:47 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle04:41:47 AM all 0.66 0.00 1.39 2.65 0.00 0.01 0.00 0.00 0.00 95.28[root@centos7 ~]#[root@centos7 ~]# mpstat -P ALL 1Linux 3.10.0-1062.el7.x86_64 (centos7) 03/18/2020 _x86_64_ (4 CPU)04:44:11 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle04:44:11 AM all 0.39 0.00 0.82 1.54 0.00 0.01 0.00 0.00 0.00 97.2404:44:11 [root@centos7 ~]# %usr：间隔时间段内，用户态的CPU时间（%），不包含 nice值为负进程 %nice：nice值为负进程的CPU时间（%） %sys：核心时间（%） %iowait：硬盘IO等待时间（%） %irq：硬中断时间（%） %soft：软中断时间（%） %steal：虚拟机管理器在服务另一个虚拟处理器时虚拟CPU处在非自愿等待下花费时间的百分比 %guest：运行虚拟处理器时CPU花费时间的百分比 %idle：CPU的空闲时间（%） pidstat 1pidstat用于监控全部或指定进程的资源占用情况，和top命令类似，但不覆盖输出，有利于观察数据随时间的变动情况，top会覆盖之前的输出 pidstat -p 1 1：-p 指定进程号，间隔1s打印pid为1的进程123456789[root@centos7 ~]# pidstatLinux 3.10.0-1062.el7.x86_64 (centos7) 03/18/2020 _x86_64_ (4 CPU)04:52:29 AM UID PID %usr %system %guest %CPU CPU Command04:52:29 AM 0 1 0.05 0.19 0.00 0.24 0 systemd04:52:29 AM 0 2 0.00 0.00 0.00 0.00 3 kthreadd04:52:29 AM 0 6 0.00 0.00 0.00 0.00 0 ksoftirqd/004:52:29 PID：进程ID %usr：进程在用户空间占用cpu的百分比 %system：进程在内核空间占用cpu的百分比 %guest：进程在虚拟机占用cpu的百分比 %CPU：进程占用cpu的百分比，各个CPU上的使用量的总和 CPU：处理进程的cpu编号 Command：当前进程对应的命令 iostat 1iostat用于显示CPU和块设备（磁盘I/O）相关的统计信息 12345678910[root@centos7 ~]# iostat 1Linux 3.10.0-1062.el7.x86_64 (centos7) 03/18/2020 _x86_64_ (4 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.15 0.00 0.34 0.60 0.00 98.92Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnsda 9.46 158.59 15.05 142895 13561scd0 0.02 1.14 0.00 1028 0 avg-cpu：总体cpu使用情况统计信息linux各种设备文件在/dev目录下可以看到 tps：每秒进程向磁盘设备下发的IO读、写请求数量 kB_read/s：每秒从驱动器读入的数据量 kB_wrtn/s：每秒从驱动器写入的数据量 kB read：读入数据总量 kB wrtn：写入数据总量 sar命令sar（System ActivityReporter）：系统活动情况报告，是Linux系统性能分析工具。可以用来分析磁盘I/O、CPU效率、内存使用等，下面介绍它的分析网络性能用法。 sar -n DEV 1检查网络流量的工作负载，可用来检查网络流量是否已经达到限额。1234567[root@centos7 dev]# sar -n DEV 1Linux 4.18.0-147.5.1.el8_1.x86_64 (iZ8vb54310gt89j8qct198Z) 12/19/2020 _x86_64_ (1 CPU)08:08:37 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil08:08:38 PM eth0 4.00 2.00 0.23 0.27 0.00 0.00 0.00 0.0008:08:38 PM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0008:08:38 PM docker0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 sar -n TCP 1显示TCP连接情况，可用来描述系统负载12345678[root@centos7 dev]# sar -n TCP,ETCP 1Linux 4.18.0-147.5.1.el8_1.x86_64 (iZ8vb54310gt89j8qct198Z) 12/19/2020 _x86_64_ (1 CPU)08:15:48 PM active/s passive/s iseg/s oseg/s08:15:49 PM 0.00 0.00 1.00 1.0008:15:48 PM atmptf/s estres/s retrans/s isegerr/s orsts/s08:15:49 PM 0.00 0.00 0.00 0.00 0.00 active/s：主动连接数，本地每秒创建的TCP连接数 passive/s：被动连接数，远程每秒创建的TCP连接数 retrans/s：每秒TCP重传次数 --THE END--]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[克隆虚拟机后设置静态IP无效的解决方法]]></title>
    <url>%2Fposts%2Fstatic-ip-set-in-virtual-machine-cloning%2F</url>
    <content type="text"><![CDATA[克隆虚拟机后设置静态IP无效的解决方法 1. 获取虚拟机网卡的MAC地址通过下面的其中一个命令获取要设置的网卡MAC地址123ip link showifconfig -aip address show 2. 修改70-persistent-ipoib.rules 文件将eth0的MAC地址改为第一步获取到的地址1vim /etc/udev/rules.d/70-persistent-ipoib.rules 3. 修改网卡配置文件将对于网卡配置文件的MAC地址也改为第一步获取到的地址1vim /etc/sysconfig/network-scripts/ifcfg-eth0 4. 重启重启网络服务1systemctl restart network --THE END--]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机克隆</tag>
        <tag>网卡配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令：网络命令]]></title>
    <url>%2Fposts%2Flinux-shell-networking-management-guide%2F</url>
    <content type="text"><![CDATA[本文简要介绍Linux网络配置命令，包括 ip 地址、路由查看、配置等 pingping: 测试网络连接情况 -c：回应的次数 -i：每次ping的时间间隔 -I：网卡名 -t：ttl 数值 -s：数据包的大小 1234# ping ipv6地址ping -6 -I eth1 2001:db8::10# ping ipv4地址ping -I eth1 192.168.0.1 网络信息查询netstatnetstat: 打印 Linux网络系统的状态信息 -t 列出所有tcp -u 列出所有udp -l 只显示监听端口 -n 以数字形式显示地址和端口号 -p 显示进程的pid和名字123456789101112131415161718192021netstat -tnetstat -ntlp# 列出所有网络端口信息netstat -a # 列出所有tcp连接信息netstat -at # 列出所有udp连接信息netstat -au # 所有端口数据包统计信息 netstat -s# 显示核心路由信息 netstat -r# 或route -nroute print # windows# 显示网络接口列表netstat -i# 显示网络接口详细信息netstat -ie# 或ifconfig 列出所有网卡信息1234567# 查看所有网卡信息ifconfig -aip linknetstat -i# 查看某一个网卡ifconfig 网卡名字 路由配置12345678# ipv4route add/del -net 192.168.0.0/24 netmask 255.255.255.0 gw 192.168.0.1route add/del -host 192.168.1.1 dev eth1route add -net 23.23.23.0 netmask 255.255.255.0 reject # 屏蔽一条路由route add/del default gw 192.168.0.1 #增加/删除默认网关# ipv6ip -6 route add default via fe80::290:4cff:fe88:8888 dev eth1 # 配置默认网关ip -6 route add 2001:db8:3333::/64 via fe80::ca3a:35ff:fe09:efa1 dev eth1 # 添加目的网络为2001:db8:3333::/64，下一跳网关为fe80::ca3a:35ff:fe09:efa1的静态路由 查看路由表1234route -nroute -4 -nroute -6 -nip -6 route show default # 查看默认路由网关 禁用启用网卡12ifconfig eth1 upifconfig eth1 down 释放、更新地址123456# ipv4dhclient -r eth1dhclient -v eth1# ipv6dhclient -6 -r eth1 //释放ipv6地址 dhclient -6 //重新获取ipv6地址 重启网络：1systemctl restart network 添加、删除IP地址123456789101112# 添加IPv4地址ifconfig eth1 192.168.1.200 netmask 255.255.255.0ip addr add 192.168.1.200/24 dev eth1# 添加IPv6地址ip -6 addr add 2001:db8:1111::20 dev eth1# 删除IPv6地址ip -6 addr del 2001:db8:1111::20 dev eth1ip addr del 192.168.1.200/24 dev eth1# 激活/禁用设备ifconfig eth0 upifconfig eth0 down 修改MAC地址1ifconfig eth1 hw ether MAC地址 up 设置MTU值1ifconfig eth1 mtu 1500 up 配置arp信息12345678# arp缓存arp -a# 删除arparp -d IP# 添加arparp -s IP MAC 设置无线网络12345678910111213141516171819# 安装sudo apt install wireless-tools# 开启无线网卡wlan0ifconfig wlan0 up# 设置密码iwconfig wlan0 key 12345678# 设置SSIDiwconfig wlan0 essid &quot;test&quot;# 加入无线网iwconfig wlan0 ap auto# 查看网卡信息iwconfig wlan0# 为无线网卡指定IP地址ifconfig wlan0 192.168.1.30 netmask 255.255.255.0 # 用dhclient或dhcpcd获取ipdhclient wlan0# 或dhcpcd wlan0 iwconfig 的弊端是只支持WEP认证方式，要想支持WPA，需要wpa_supplicant工具，wpa_supplicant支持4种认证方式：OPEN，WEP，WPA，WPA2 --THE END--]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令：文件操作命令]]></title>
    <url>%2Fposts%2Flinux-shell-file-command-guide%2F</url>
    <content type="text"><![CDATA[Linux系统命令主要包括文件操作、网络命令和性能命令，本文介绍常用文件操作命令。 文件属性文件类型： 普通文件：- 目录文件：d 块设备文件：b，硬盘 字符设备： c，串行端口的接口设备，例如键盘、鼠标 链接文件：l 套接字文件：s 管道文件：p r 读权限read 4w 写权限 write 2x 操作权限 execute 1 常用命令： chmod 777 test，修改test文件属性为可读，可写，可执行（4+2+1=7） ls -l 查看文件属性（或者使用ll） ls -ld 查看当前目录的属性 ls -l 长模式，属性信息 ls -1 把文件一行一个的显示出来 ls -a 显示所有文件 ls -s 显示文件及文件大小 ls -l -a -s —&gt; ls -las ls -sh (h-human，显示文件大小单位） 基本终端操作命令ls: 列出目录文件pwd: 显示目前的目录cd: 切换目录 cd - ：切换到上次目录 cd .. ：切换到上级目录 cd / ：切换到根目录 cd ~ ：切换到当前用户的home目录 cd start*end ：目录名较长时可使用通配符”*“，比如进入system目录，可以使用 cd s*m man命令：可以通过 man + 命令 查看帮助文档： j：下翻 k：上翻 空格键：翻页 q：退出 /-e：查找“-e” n 下一个“-e” N（shift+n） 上一个“-e” 123456789101112131415161718192021222324[root@client ~]# lsdesktop.ini jenkins test.log test.txt t.txt[root@client ~]# cd j*s[root@client jenkins]# pwd /root/jenkins[root@client jenkins]# cd -/root[root@client ~]# pwd/root[root@client ~]# cd jenkins/[root@client jenkins]# pwd/root/jenkins[root@client jenkins]# cd ..[root@client ~]# pwd/root[root@client ~]# /root[root@client ~]# cd /[root@client /]# pwd/[root@client /]# cd ~[root@client ~]# pwd/root[root@client ~]# 文件、目录操作touch：新建文件，或者使用vim命令创建文件：vim test.txt，保存mkdir: 创建一个新的目录rmdir: 删除一个空的目录cp: 复制文件或目录rm: 移除文件或目录mv: 移动文件与目录，或修改文件与目录的名称 123456789101112# 将目录A复制到目录B下cp -r /etc/A /etc/B# 将目录A的内容复制到目录B下cp -r /etc/A/* /etc/Bcp -r /etc/A/. /etc/B# 删除目录A及其下面的所有文件rm -r /etc/Arm -rf /etc/A #强制删除# 移动目录A到目录B下mv /etc/A /etc/B# 移动目录A下的所有文件到目录B下mv /etc/A/* /etc/B 文件内容显示cat：显示文件内容，还可以将多个文件连接起来显示，适用于内容少的文件more：以一页一页的显示内容，空格键下一页less：支持向前翻，向后翻页head：打印前面n行内容：head -2 test.txttail：打印后面n行内容：tail -2 test.txt 向文件添加内容将内容”TEST”添加到test.txt文件中 方法一：vi编辑法 打开终端，输入vi test.txt 回车，按a或i进入编辑模式输入 TEST，然后按esc键退出编辑模式，输入 :wq 保存并退出。 方法二：echo命令法 1234# 追加echo ‘TEST’ &gt;&gt; ./test.txt# 覆盖echo ‘TEST’ &gt; ./test.txt方法三：cat命令法 1cat &gt;&gt; ./test.txt &lt;&lt;TEST结尾的TEST要顶格。 方法四：cat编辑法 1cat &gt;&gt; ./test.txt 回车后开始编辑输入内容：TEST 按ctrl+d组合键结束编辑。 find命令用于查找文件，基本用法：find path -name‘xxx&#39;find / -name jenkins：查找所有目录下的jenkins文件123456[root@client ~]# find / -name jenkins/root/jenkins/var/lib/docker/overlay2/6cc1d9dcc70fed5dcc455ca4147a13f650724c2e8004a9c101b4e2130276241c/diff/usr/share/jenkins/var/lib/docker/overlay2/9b98446d8cf91c4c8da9d8eab5cd6366ef2cec266615c1fe6ad4f4faa84f25a1/diff/usr/share/jenkins/var/lib/docker/overlay2/f1f4123687b215d1eff46d989df6c9568be89c231a83ab6105dc22c136ccf24b/diff/usr/share/jenkins[root@iZ8vb54310gt89j8qct198Z ~]# 限制搜索深度 -maxdepth -mindefth 限制文件类型：文件类型有：普通文件f，目录d，符号链接 l，字符设备c，块设备b，套接字s，FIFO-p -type f：搜索普通文件和目录还有其他限制条件，可以通过命令 man find 查看 文件解压1tar -xvzf xxx.tar.gz --THE END--]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统介绍]]></title>
    <url>%2Fposts%2Flinux-kernel-and-shell-introduce%2F</url>
    <content type="text"><![CDATA[Linux系统主要包括3层， 硬件（RAM、CPU、I/O设备等）、 Linux 内核和 用户进程。Linux 内核最初由芬兰黑客 Linus Torvalds 开发，Linux内核是Linux操作系统的重要组成部分，是操作系统的核心，是系统硬件和进程之间的接口。内核提供内存管理、进程管理、设备驱动和各种系统调用。 Linux内核版本Linux各个内核版本可以在https://www.kernel.org/ 上下载，一些社区组织或厂商将Linux内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。Linux有多个发行版本，常见的Linux系统有Centos和Ubuntu。 查看系统版本12cat /proc/versionuname -a 1234[root@iZ8vb54310gt89j8qct198Z ~]# cat /proc/versionLinux version 4.18.0-147.5.1.el8_1.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 8.3.1 20190507 (Red Hat 8.3.1-4) (GCC)) #1 SMP Wed Feb 5 02:00:39 UTC 2020[root@iZ8vb54310gt89j8qct198Z ~]# uname -aLinux iZ8vb54310gt89j8qct198Z 4.18.0-147.5.1.el8_1.x86_64 #1 SMP Wed Feb 5 02:00:39 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 4.18.0-147.5.1.el8_1.x86_64 : 4：内核主版本号 18：内核次版本号，偶数代表稳定版；奇数代表开发版 0：内核修订版本号，添加安全补丁，bug修复，新功能或驱动程序等 147.5.1：发行版本的补丁版本 el8_1：使用的内核是 RedHat / CentOS 系列发行版专用内核 x86_64：x86平台64位CPU 查看centos发行版本：12[root@iZ8vb54310gt89j8qct198Z ~]# cat /etc/redhat-release CentOS Linux release 8.1.1911 (Core) shell常见 shellShell 是一种脚本编程语言，连接内核和用户。常见的 Shell 有 sh、bash、ksh、csh等。 Bourne Shell (/usr/bin/sh或/bin/sh) Bourne Again Shell (/bin/bash)：兼容 sh C Shell (/usr/bin/csh) K Shell (/usr/bin/ksh) Shell for Root (/sbin/sh) cat /etc/shells 命令查看系统可用shell:123456[root@client ~]# cat /etc/shells/bin/sh/bin/bash/usr/bin/sh/usr/bin/bash[root@client ~]# 运行 shell 使脚本具有执行权限12chmod +x ./test.sh chmod 777 ./test.sh 执行脚本12./test.sh # 执行脚本/bin/sh test.sh 查看Linux系统信息查看系统位数 getconf LONG_BIT file /bin/ls 12345[root@iZ8vb54310gt89j8qct198Z ~]# getconf LONG_BIT64[root@iZ8vb54310gt89j8qct198Z ~]# file /bin/ls/bin/ls: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=937708964f0f7e3673465d7749d6cf6a2601dea2, stripped, too many notes (256)[root@iZ8vb54310gt89j8qct198Z ~]# 查看内存信息Linux 查看内存支持的最大内存容量1dmidecode|grep -P &#x27;Maximum\s+Capacity&#x27; 查看槽位上内存的速率，没插就是unknown。1dmidecode|grep -A16 &quot;Memory Device&quot;|grep &#x27;Speed&#x27; 查看内存条厂家1dmidecode -t memory | grep Manufacturer 查看内存信息（显示插槽个数和每个插槽里内存条的大小）1dmidecode -t memory | grep Size Linux软件包管理Linux软件安装可以直接通过源码编译安装，一般源码包都打包成tar.gz压缩格式。源码包安装比较麻烦，容易出错，也可以使用包管理来软件包的管理，包管理工具是对软件工具的安装、卸载及其他管理， 常见的两类软件包管理工具是RPM 和 DPKG，RPM是Red Hat软件包管理器，DPKG的是Debian的Linux系列基本的包管理系统。 源码编译安装源码编译安装步骤： 下载安装文件 解压1tar -xvzf xxx.tar.gz 检查编译进入解压文件内1./configure 检查通过后，将生成用于编译的MakeFile文件。 编译1make 安装1make install 安装完毕，应清除编译过程中产生的临时文件和配置过程中产生的文件。12make cleanmake distclean如果要卸载，则执行1make uninstall RPMRPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，rpm包文件通常以.rpm结尾。 RPM包安装下载rpm包后安装：安装 RPM 包1rpm -ivh package.rpm 升级 RPM 包1rpm -Uvh package.rpm 卸载 RPM 包1rpm -ev package yumrpm无法解决软件包与软件包之间的依赖问题，可以使用yum工具进行在线安装，yum（Yellowdog update Modifier）是RPM前端工具，操作对象为rpm包。由于网络问题，可以设置yum国内镜像源，也可以配置本地源。下面介绍yum安装方法：搜索可用软件包：1yum search all 软件关键字搜索已安装的软件：1yum list installed | grep 软件关键字 安装12yum install package-nameyum -y install package-name #接受所有互动问答卸载12yum remove package-nameyum -y remove package-name DPKGDPKG全称为 Debian Package，功能与 RPM 相似，包文件通常以 .deb 扩展名结尾。Ubuntu系统使用此包管理工具。 DPKG 命令安装安装 DEB 包1dpkg -i package.deb升级 DEB 包1dpkg -i package.deb ( 和安装命令相同）卸载 DEB 包12dpkg -r package.deb # 不卸载配置文件dpkg -P package.deb # 卸载配置文件 aptapt 全称 Advanced Packaging Tools，DPKG 前端工具， apt 的主要包管理工具为apt-get，实现功能和yum类似。 搜索可用软件包1apt-cache search 软件关键字安装1apt-get install package-name下载指定软件的源文件1apt-get source package-name更新123apt-get upgrade # 更新软件apt-get update # 更新软件列表apt-get dist-upgrade # 更新所有软件卸载12apt-get remove package-name 查看历史命令history在Linux命令窗口可以查看执行过的历史命令，可以通过上/下方向键（或者Ctrl+ p / Ctrl+ n）显示相对于当前命令的上一条或下一条历史记录。或者通过Ctrl+ r 来搜索历史命令。 还有一种更为直观的方法是使用history命令，可以显示多个记录，默认情况下，历史命令存放在 ~/.bash_history 文件里面，也可以在/etc/bashrc中设置历史命令存放路径，添加：export HISTFILE=存放路径 history命令格式如下：1history [-c] [-d offset] [n] -c：清空历史命令 -d offset：删除历史命令中第offset个命令 n：显示最近的n条历史命令 显示最近的5个命令：1234567[root@server ~]# history 5 996 cat /etc/bashrc 997 vim /etc/bashrc 998 history --help 999 echo $HISTSIZE 1000 history 5[root@server ~]# --THE END--]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App自动化测试 | AppCrawler自动遍历测试]]></title>
    <url>%2Fposts%2Fappium-automatic-traversal-test-appcrawler%2F</url>
    <content type="text"><![CDATA[AppCrawler 是由 seveniruby开源的一个自动遍历测试工具，谷歌有一个叫App Crawler 的遍历工具。AppCrawler具有很大的灵活性，可以自由控制测试页面，控件类型，测试深度等，且支持Android和IOS应用测试。AppCrawler开源地址：https://github.com/seveniruby/AppCrawler appcrawler基于appium开发，底层引擎还引用了 adb、 macaca、 selenium AppCrawler安装AppCrawler工具以jar包方式发布，下载地址：https://pan.baidu.com/s/1dE0JDCH appcrawler 2.4.0 java8 appium 1.8.x AppCrawler运行 启动 appium server 启动模拟器或者连接真机 开始自动遍历 appcrawler —capability “appPackage=com.xueqiu.android,appActivity=.view.WelcomeActivity Alias” 使用AppCrawler前需要启动appium server，然后启动模拟器或者连接真机。运行 java -jar appcrawler.jar 查看帮助。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152D:\testing_tools\appcrawler&gt;java -jar appcrawler-2.4.0-jar-with-dependencies.jar----------------AppCrawler 2.4.0 [霍格沃兹测试学院特别纪念版]Appium 1.8.1 Java8 testedapp爬虫, 用于自动遍历测试. 支持Android和iOS, 支持真机和模拟器项目地址: https://github.com/seveniruby/AppCrawler移动测试技术交流: https://testerhome.com联络作者: seveniruby@testerhome.com (思寒)致谢: 晓光 泉龙 杨榕 恒温 mikezhou yaming116 沐木--------------------------------Usage: appcrawler [options] -a, --app &lt;value&gt; Android或者iOS的文件地址, 可以是网络地址, 赋值给appium的app选项 -e, --encoding &lt;value&gt; set encoding, such as UTF-8 GBK -c, --conf &lt;value&gt; 配置文件地址 -p, --platform &lt;value&gt; 平台类型android或者ios, 默认会根据app后缀名自动判断 -t, --maxTime &lt;value&gt; 最大运行时间. 单位为秒. 超过此值会退出. 默认最长运行3个小时 -u, --appium &lt;value&gt; appium的url地址 -o, --output &lt;value&gt; 遍历结果的保存目录. 里面会存放遍历生成的截图, 思维导图和日志 --capability k1=v1,k2=v2... appium capability选项, 这个参数会覆盖-c指定的配置模板参数, 用于在模板配置之上的参数微调 -r, --report &lt;value&gt; 输出html和xml报告 --template &lt;value&gt; 输出代码模板 --master &lt;value&gt; master的diff.yml文件地址 --candidate &lt;value&gt; candidate环境的diff.yml文件 --diff 执行diff对比 -vv, --verbose 是否展示更多debug信息 --demo 生成demo配置文件学习使用方法 --help示例appcrawler -a xueqiu.apkappcrawler -a xueqiu.apk --capability noReset=trueappcrawler -c conf/xueqiu.json -p android -o result/appcrawler -c xueqiu.json --capability udid=[你的udid] -a Snowball.appappcrawler -c xueqiu.json -a Snowball.app -u 4730appcrawler -c xueqiu.json -a Snowball.app -u http://127.0.0.1:4730/wd/hub#生成demo例子appcrawler --demo#启动已经安装过的appappcrawler --capability &quot;appPackage=com.xueqiu.android,appActivity=.view.WelcomeActivityAlias&quot;#从已经结束的结果中重新生成报告appcrawler --report result/#新老版本对比appcrawler --candidate result/ --master pre/ --report ./ 生成样板配置示例运行 java -jar appcrawler.jar --demo 会在当前目录下生成一个demo.yml文件。 通过编辑demo.yml文件实现app自动遍历的灵活定制。 123456789101112131415161718D:\testing_tools\appcrawler&gt;java -jar appcrawler-2.4.0-jar-with-dependencies.jar --demo2020-11-18 20:47:04 INFO [AppCrawler$.86.main]----------------AppCrawler 2.4.0 [霍格沃兹测试学院特别纪念版]Appium 1.8.1 Java8 testedapp爬虫, 用于自动遍历测试. 支持Android和iOS, 支持真机和模拟器项目地址: https://github.com/seveniruby/AppCrawler移动测试技术交流: https://testerhome.com联络作者: seveniruby@testerhome.com (思寒)致谢: 晓光 泉龙 杨榕 恒温 mikezhou yaming116 沐木--------------------------------2020-11-18 20:47:05 INFO [AppCrawler$.223.parseParams] use default appium address 47232020-11-18 20:47:05 INFO [AppCrawler$.230.parseParams] appium address = Some(http://127.0.0.1:4723/wd/hub)2020-11-18 20:47:05 INFO [AppCrawler$.242.parseParams] result directory = 202011182047012020-11-18 20:47:07 INFO [AppCrawler$.286.parseParams] you can read D:\testing_tools\appcrawler\demo.yml for demo 执行参数与配置文件 capability设置：与 appium完全一致 1234567appPackage: &quot;com. xueqiu.android&quot;appActivity: &quot;.view.WelcomeActivityAlias&quot;app:appium: &quot;http: //127.0.0.1:4723/wd/hub&quot;noReset: trueautomationName: uiautomator2dontStopAppOnReset: true testcase：用于启动app后的基础测试用例 selectedList：设定遍历范围 triggerActions：特定条件触发执行动作 执行参数比配置文件优先级别高 1java -jar &lt;appcrawler.jar路径&gt; -c example.yml --capability appPackage=com.xueqiu.android,appActivity=.view.WelcomeActivityAlias -o /tmp/xueqiu/ testcase testcase的完整形态 given：所有的先决条件 when：先决条件成立后的行为 then：断言集合 testcase的简写形态 xpath：对应when里的 xpath action：对应when的 action action back 后退 backApp 回退到当前的app默认等价于back行为 可定制 monkey 随机事件 xxx()执行代码 Thread.sleep(3000) driver.swipe(0.9, 0.5,0.1,0.5) click longTap 自动遍历定制 selectedList：需要被遍历的元素范围 firstList：优先被点击 lastList：最后被点击 tagLimitMax：同祖先(同类型)的元素最多点击多少次 backButton：当所有元素都被点击后默认后退控件定位 blackList：黑名单 maxDepth：遍历的最大深度 触发器triggerActions: 动作触发特定次数 通常用于处理弹框：关闭弹框 xpath：指定具体按钮 action：动作 times：规则的使用次数 自动遍历测试过程 信息的获取: 把当前app的界面dump为xml结构 获取待遍历元素 遍历范围 selectedList 过滤黑名单 小控件 不可见控件 blackList 重排控件顺序 firstList lastList 跳过已点击+跳过限制点击的控件tagLimit 根据匹配的规则执行 action 循环上面的步骤 网页报告1java -jar appcrawler-2.4.0-jar-with-dependencies.jar -c demo1.yml 自动遍历执行完成后，当前目录会生成测试报告index.html打开index.html文件]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>AppCrawler</tag>
        <tag>自动遍历测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议架构介绍（二）：网络层]]></title>
    <url>%2Fposts%2Ftcp-ip-protocol-architecture-model%20_internet-layer%2F</url>
    <content type="text"><![CDATA[网络层负责寻址和路由，还可以实现拥塞控制、网际互连等功能。数据的单位称为数据包（packet）-分组。 分组指IP数据报既可以是一个IP数据报（IP datagram，也可以是IP数据报的一个片（fragment）。网络层协议的代表包括：IP、IPX、RIP、OSPF等 IP协议所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP是不可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这是上层协议（传输层）：TCP或UDP要做的事情。 IP数据报首部 首部和数据报之和的长度，最大65535，不能超过MTU（即最大传送单元） 版本：4位，IP协议的版本 首部长度：4位（1个单位表示4个字节） 区分服务：8位，报文的优先级，获得更好的服务（QoS应用） 总长度：16位 标识：计数器，产生数据报的标识（共有几个数据报） 标志：3位，前两位有意义（MF=1，有分片，MF=0，最后一个分片，DF=0，允许分片） 片偏移：13位，较长的分组在分片后，某片在原分组中的相对位置，以8个字节为偏移单位 生存时间：TTL，数据报在网络中可通过的路由器数的最大值（8位） 协议：8位，指出数据报使用何种协议 首部校验和：16位，只检查数据报首部，不检查数据部分 IP地址 192.168.128.10/24 24表示从头数到第几为止属于网络标识（前面24位为网络标识） 路由器仅根据目的主机所连接的网络号来转发分组（不考虑目的主机号） IP地址 地址范围 私有地址 保留地址 A类 0.0.0.0 ~127.255.255.255 10.0.0.0~10.255.255.255 127.0.0.0~127.255.255.255 B类 128.0.0.0~191.255.255.255 172.16.0.0~172.31.255.255 169.254.0.0~169.254.255.255 C类 192.0.0.0~223.255.255.255 192.168.0.0~192.168.255.255 D类 224.0.0.0-239.255.255.255 E类 240.0.0.0~255.255.255.255 私有地址就是在互联网上不使用，而被用在局域网络中的地址 单播地址：A类，B类和C类地址 多播地址：D类地址 224.0.0.0代表组地址，用在IGMP查询报文中 224. 0.0.1 代表“该子网内的所有主机”，用在IGMP的查询报文 224.0.0.2 代表“该子网内的所有路由器组” 224.0.1.1 用作网络时间协议NTP 224.0.0.9 用作RIP-2 224.0.1.2 用作SGI公司的dogfight应用 广播地址 主机地址全为1的IP地址为广播地址 本地广播：在本网络内的广播 直接广播：不同网络之间的广播 特殊IP地址 net-id host-id 源地址使用 目的地址使用 说明 0 0 可以 不可 本网络本主机(DHCP协议) 0 host-id 可以 不可 本网络的某个主机(host-id) 全1 全1 不可 可以 广播地址（在本网络广播，即路由器不转发） net-id 全1 不可 可以 广播地址(对net-id上的所有主机进行广播) 127 非全0或全1的任何数 可以 可以 环回地址：本主机进程之间的通信 子网划分从主机号借用若干位作为子网号，两级IP地址变成了三级IP地址：网络号、子网号和主机号 数据报到达路由器后，路由器通过子网掩码来确定子网，将数据转发到子网到达目的主机 为了便于查找路由表，不划分子网时也使用子网掩码 A类地址默认子网掩码：255.0.0.0 B类地址默认子网掩码：255.255.0.0 C类地址默认子网掩码：255.255.255.0 为什么同时需要IP地址和MAC地址？ 如果只用MAC地址，网桥在学习到MAC地址前，必须向全世界发送包，将会造成巨大的网络流量，并且表格难以维护，超过网桥所能承受的极限。 如果只使用IP地址，网络中的路由器会隔断网络，在以太网发送IP包时，“下一个路由器”只能有MAC地址来确定，IP地址无法确定。 IP地址的作用很重要的一部分就是屏蔽链路层的差异，因为它是一个逻辑地址，所以可以适应于多种链路； 以太网这种链路层组网方式中，要通过mac地址来通信，其实ip协议完全可以运行于串口（通常运行slip或ppp等链路层协议）等其他形式的链路之上，这时并不需要一个mac地址 在局域网中两台电脑之间传输数据包用MAC地址即可识别 而通过路由器访问互联网 ，传输数据包中的MAC地址就转成路由器的MAC地址。此时就要靠IP来识别，当我要换了一台路由器时候，只要我的IP地址不变，要跟我们传输数据的对象只要记住IP地址即可与我们通信，而不需记住我们的mac地址。 ARP地址解析协议ARP（Address Resolution Protocol） ARP 是根据IP地址获取MAC地址的一种协议， 工作在数据链路层与网络层之间 IP地址和MAC地址都具有唯一性，只有IP地址具有层次性（网段） 当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。 如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址 收到这份广播的包的所有主机都会查询自己的IP地址 如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。 ARP报文字段 以太网帧类型：0x0806 硬件类型：1表示以太网地址 协议类型：表示要映射的协议地址类型。值为0x0800，表示IP地址 硬件地址长度和协议地址长度分别指出硬件地址和协议地址的长度，以字节为单位。对于以太网上IP地址的ARP请求或应答来说，它们的值分别为6和4。 操作字段：指出四种操作类型，ARP请求（值为1）、ARP应答（值为2）、RARP请求（值为3）和RARP应答（值为4） 以太网目的地址为全1的广播地址，以太网源地址和发送端以太网地址相同。 ARP请求响应报文1 ARP request(ARP请求) 2 ARP replay(ARP响应) ARP缓存表ARP是借助ARP请求与ARP响应两种类型的包确定MAC地址 主机A为了获得主机B的MAC地址，起初要通过广播发送一个ARP请求包。这个包中包含了想要了解其MAC地址的主机IP地址。 ARP的请求包会被这同一个链路上所有的主机和路由器解析。如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个节点就将自己的MAC地址塞入ARP响应包返回给主机A。 由此，可以通过ARP从IP地址获得MAC地址，实现链路内的IP通信。 如果每发送一个IP数据报都要进行一次ARP请求以确定MAC地址，那将会造成不必要的网络流量，因此，通常的做法是把获取到的MAC地址缓存一段时间。 即把第一次通过ARP获取到的MAC地址作为IP对MAC的映射关系记忆到一个ARP缓存表中，下一次再向这个IP地址发送数据报时不需再重新发送ARP请求，而是直接使用这个缓存表当中的MAC地址进行数据报的发送。 每执行一次ARP，其对应的缓存内容都会被清除。高速缓存中每一项的生存时间一般为20分钟 RARP协议逆地址解析协议PARP（Reverse Address Resolution Protocol） 从MAC地址定位IP地址 对于嵌入式设备，会遇到没有任何输入接口或无法通过DHCP动态获取IP地址的情况。需要RARP服务器来注册设备的MAC地址及其IP地址。 RARP分组的格式与ARP分组基本一致。主要的差别是RARP请求或应答的帧类型代码为0x8035，而且RARP请求的操作代码为3，应答操作代码为4。 ARP，RARP请求以广播方式传送，应答一般是单播(unicast)传送的 ICMP协议ICMP协议（Internet Control Message Protocol，网际控制报文协议） IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会 ICMP报文是在IP数据报内部被传输的 12ping www.baidu.comtracert www.baidu.com # 侦测主机到目的主机之间所经路由情况 Ping发送一个ICMP，回声请求消息给目的地并报告是否收到所希望的ICMP echo （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。原理：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。 ICMP报文 不同类型由报文中的类型字段和代码字段来共同决定 查询报文类型8 代码0：请求回显（ping请求） 响应报文类型0 代码0：回显应答(Ping应答） 0 回送应答（Echo Reply） 3 目标不可达（Destination Unreachable） 4 原点抑制（Source Quench） 5 重定向或改变路由（Redirect） 8 回送请求（Echo Request） 9 路由器公告（Router Advertisement） 10 路由器请求（Router Solicitation） 11 超时（Time Exceeded） 17 地址子网请求（Address Mask Request） 18 地址子网应答（Address Mask Reply） IGMP协议IGMP协议（Internet Group Management Protocol，网际组管理协议），用于主机与路由器之间交互信息，IGMP有固定的报文长度，没有可选数据 所有要加入组播组的主机和所有连接到有组播主机的子网中的路由器都需支持IGMP协议 IGMP消息不能被路由器转发，只限制在本地网络内 IGMP报文的TTL值始终为1 IGMP版本 IGMP的版本目前有V1/V2/V3三种 RFC 1112 — IGMPv1 RFC 2236 — IGMPv2 RFC 3376 — IGMPv3 IGMPv1 IGMPv2 IGMPv3 查询器选举 依靠上层路由协议 自己选举 自己选举 成员离开方式 默默离开 主动发出离开报文 主动发出离开报文 特定组查询 不支持 支持 支持 指定源、组加入 不支持 不支持 支持 多播路由器加入一个多播组一个主机通过组地址和接口来识别一个多播组。主机必须保留一个表，此表中包含所有至少含有一个进程的多播组以及多播组中的进程数量。 多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况。使用规则如下：1) 当第一个进程加入一个组时，主机就发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个IGMP报告。这个报告被发送到进程加入组所在的同一接口上。 2) 进程离开一个组时，主机不发送IGMP报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的IGMP查询中就不再发送报告报文。 3) 多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个IGMP查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此IGMP查询报文中的组地址被设置为0。 4) 主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告。 使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。 IGMP 报文 IGMP类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文。 检验和的计算和ICMP协议相同。 组地址为D类IP地址。在查询报文中组地址设置为0，在报告报文中组地址为要参加的组地址。 IGMPv1的查询与响应过程如下： IGMP查询器周期性地向共享网段内所有主机以组播方式（目的地址为224.0.0.1）发送“成员关系查询”报文（组地址为0）。 网络内所有主机都接收到该查询消息，如果某主机对任意组播组G感兴趣，则发送“成员关系报告”报文（其中携带组播组G的地址）来宣告自己将加入该组播组。 经过查询/响应过程后，IGMP路由器了解到本网络内存在组播组G对应的接收者，生成（*，G）组播转发表项并依此作为组播信息的转发依据。（*表示组播组成员，G表示某个组播组）。 OSPFOSPF(Open Shortest Path First开放式最短路径优先） 是一个内部网关协议(Interior Gateway Protocol，简称IGP） 是目前广泛使用的一种动态路由协议，属于链路状态路由协议，运作于自治系统内部 著名的迪克斯加算法被用来计算最短路径树 OSPF支持负载均衡和基于服务类型的选路 也支持多种路由形式，如特定主机路由和子网路由等。 RIPRIP(Routing Information Protocol, 路由信息协议） 是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统 (autonomous system,AS） 内的路由信息的传递 RIP协议基于距离矢量算法（DistanceVectorAlgorithms） --THE END--]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议架构介绍（一）：网络接口层]]></title>
    <url>%2Fposts%2Ftcp-ip-protocol-architecture-model_link-layer%2F</url>
    <content type="text"><![CDATA[TCP/IP协议架构是通信协议的统称，常被称为TCP/IP协议族，包括两个核心协议：TCP（传输控制协议）和IP（网际协议），TCP/IP协议的开发始于20世纪60年代后期，早于OSI参考模型，由于TCP/IP模型更加简洁易用，目前大多采用TCP/IP模型。一共包括4层：应用层、传输层、网络层和网络接口层。 OSI模型与TCP/IP模型： 物理层负责0、1 比特流（0/1序列）与电压的高低之间的转换 数据的单位称为比特（bit） 属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45、fddi令牌环网等OSI采纳了各种现成的协议，其中有RS-232、RS-449、X.21、V.35、ISDN、以及FDDI、IEEE802.3、IEEE802.4、和IEEE802.5的物理层协议 数据链路层负责物理层面上的互联的、节点间的通信传输（例如一个以太网项链的2个节点之间的通信）； 该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧（frame） 封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。 透明传输：零比特填充、转义字符。 可靠传输：在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。 差错检测(CRC)：接收者检测错误,如果发现差错，丢弃该帧。 主要协议①点对点协议PPP（Point to Point Protocol）②以太网（Ethernet)③高级数据链路控制协议HDLC(High-Level Data Link Control)④ 帧中继（Frame Relay)⑤异步传输模式ATM(Asynchronous Transfer Mode) MAC地址MAC(Medium/Media Access Control)地址，媒体访问控制,或称为物理地址、硬件地址，48位 MAC地址 组织唯一标识符（OUI）由IEEE（电气和电子工程师协会）分配给厂商 I/G（Individual/Group）位，如果I/G=0，则是某台设备的MAC地址，即单播地址；如果I/G=1，则是多播地址（组播+广播=多播）。 G/L（Global/Local，也称为U/L位，其中U表示Universal）位，如果G/L=0，则是全局管理地址，由IEEE分配；如果G/L=1，则是本地管理地址，是网络管理员为了加强自己对网络管理而指定的地址。 MAC帧 IP地址负责表示计算机的网络层地址，网络层设备（如路由器）根据IP地址来进行操作；MAC地址负责表示计算机的数据链路层地址IP和MAC地址这种映射关系由ARP（Address Resolution Protocol，地址解析协议）协议完成。 PPPoE 协议基于以太网的点对点通讯协议PPPOE(Point to Point Protocol over Ethernet) 单纯的以太网没有验证功能，也没有建立和断开连接的处理，因此无法按时计费。 如果采用PPPoE管理以太网连接，就可以利用PPP的验证等功能使各家ISP可以有效地管理终端用户的使用。 分成发现阶段(Discorvery)和PPP会话阶段（Session） 报文的以太网类型: 当值为0x8863时表示Discovery阶段或Terminate阶段。 当值为0x8864时表示Session阶段。 PPPoE拨号过程 PPPoE Discovery发现阶段 用户主机用广播的方式发出PADI (PPPOE Active Discovery Initiatio) 包，准备去获得所有可连接的接入设备（获得其MAC地址）； PPPoE服务器收到PADI包后，返回PADO (PPPOE Active Discovery Offer) 作为回应； 用户主机从收到的多个PADO包中，根据其名称类型名或者服务名，选择一个合适的接入设备，然后发送PADR (PPPOE Active Discovery Request) 包，另外如果一个用户主机在发出PADI后在规定时间内没有收到PADO，则会重发PADI,并且加倍等待时间； PPPoE服务器收到PADR包后，返回PADS (PPPOE Active Discovery Session-confirmation) 包，其中包含了一个唯一session ID，双方进入PPP会话阶段。 code 报文 0x09 PADI PPPoE Active Discovery Initiation PPPoE发现初始报文 0x07 PADO PPPoE Active Discovery Offer PPPoE发现提供报文 0x19 PADR PPPoE Active Discovery Request PPPoE发现请求报文 0x65 PADS PPPoE Active Discovery Sessionconfirmation PPPoE发现会话确认报文 0xa7 PADT PPPoE Active Discovery Terminate PPPoE发现终止报文 Discovery阶段：以太网帧的ETHER_TYPE域都设置为 0x8863 PPPoE Session 会话阶段1 LCP协商阶段（Link Control Protocol）链路协商 LCP用于建立、拆除和监控PPP数据链路 还用于链路层参数的协商，如MRU、验证方式 协商双方互相发送一个LCP Config-Request报文，确认收到的Config-Request报文中的协商选项，根据这些选项的支持与接受情况，做出适当的回应。若两端都回应了Config-ACK，则标志LCP链路建立成功，否则会继续发送Request报文，直到对端回应了ACK报文为止。 2 认证阶段 会话双方通过LCP协商好的认证方法进行认证，如果认证通过了，才可以进行下面的网络层的协商。认证过程在链路协商结束后就进行。 PAP（Password Authentication Protocol，口令认证协议） PAP为两次握手协议，它通过用户名及口令来对用户进行验证。 CHAP（Challenge Handshake Authentication Protocol，质询握手认证协议） CHAP为三次握手协议。只在网络上传输用户名，并不传输用户口令，因此它的安全性要比PAP高。 Md5算法 3 NCP协商阶段 网络层协商：IPCP、BCP、IPv6CP等 协商PPP报文的网络层参数，如IP地址，DNS Server IP等。 PPPoE用户主要通过IPCP来获取访问网络的IP地址或IP地址段，网关，DNS等。 用户和接入设备对IP服务阶段的一些要求进行多次协商，以决定双方都能够接收的约定。如：IP业务阶段使用的IP压缩协议等。 双方的协议是通过报文中包含的Option项进行协商的，每一个Option都是一个需要协商的问题。最后双方都需要对方答复Configure_Ack的同意报文。 IPCP的协商过程是基于PPP状态机进行协商的。 经过双方协商，通过配置请求、配置确认、配置否认等包文交换配置信息，最终由initial (或closed)状态变为Opened状态。 IPCP状态变为Opened的条件必须是发送方和接收方都发送和接收过确认报文。 IPCP协商过程中，协商报文可包含多个选项，即参数。 各个选项的拒绝或否认都不能影响IPCP的UP，IPCP可以无选项协商，无选项协商也同样能够UP。选项有IP Address、网关、掩码等，其中IP Address是最重要的一个选项，有些厂家的实现必须这个选项得到确认，大多数厂家的实现允许这个选项为空。 PPPoE Terminate阶段 PPP通信双方可以使用PPP协议自身来结束PPPoE会话 当无法使用PPP协议结束会话时可以使用PADT（PPPoE Active Discovery Terminate）报文。 进入PPPoE Session阶段后，PPPoE Client和PPPoE Server都可以通过发送PADT报文的方式来结束PPPoE连接。 PADT数据包可以在会话建立以后的任意时刻单播发送。在发送或接收到PADT后，就不允许再使用该会话发送PPP流量了。 --THE END--]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议架构介绍（三）：传输层]]></title>
    <url>%2Fposts%2Ftcp-ip-protocol-architecture-model_transport-layer%2F</url>
    <content type="text"><![CDATA[传输层主要为两台主机上的应用程序提供端到端的通信。 传输层简介 传输层是唯一负责总体的数据传输和数据控制的一层； 数据的单位称为数据段（segment） TCP报文段（TCP segment） UDP数据报（User Datagram） 主要功能： ①为端到端连接提供传输服务 ②这种传输服务分为可靠和不可靠的,其中TCP是典型的可靠传输，而UDP则是不可靠传输 ③为端到端连接提供流量控制，差错控制，服务质量(Quality of Service,QoS)等管理服务 包括的协议如下： TCP：传输控制协议，传输效率低，可靠性强 UDP：用户数据报协议，适用于传输可靠性要求不高，数据量小的数据（比如QQ：采用的通信协议以UDP为主，辅以TCP协议） DCCP、SCTP、RTP、RSVP、PPTP等协议 端口号 MAC地址用来识别同一链路中不同的计算机，IP地址用来识别TCP/IP网络中互连的主机和路由器 传输层中也有这种类似于地址的概念，那就是端口号。 端口号用来识别同一台计算机中不同的应用程序。因此，它也被称为程序地址。 同一台计算机可以同时运行多个程序：通过端口号来识别正在进行通信的应用程序，并准确的将数据传输 TCP/IP或者UDP/IP通信中通常采用5个信息来识别一个通信，分别是“源IP地址”、“目标IP地址”、“协议号”、“源端口号”、“目标端口号”，也被称为“五元组”，只要其中某一项不同，则被认为是其他通信。 端口号的取值范围在0-65535之间，其中0-1023为知名端口号，1024-65535之间的端口为非知名端口不同的传输层协议可以使用相同的端口号 数据到达IP层后，会先检查IP首部中的协议号，再传给相应协议的模块。如果是TCP则传给TCP模块，如果是UDP则传给UDP模块去做端口号的处理，即使是同一个端口号，由于传输协议是各自独立的进行处理，因此相互之间不会受到影响。 TCP协议和UDP协议TCP（Transmission Control Protocol，传输控制协议） UDP（User Datagram Protocol，用户数据报协议） TCP和UDP协议特点 TCP UDP 可靠性 可靠 不可靠 连接性 面向连接 无连接 报文 面向字节流 面向报文 效率 传输效率低 传输效率高 双工性 全双工 一对一、一对多、多对一、多对多 流量控制 滑动窗口 无 拥塞控制 慢开始、拥塞避免、快重传、快恢复 无 传输速度 慢 快 应用 SMTP、Telnet、HTTP、FTP、DNS DNS、TFTP、SNMP、NFS TCP的主要特点是： 1.TCP 是面向连接的传输层协议。 2.TCP 提供可靠交付的服务。 3.TCP是面向字节流 4.提供流量控制，拥塞控制 5.TCP提供全双工通信。每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP连接只能是点对点的（一对一）。 6.首部最低20个字节。 可靠传输： 应答机制：对方收到消息底层会回复 超时重传：给多方发送一个数据，如果一段时间内对方没有接收，会隔一段时间给对方再次发送，如果一直没有回复，会认为对方掉线了 错误校验：如果接收的数据包序号发生了错乱，TCP会自动排序，保证数据的有序性，如果有重复数据包，会删除重复的数据包 流量控制：数据发送在网卡缓存区达到一定上限，对方不会一直发送数据，需要等待对方接收数据，网卡缓存区有空间再发送，保证网卡缓存不会超出 UDP的主要特点是： UDP是无连接的，在发送数据之前不需要建立连接，因此减少了靠小和发送数据之前的时延。 UDP使用尽最大努力交付，不保证可靠交付。 UDP是面向报文的，发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。 UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。 UDP支持一对一、一对多、多对一和多对多的交互通信。 UDP的首部开销小，只有8个字节，比TCP的20个字节首部要短。 TCP报文格式 源端口和目的端口：各占两个字节，分别表示数据包源端口和目的端口，由此可知，端口号的范围是0-65535。 序号：四个字节，范围是[0,232-1]，共232(4294967296)个序号。TCP字节流的起始序号必须在连接建立时设置，首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。 确认号：四个字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表示到序号N-1为止的所有数据都已正确收到。 数据偏移：占四位，它指出当前TCP报文段的数据起始处距离整个TCP报文段的起始处有多远。 保留：占六位，保留为今后使用，当前应置为0。 控制位：占六位，包含URG,ACK,PSH,RST,SYN和FIN，分别为TCP连接中需要使用的数据位。 窗口：两个字节，窗口值是[0,216-1]之间的整数，窗口指的是发送本报文段一方的接收窗口，作为接收方让发送方设置其发送窗口的依据。 校验和：两个字节，检查范围包括首部和数据这两部分。 紧急指针：两个字节，只有URG=1时才有意义。 选项：长度可变，最长可达40字节，当没有使用选项时，TCP首部长度是20字节。 在TCP中，当发送端的数据到达接收端主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。 TCP连接的建立和断开过程 三次握手和四次挥手 建立一个TCP连接需要3个报文段，而关闭TCP连接需要4个报文段。 UDP报文格式 源端口号：表示发送端端口号，字段长16位。该字段是可选项，有时可能不会设置源端口号。没有源端口号的时候该字段的值为0，可用于不需要返回的通信中。 目标端口号：表示接收端端口，字段长度16位。 包长度：该字段保存了UDP首部的长度和数据的长度之和，单位为字节。 校验和：校验和是为了提供可靠的UDP首部和数据而设计的。需要把首部和数据部分一起都检验 --THE END--]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议架构介绍（四）：应用层]]></title>
    <url>%2Fposts%2Ftcp-ip-protocol-architecture-model_application-layer%2F</url>
    <content type="text"><![CDATA[本文介绍应用层相关协议 数据：报文 FTP文件传输协议FTP(File Transfer Protocol)：TCP20，21FTP协议包括两个组成部分：FTP服务器和FTP客户端 FTP传输模式FTP支持两种模式，一种方式叫做Standard (也就是 PORT方式，主动方式)，一种是 Passive(也就是PASV，被动方式)。 Standard模式：FTP的客户端发送 PORT 命令到FTP服务器 Passive模式：FTP的客户端发送 PASV命令到 FTP服务器 默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息 但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关 如果采用主动模式，那么数据传输端口就是20 如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定 Port FTP 客户端首先和FTP服务器的TCP 21端口建立连接，通过这个通道发送命令 客户端需要接收数据的时候在这个通道上发送PORT命令，PORT命令包含了客户端用什么端口接收数据。 在传送数据的时候，服务器端通过自己的TCP 20端口连接至客户端的指定端口发送数据。 FTP server必须和客户端建立一个新的连接用来传送数据 Passive 在建立控制通道的时候和Standard模式类似，但建立连接后发送的不是Port命令，而是Pasv命令 FTP服务器收到Pasv命令后，随机打开一个高端端口（端口号大于1024）并且通知客户端在这个端口上传送数据的请求 客户端连接FTP服务器此端口，通过三次握手建立通道，然后FTP服务器将通过这个端口进行数据的传送。 很多防火墙在设置的时候都是不允许接受外部发起的连接的，所以许多位于防火墙后或内网的FTP服务器不支持PASV模式，因为客户端无法穿过防火墙打开FTP服务器的高端端口； 而许多内网的客户端不能用PORT模式登陆FTP服务器，因为从服务器的TCP 20无法和内部网络的客户端建立一个新的连接，造成无法工作。 TFTPTFTP（Trivial File Transfer Protocol,简单文件传输协议） 端口号 UDP69 TFTP协议支持三种传输模式： netascii：ASCII文本模式 octet：二进制模式，每字节8位 mail：现在已经不使用 TFTP协议数据包种类 opcode 描述 1 读请求（RRQ） 2 写请求（WRQ） 3 数据（DATA） 4 应答（ACK） 5 错误（ERROR） 6 选项应答（OACK） TFTP和FTP一个主要的区别就是它没有交互式，且不进行身份验证。 SSH安全外壳协议SSH( secure shell protocal )：TCP22 ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据 SSH可以有效防止远程管理过程中的信息泄露问题， 提供了基于内容加密服务 SSH传输的数据是经过压缩的，所以可以加快传输的速度。 SSH既可以代替Telnet，又可以为FTP、PoP、甚至为PPP提供一个安全的”通道” 口令验证参考网址（1）客户端向远程主机发起登陆链接请求。（2）远程主机收到用户的登录连接请求，然后把自己的公钥发给客户端。（3）客户端收到这个公钥，并使用这个公钥，将登录密码加密后，发送到远程主机。（4）远程主机用自己的私钥，解密登录密码，并验证该密码与当前要登陆的用户密码是否匹配，匹配就同意用户登录。 缺陷：口令验证，主动权在客户端，真正的远程主机可能会被拦截掉，能会有别的服务器伪装真正的服务器，受到“中间人”的攻击。此时客户端收到的密钥是伪装机的，客户端发送加密后的密码后，会被伪装机通过私钥解密，此时伪装机就获取到了真实远程主机的账密，那么真实远程主机的安全就受到了严重威胁。 密钥验证前提：客户端在本地生成非对称密钥（公钥、私钥）。并且将公钥放到了远程主机的.ssh/authorized_keys文件中。（1）客户端向远程主机发起登陆连接请求，附带信息备注：网上对于附带信息，我目前看到两个版本，一个是：ip，用户名；一个是：公钥信息。对于第一种，我是肯定不赞同，客户端物理位置不定，Ip会变，而且公钥信息中根本没有IP，用户名等信息，所以用IP和用户名在远程主机中定位公钥肯定不行；第二版本我比较赞同，但是目前还有待验证。（2）远程主机根据附带的信息定位到客户端对应的公钥，然后生成一个随机串并用该公钥加密，然后将生成的加密串发送给客户端。（3）客户端收到远程主机送来的加密串，然后用自己的私钥解密，再将解密后的字符串送给远程主机。（4）远程主机接收到解密后的字符串，然后跟自己最初生成的字符串作比较，一样则校验成功，允许与客户端建立登陆链接。 与第一种级别相比，第二种级别不需要在网络上传送口令。第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒 。 Telnet远程登录协议Telnet(telecommunication network protocol)：TCP23Telnet 协议是基于网络虚拟终端 NVT(Network Virtual Termina1)的实现NVT 是虚拟设备，连接双方(客户机和服务器)都必须把它们的物理终端和 NVT 进行相互转换。 实现整个协议软件分为三个模块，各模块的功能如下： 与本地用户的输入/输出模块：处理用户输入/输出； 与远地系统的输入/输出模块：处理与远程系统输入/输出； TELNET 协议模块：实现 TELNET 协议，维护协议状态机。 Telnet远程登录服务分为以下4个过程：1）本地与远程主机建立连接。该过程实际上是建立一个TCP连接，用户必须知道远程主机的Ip地址或域名；2）将本地终端上输入的用户名和口令及以后输入的任何命令或字符以NVT（Net Virtual Terminal）格式传送到远程主机。该过程实际上是从本地主机向远程主机发送一个IP数据包；3）将远程主机输出的NVT格式的数据转化为本地所接受的格式送回本地终端，包括输入命令回显和命令执行结果；4）最后，本地终端对远程主机进行撤消连接。该过程是撤销一个TCP连接。 telnet 客户机要做两件事： 读取用户在键盘上键入的字符，并通过 tcp 连接把他们发送到远程服务器上 读取从 tcp 连接上收到的字符，并显示在用户的终端上 Telnet 协议的主体由三个部分组成： 网络虚拟终端（NVT，Network Virtual Terminal）； 操作协商； 协商有限自动机； NVT 的组成网络虚拟终端 NVT 包括两个部分： 输出设备：输出远程数据，一般为显示器 输入设备：本地数据输入在网络虚拟终端 NVT 上传输的数据采用 8bit 字节数据，其中 最高位为 0 的字节用于一般数据，最高位为 1 的字节用于 NVT 命令。 操作协商为了实现对多种终端特性的支持，TELNET协议规定在扩展NVT功能时采用协商的机制，只有通信双方通过协商后达成一致的特性才能使用，才能赋予NVT该项特性，这样就可以支持具有不同终端特性的终端设备可以互连，保证他们是工作在他们自己的能力以内。 RDP远程桌面协议RDP(Remote Desktop Protocol)是一个多通道(multi-channel)的协议，windows自带的远程桌面mstsc端口TCP 3389 HTTP超文本传输协议HTTP(HTTPHyper Text Transfer Protocol)： HTTP端口号：TCP 80 HTTPS端口号：TCP 443 HTTP协议的服务器端实现程序有httpd、nginx等，其客户端的实现程序主要是Web浏览器应用：WEB端内容获取(门户网站)，在移动互联网的客户端APP HTTP请求报文方法 方法 意义 OPTION 请求一些选项信息 GET 请求读取由URL所标志的信息 HEAD 请求读取由URL所标志的信息的首部 POST 给服务器添加信息 PUT 在指明的URL下存储一个文档 DELETE 删除指明的URL所标志的资源 TRACE 用来进行环回测试的请求报文 CONNECT 用于代理服务器 常见状态码状态码有5个大类，由第一位数字进行区分，每个大类下面还有不同的子类，每种子类的长度都是3位，都代表一个状态码，即一种类型的返回的信息。 1xx 表示通知信息，如请求收到了或正在进行处理 2xx 表示成功，如接受或知道了 3xx 表示重定向，如果要完成请求还必须才去进一步的行动 4xx 表示客户的差错 5xx 表示服务器的差错 工作原理HTTP是基于客户/服务器模式，且面向连接的。一次HTTP操作称为一个事务，典型的HTTP事务处理过程如下： （1）客户与服务器建立连接；建立连接-TCP三次握手 （2）客户向服务器提出请求；发送请求信息 （3）服务器接受请求，并根据请求返回相应的文件作为应答；发送响应信息 （4）客户与服务器关闭连接。关闭连接 客户与服务器之间的HTTP连接是一种一次性连接，它限制每次连接只处理一个请求，当服务器返回本次请求的应答后便立即关闭连接，下次请求再重新建立连接(可以大大提高服务器的执行效率)。 HTTP是一种无状态协议，即服务器不保留与客户交易时的任何状态。这就大大减轻了服务器记忆负担，从而保持较快的响应速度。 HTTP是一种面向对象的协议。允许传送任意类型的数据对象。它通过数据类型和长度来标识所传送的数据内容和大小，并允许对数据进行压缩传送。 当用户在一个HTML文档中定义了一个超文本链后，浏览器将通过TCP/IP协议与指定的服务器建立连接。 从技术上讲是客户在一个特定的TCP端口（端口号一般为80）上打开一个套接字。如果服务器一直在这个周知的端口上倾听连接，则该连接便会建立起来。然后客户通过该连接发送一个包含请求方法的请求块。 HTTP规范定义了7种请求方法，每种请求方法规定了客户和服务器之间不同的信息交换方式，常用的请求方法是GET和POST。服务器将根据客户请求完成相应操作，并以应答块形式返回给客户，最后关闭连接。 HTTP协议是无状态的和Connection: keep-alive的区别 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。HTTP是一个无状态的面向连接的协议， 无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。 HTTP报文 TCP三次握手建立连接[SYN]—seq:(x=0)[SYN,ACK]—seq:(y=0),ack = x+1 = 1[ACK]—seq=x+1=1,ack=y+1=1 9.9.9.13 发出HTTP页面和图片请求 No.4GET 157.255.77.60确认 No.5 157.255.77.60传输数据 No.6发送状态响应码200 OK 9.9.9.13确认 No.7... 关闭连接tcp.flags.fin==1 HTTP请求报文 HTTP响应报文 chrome开发者工具分析网络请求chrome浏览器打开网页，按F12 或者 右键选择检查，选择Network，刷新页面或者点击页面元素，可以看到报文交互、资源请求信息： DNS域名服务系统DNS（Domain Name System）：UDP53，是因特网上作为域名和IP地址相互映射的一个分布式数据库，进行域名解析的服务器 域名顶级域名（top level domain）:(1) 国家顶级域名(2) 通用顶级域名(3) 基础结构域名 阿里云DNS：223.5.5.5，备用，223.6.6.6老牌DNS：114.114.114.114谷歌：8.8.8.8腾讯：119.29.29.29百度：180.76.76.76 DNS协议DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。 DNS区域传输的时候使用TCP协议： 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。 TCP是一种可靠连接，保证了数据的准确性。 域名解析时使用UDP协议： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。 理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 DNS报文DNS首部12字节 DNS query 查询报文 DNS response 响应报文 DDNSDDNS（Dynamic Domain Name Server，动态域名服务）将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务器程序负责提供DNS服务并实现动态域名解析。 动态域名解析（Dynamic DNS，简称DDNS）是把互联网域名指向可变IP地址的系统。 DNS只是提供了域名和IP地址之间的静态对应关系，当IP地址发生变化时，DNS无法动态的更新域名和IP地址之间的对应关系，从而导致访问失败。 DDNS系统是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络时，客户端程序通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，实现动态域名解析。 DDNS用来动态更新DNS服务器上域名和IP地址之间的对应关系，从而保证通过域名访问到正确的IP地址。 很多机构都提供了DDNS服务，在后台运行并且每隔数分钟来检查电脑的IP地址，如果IP发生变更，就会向DNS服务器发送更新IP地址的请求。 DHCP动态主机配置协议DHCP（Dynamic Host Configuration Protocol）：UDP67，68 bootps:67bootpc:68 DHCP过程 发现阶段，DHCP Discover，DHCP客户机以广播方式发送DHCP discover报文寻找DHCP服务器（向地址255.255.255.255发送广播信息）。 提供阶段，DHCP Offer，接收到DHCP discover报文的DHCP服务器都会做出响应，向DHCP客户机发送一个包含IP地址和其他信息的Offer报文。 选择阶段，DHCP Request，DHCP客户机只接受第一个收到的DHCP offer提供的信息，然后它就以广播方式回答一个DHCP request请求信息，该信息中包含向它所选定的DHCP服务器请求IP地址的内容，通知所有的DHCP服务器，他将选择某台DHCP服务器所提供的IP地址。 确认阶段，DHCP ACK，确认IP地址。当DHCP服务器收到DHCP客户机回答的DHCP request请求信息之后，它便向DHCP客户机发送一个包含它所提供的IP地址和其他设置的DHCP ack确认信息，告诉DHCP客户机可以使用它所提供的IP地址。 重新登录，DHCP NAK，如果客户机的IP地址已无法再分配给原来的DHCP客户机使用时（比如此IP地址已分配给其它DHCP客户机使用），则DHCP服务器给DHCP客户机回答一个DHCP nack否认信息。当原来的DHCP客户机收到此DHCP nack否认信息后，重新发送DHCP discover发现信息来请求新的IP地址。 更新租约，DHCP服务器向DHCP客户机出租的IP地址一般都有一个租借期限，期满后DHCP服务器便会收回出租的IP地址。如果DHCP客户机要延长其IP租约，则必须更新其IP租约。DHCP客户机启动时和IP租约期限过一半时，DHCP客户机都会自动向DHCP服务器发送更新其IP租约的信息。通过单播发送DHCP request信息到DHCP服务器 DHCP Release，当用户不再需要使用分配IP地址时，就会”主动”向DHCP服务器发送Release报文，告知服务器用户不再需要分配IP地址，DHCP服务器会释放被绑定的租约(在数据库中清除某个MAC对某个IP的租约记录，这样，这个IP就可以分配给下一个请求租约的MAC) DHCP Decline，DHCP客户端收到DHCP服务器回应的ACK报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则发送Decline报文，通知服务器所分配的IP地址不可用，我们在手工设置静态IP、或者DHCP分配中有时会遇到”检测到IP冲突”的提示就是因为客户端利用ARP机制来在当前内网中确认当前指定的IP是否已经被占用 DHCP Inform，DHCP客户端如果需要从DHCP服务器端获取更为详细的配置信息，则发送Inform报文向服务器进行请求，服务器收到该报文后，将根据租约进行查找，找到相应的配置信息后，发送ACK报文回应DHCP客户端 DHCP中继代理家庭网络大多都只有一个以太网（无线LAN）的网段，与其连接的主机台数也不会太多。因此，只要有一台DHCP服务器就足以应对IP地址分配的需求，而大多数情况下都由宽带路由器充当这个DHCP的角色。相比之下，一个企业或学校等较大规模组织机构的网络环境中，一般会有多个以太网（无线LAN）网段。在这类网络环境中，往往需要将DHCP统一管理。具体方法可以使用DHCP服务器统一进行管理和运维。 只需在每个网段设置一个DHCP中继代理即可。DHCP客户端会向DHCP中继代理发送DHCP请求包，而DHCP中继代理收到这个广播包以后再以单播形式发给DHCP服务器。 服务器收到该包以后再向DHCP中继代理返回应答，并由DHCP中继代理将此包转发给DHCP客户端。DHCP包中包含发出请求的主机的MAC地址。DHCP中继代理正是利用这个MAC地址将包返回给了DHCP客户端。由此，DHCP服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。 DHCP报文格式 OP：报文的操作类型。分为请求报文和响应报文。 1：请求报文，2：应答报文。即client送给server的封包，设为1，反之为2。 请求报文：DHCP Discover、DHCP Request、DHCP Release、DHCP Inform和DHCP Decline。 应答报文：DHCP Offer、DHCP ACK和DHCP NAK。 Htype：DHCP客户端的MAC地址类型。MAC地址类型其实是指明网络类型 Htype值为1时表示为最常见的以太网MAC地址类型。 Hlen：DHCP客户端的MAC地址长度。以太网MAC地址长度为6个字节，即以太网时Hlen值为6。 Hops：DHCP报文经过的DHCP中继的数目，默认为0。 DHCP请求报文每经过一个DHCP中继，该字段就会增加1。 没有经过DHCP中继时值为0。(若数据包需经过router传送，每站加1，若在同一网内，为0。) Xid：客户端通过DHCP Discover报文发起一次IP地址请求时选择的随机数，相当于请求标识。用来标识一次IP地址请求过程。在一次请求中所有报文的Xid都是一样的。 Secs：DHCP客户端从获取到IP地址或者续约过程开始到现在所消耗的时间，以秒为单位。在没有获得IP地址前该字段始终为0。(DHCP客户端开始DHCP请求后所经过的时间。目前尚未使用，固定为0。) Flags：标志位，只使用第0比特位，是广播应答标识位 用来标识DHCP服务器应答报文是采用单播还是广播发送，0表示采用单播发送方式，1表示采用广播发送方式。其余位尚未使用。(即从0-15bits，最左1bit为1时表示server将以广播方式传送封包给client。) 【注意】在客户端正式分配了IP地址之前的第一次IP地址请求过程中，所有DHCP报文都是以广播方式发送的，包括客户端发送的DHCP Discover和DHCP Request报文，以及DHCP服务器发送的DHCP Offer、DHCP ACK和DHCP NAK报文。当然，如果是由DHCP中继器转的报文，则都是以单播方式发送的。 另外，IP地址续约、IP地址释放的相关报文都是采用单播方式进行发送的。 Ciaddr：DHCP客户端的IP地址。仅在DHCP服务器发送的ACK报文中显示，在其他报文中均显示0，因为在得到DHCP服务器确认前，DHCP客户端是还没有分配到IP地址的。 Yiaddr：DHCP服务器分配给客户端的IP地址。 仅在DHCP服务器发送的Offer和ACK报文中显示，其他报文中显示为0。 Siaddr：下一个为DHCP客户端分配IP地址等信息的DHCP服务器IP地址。 仅在DHCP Offer、DHCP ACK报文中显示，其他报文中显示为0。(用于bootstrap过程中的IP地址) Giaddr：DHCP客户端发出请求报文后经过的第一个DHCP中继的IP地址。 如果没有经过DHCP中继，则显示为0。(转发代理（网关）IP地址) Chaddr：DHCP客户端的MAC地址。在每个报文中都会显示对应DHCP客户端的MAC地址。 Sname：为DHCP客户端分配IP地址的DHCP服务器名称（DNS域名格式）。 在Offer和ACK报文中显示发送报文的DHCP服务器名称，其他报文显示为0。 File：DHCP服务器为DHCP客户端指定的启动配置文件名称及路径信息。 仅在DHCP Offer报文中显示，其他报文中显示为空。 Options：可选项字段，长度可变，格式为”代码+长度+数据”。 DHCP报文交互报文过滤： pppoed：过滤PPPoEbootp：过滤DHCP协议 1、DHCP Release如果Client放弃现在使用的IP地址，则它发送DHCP Release单播报文，通知Server, Server将此地址回收以便下次使用 1C:\Users\DELL&gt;ipconfig /release 2、DHCP Discover_offer_request_ack Client发送释放报文后，必须不再使用此地址发送其他数据包，并且再使用IP地址前必须重新发送Discover报文 1C:\Users\DELL&gt;ipconfig /renew DHCP Discover DHCP offer DHCP Request DHCP ACK 3、续租及续租失败的情况(1) 续租 12C:\Users\DELL&gt;ipconfig /releaseC:\Users\DELL&gt;ipconfig /renew 50%-75%-87.5% 当Client的地址到达50%的租用期（T1）时，Client进入RENEW状态，使用Request单播报文续约，联系该服务器 当Client的地址到87.5%租用期（T2）时，Client进入REBINDING状态，使用Request广播报文续约，联系任意服务器 该Request报文中，‘server identifier’必须为空 ，‘ requested IP address’为空， ’ciaddr’字段填充为客户端的IP地址 (2) 续租失败 (3) 没有IP地址缓存的情况1C:\Users\DELL&gt;ipconfig /renew 这是因为没有IP地址缓存下图为有IP地址缓存的情况下，会有option 50这个字段 --THE END--]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App自动化测试 | 自动遍历测试之Monkey工具]]></title>
    <url>%2Fposts%2Fappium-automatic-traversal-test-monkey%2F</url>
    <content type="text"><![CDATA[某些移动APP业务线多，流程复杂，且产品迭代速度快，在回归测试中涉及到大量用例，工作量大，解决这个问题的一个可行方法是使用自动遍历测试，可以降低用例维护成本，尽可能的自动化覆盖回归业务。 自动遍历工具 google android原生monkey、 app crawler 百度 smartmonkey 腾讯 newmonkey smart_monkey macaca的NoSmoke 头条的 zhangzhao maxim seveniruby appcrawler 下面介绍android原生monkey工具 Android monkey简介monkey是开发用来进行压力测试的工具，测试activity的性能。monkey向应用程序发送伪随机的用户事件流（如按键、触屏、滑动等操作），对应用程序进行随机操作，它的这种特性可以用来做自动遍历测试。 Android SDK提供了Monkey工具，使用adb shell monkey运行 常用Monkey命令对所有包随机操作100次 1adb shell monkey 100 对指定包随机操作100次 1adb shell monkey -p com.xueqiu.android 100 时间种子，如果想重现一样的测试路径，两次测试的-s参数应相同 1adb shell monkey -p com.xueqiu.android -s 20 100 打印详细日志 1adb shell monkey -p com.xueqiu.android -vv -s 20 100 可以看到对雪球app的操作日志，其中 0：触摸事件百分比，参数—pct-touch 1：滑动事件百分比，参数—pct-motion 2：缩放事件百分比，参数—pct-pinchzoom 3：轨迹球事件百分比，参数—pct-trackball 4：屏幕旋转事件百分比，参数—pct-rotation 5：基本导航事件百分比，参数—pct-nav 6：主要导航事件百分比，参数—pct-majornav 7：系统事件百分比，参数—pct-syskeys 8：Activity启动事件百分比，参数—pct-appswitch 9：键盘翻转事件百分比，参数—pct-flip 10：其他事件百分比，参数—pct-anyevent 事件百分比 1adb shell monkey -p com.xueqiu.android --pct-touch 10 1000 其他事件类似 时间延迟 1adb shell monkey -p com.xueqiu.android --throttle 5000 100 每次随机事件的时间间隔5000毫秒 常用事件 —pct-touch：触摸事件，比如点击 —pct-motion：动作事件，比如滑动(直线) —pct-trackball：轨迹事件，比如移动+点击,曲线滑动 —pct-majornav：主要导航事件，比如回退按键、菜单按键: monkey 使用实例 启动模拟器或者连接真机 自动遍历雪球APP 随机操作100次，触摸事件百分比50%，每次随机事件的时间间隔1s 1adb shell monkey -p com.xueqiu.android -vv --pct-touch 50 --throttle 1000 100 --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>自动遍历测试</tag>
        <tag>Monkey</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决网易mumu模拟器忘记PIN码]]></title>
    <url>%2Fposts%2Fandroid-mumu-emulator-pin-code%2F</url>
    <content type="text"><![CDATA[网易mumu模拟器忘记PIN码 连接模拟器 adb shell 进入手机 cd data/system 删除*.key文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849C:\Users\10287&gt;adb connect 127.0.0.1:7555* daemon not running; starting now at tcp:5037* daemon started successfullyconnected to 127.0.0.1:7555C:\Users\10287&gt;adb shellroot@x86:/ # cd dataroot@x86:/data # cd systemroot@x86:/data/system # lsappops.xmlapps-gson-infobatterystats-daily.xmlbatterystats.bincalled_pre_boots.datdevice_policies.xmldropboxentropy.datframework_atlas.configgatekeeper.password.keygatekeeper.pattern.keyheapdumpifwinputmethodinstall_sessionsjoblast-fstrimlocksettings.dblocksettings.db-shmlocksettings.db-walndebugsocketnetstatsnotification_log.dbnotification_log.db-journalpackage-usage.listpackages.listpackages.xmlprocstatsrecent_imagesrecent_tasksseapp_hashshared_prefssynctouch_sound_has_been_setuiderrors.txtusagestatsusersroot@x86:/data/system # rm gatekeeper.password.keyroot@x86:/data/system # rm gatekeeper.pattern.keyroot@x86:/data/system # reboot --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>模拟器</tag>
        <tag>网易mumu模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App自动化测试 | Android WebView测试]]></title>
    <url>%2Fposts%2Fappium-android-webview%2F</url>
    <content type="text"><![CDATA[混合应用中包含 Web 视图的应用，在 App自动化测试 | Appinum 介绍及环境安装 中介绍了appium支持WebView测试，本文将分享Android 混合页面的测试方法。 WebView测试环境准备手机端 被测浏览器： iOS：Safari Android：Chrome，Chromium，Browser (自带浏览器) PC端 安装 Chrome浏览器(或chromium)，可以访问https://www.google.com 下载手机浏览器webview版本对应的 driver webview和driver版本对应关系：https://raw.githubusercontent.com/appium/appium-chromedriver/master/config/mapping.json driver下载：https://sites.google.com/a/chromium.org/chromedriver/downloads 国内镜像地址 : https://npm.taobao.org/mirrors/chromedriver/ appium github: https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/web/chromedriver.md 查看手机浏览器版本1234adb shell pm list package | grep webviewadb shell pm dump com.android.browser | grep versionadb shell pm dump com.android.chrome | grep versionadb shell pm dump com.android.webview | grep version 查看手机browser和chrome版本 123456789101112C:\Users\10287&gt;adb shell pm list packages|findstr browserpackage:com.android.browserC:\Users\10287&gt;adb shell pm dump com.android.browser | findstr version versionCode=22 targetSdk=22 versionName=5.1.1-500200323C:\Users\10287&gt;adb shell pm dump com.android.chrome | findstr version versionCode=398713200 targetSdk=29 versionName=80.0.3987.132 enabled=true targetSdkVersion=29 versionCode=398713200 查看手机webview版本在手机上设置中查看 Android System WebView应用版本 客户端代码 desirecapability “chromedriverExecutable” = “指定driver地址” “browser” = “Browser” 或者“browser” = ”Chrome“ WebView元素定位1、连接手机/模拟器 手机打开google浏览器，并进入百度网页：https://m.baidu.com 2、Chrome浏览器输入地址： chrome://inspect 可以看到电脑连接的设备名以及打开的手机浏览器 点击inspect 这样就可以定位到浏览器元素。 Android混合页面测试文档：https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews?hl=zh-cn 测试步骤： 打开ApiDemos 进入WebView页面 点击”i am a link” 退出应用 下载ApiDemos-debug.apk https://github.com/appium/appium/blob/master/sample-code/apps/ApiDemos-debug.apk 123456789101112131415161718192021222324252627282930313233from appium import webdriverfrom appium.webdriver.common.mobileby import MobileByclass TestBrowser(): def setup(self): desired_caps = &#123; &#x27;platformName&#x27;: &#x27;android&#x27;, &#x27;platformVersion&#x27;: &#x27;10&#x27;, &#x27;appPackage&#x27;: &#x27;io.appium.android.apis&#x27;, &#x27;appActivity&#x27;: &#x27;io.appium.android.apis.ApiDemos&#x27;, &#x27;deviceName&#x27;: &#x27;CUYDU19626004019&#x27;, &#x27;noReset&#x27;: &#x27;true&#x27;, &#x27;chromedriverExecutable&#x27;: &#x27;D:/testing_tools/chromedriver85/chromedriver.exe&#x27; &#125; self.driver = webdriver.Remote(&#x27;http://127.0.0.1:4723/wd/hub&#x27;, desired_caps) self.driver.implicitly_wait(5) def teardown(self): self.driver.quit() def test_webview(self): self.driver.find_element_by_accessibility_id(&quot;Views&quot;).click() webview =&quot;WebView&quot; print(self.driver.contexts) self.driver.find_element_by_android_uiautomator(&#x27;new UiScrollable(new UiSelector().&#x27; &#x27;scrollable(true).instance(0)).&#x27; f&#x27;scrollIntoView(new UiSelector().text(&quot;&#123;webview&#125;&quot;)&#x27; &#x27;.instance(0));&#x27;).click() print(self.driver.contexts) self.driver.switch_to.context(self.driver.contexts[1]) print(self.driver.current_context) self.driver.find_element(MobileBy.ID, &#x27;i am a link&#x27;).click() --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App自动化测试 | Appium元素定位（二）]]></title>
    <url>%2Fposts%2Fappium-locator-uiautomator%2F</url>
    <content type="text"><![CDATA[UiAutomator定位用于Android APP的元素定位，使用UI Automator API（UISelector类）来搜索特定元素。 Appium将Java代码作为字符串发送到服务器实现对应用程序的交互。UiAutomator是android的工作引擎，所以定位速度快。缺点是语法表达式复杂，容易写错。 可参考官方文档：https://developer.android.com/reference/android/support/test/uiautomator/UiSelector 下面将介绍UiSelector类一些常用接口使用方法。 uiautomator定位方式通过 resource-id定位 new UiSelector().resourceld(&quot;id&quot;)通过 classname定位 new UiSelector().className(&quot;className&quot;)通过 content-desc定位 new UiSelector().description(&quot;contenet-desc属性&quot;)通过文本定位 text文本定位 new UiSelector().text(&quot;text文本&quot;) textContains 模糊匹配 new UiSelector().textContains(&quot;包含text文本&quot;) textStartsWith，以某个文本开头来匹配 new UiSelector().textStartsWith(&quot;以text文本开头&quot;) 正则表达式 textMatches 匹配 new UiSelector().textMatches(&quot;正则表达式&quot;)组合定位 id与text属性组合 12id_text = &#x27;resourceld(&quot;com.baidu.yuedu:id/webbooktitle&quot;).text(&quot;textname&quot;)&#x27;driver.find_element_by_android_uiautomator(id_text).click() class与text属性组合 12class_text=&#x27;className(&quot;android.widget.TextView&quot;).text(&quot;textname&quot;)&#x27;driver.find_element_by_android_uiautomator(class_text).click() 父子元素、兄弟元素定位父子关系定位 childSelector通过父元素找儿子元素1son = &#x27;resourceld(&quot;com.baidu.yuedu:id/rl_tabs&quot;).childSelector(text(&quot;股票&quot;))&#x27; 兄弟定位 fromParent通过相邻的兄弟元素定位，通过兄弟元素，找到同一父级元素下的子元素1brother = &#x27;resourceld(&quot;com.baidu.yuedu:id/lefttitle&quot;).fromParent(text(&quot;用户&quot;))&#x27; 滚动查找元素1&#x27;new UiScrollable(new UiSelector().scrollable(true).instance(0)).scrollIntoView(newUiSelector().text(&quot;查找的文本&quot;).instance(0));&#x27; uiautomator定位实例跟 App自动化测试 | Appium元素定位（一）的测试过程一样，判断股票价格测试过程： 打开雪球app 点击搜索框 输入”招商银行” 选择 获取股价，并判断 1234567891011121314151617181920212223242526272829303132333435import pytestfrom appium import webdriverclass TestUiautomator: def setup(self): desired_caps = &#123;&#125; desired_caps[&#x27;platformName&#x27;] = &#x27;Android&#x27; desired_caps[&#x27;platformVersion&#x27;] = &#x27;6.0.1&#x27; desired_caps[&#x27;deviceName&#x27;] = &#x27;127.0.0.1:7555&#x27; desired_caps[&#x27;appPackage&#x27;] = &#x27;com.xueqiu.android&#x27; desired_caps[&#x27;automationName&#x27;] = &#x27;Uiautomator2&#x27; desired_caps[&#x27;appActivity&#x27;] = &#x27;com.xueqiu.android.common.MainActivity&#x27; desired_caps[&#x27;newCommandTimeout&#x27;] = 3000 desired_caps[&#x27;noReset&#x27;] = True desired_caps[&#x27;dontStopAppOnReset&#x27;] = True desired_caps[&#x27;skipDeviceInitialization&#x27;] = True desired_caps[&#x27;unicodeKeyboard&#x27;] = True desired_caps[&#x27;resetKeybBoard&#x27;] = True self.driver = webdriver.Remote(&#x27;http://127.0.0.1:4723/wd/hub&#x27;, desired_caps) self.driver.implicitly_wait(15) def teardown_method(self): self.driver.quit() def test_search(self, searchkey, type, price): self.driver.find_element_by_android_uiautomator( &#x27;new UiSelector().resourceId(&quot;com.xueqiu.android:id/tv_search&quot;)&#x27;).click() self.driver.find_element_by_android_uiautomator( &#x27;new UiSelector().resourceId(&quot;com.xueqiu.android:id/search_input_text&quot;)&#x27;).send_keys(&quot;招商银行&quot;) self.driver.find_element_by_android_uiautomator(&#x27;new UiSelector().text(&quot;SH600036&quot;)&#x27;).click() self.driver.find_element_by_android_uiautomator(&#x27;new UiSelector().text(&quot;SH600036&quot;)&#x27;).click() current_price = self.driver.find_element_by_android_uiautomator( &#x27;new UiSelector().resourceId(&quot;com.xueqiu.android:id/stock_current_price&quot;)&#x27;).text print(current_price) assert float(current_price) &gt; 40 执行结果： --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>元素定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App自动化测试 | Appium元素定位（一）]]></title>
    <url>%2Fposts%2Fappium-locator%2F</url>
    <content type="text"><![CDATA[APP元素定位方式与Web元素定位方式大体相同，APP自动化测试中最重要的一部分是对元素进行定位，实现对APP的控制交互。Appium常用的定位方式有Accessibility ID、Class name、ID、Name、XPath、Android UiAutomator（UiAutomator2)等。 ID定位使用resource-id属性定位，iOS中使用name属性。12elem = driver.find_element_by_id(&quot;com.xueqiu.android:id/enter_stock_fund&quot;)elem = driver.find_element(MobileBy.ID,&quot;com.xueqiu.android:id/enter_stock_fund&quot;) Accessibility ID定位在写Android和iOS自动化测试用例时，可以使用这种定位方法，使代码可重用， 实现跨平台自动化测试。iOS的Accessibility ID为UI元素的名称， Android的Accessibility ID为“ content-desc”属性值。12elem = driver.find_element_by_accessibility_id(&quot;Accessibility&quot;)elem = driver.find_element(MobileBy.ACCESSIBILITY_ID,&quot;Accessibility&quot;) Class name定位使用控件的class属性12elem = driver.find_element_by_class_name(&quot;classname&quot;)elem = driver.find_element(MobileBy.CLASS_NAME,&quot;classname&quot;) Xpath定位APP Xpath定位与Web元素Xpath定位一样，Xpath定位语法可参考文章 Web自动化测试 | xpath &amp; CSS Selector定位，可以通过父结点定位子结点、子结点定位父结点、子结点定位兄弟结点、 爷爷结点定位孙子结点。Xpath定位语法参考：https://www.w3school.com.cn/xpath/xpath_syntax.asp 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 点击雪球APP “行情”12elem = driver.find_element_by_xpath(&#x27;//*[@text=&quot;行情&quot;]&#x27;).click()elem.click() Toast定位toast介绍 Toast是手机应用消息提示框，为当前视图显示一个浮动弹出框 Toast类的思想：尽可能不引人注意，同时还向用户显示信息，希望他们看到 Toast显示的时间有限, Toast会根据用户设置的显示时间后自动消失。 Toast本身是个系统级别的控件，它归属于系统 settings，当一个app发送消息的时候，不是自己造出来的这个弹框，它是发给系统，由系统统一进行弹框，这类的控件不在app内，需要特殊的控件识别方法。 Appium使用 uiautomator底层的机制来分析抓取 Toast，并且把 Toast放到控件树里面，但本身并不属于控件。 必须使用 xpath查找 //*[@class=’android.widget.Toast’] //*[contains(@text, “xxxxx”)]toast定位 测试步骤： 打开ApiDemos 进入Popup Menu页面 点击”search” 打印弹出toast内容 1234567891011121314151617181920212223242526from appium import webdriverfrom appium.webdriver.common.mobileby import MobileByclass TestToast(): # API Demos def setup(self): desired_caps = &#123; &#x27;platformName&#x27;: &#x27;android&#x27;, &#x27;platformVersion&#x27;: &#x27;6.0.1&#x27;, &#x27;deviceName&#x27;: &#x27;127.0.0.1:7555&#x27;, &#x27;appPackage&#x27;: &#x27;io.appium.android.apis&#x27;, &#x27;appActivity&#x27;: &#x27;io.appium.android.apis.view.PopupMenu1&#x27;, &#x27;automationName&#x27;: &#x27;Uiautomator2&#x27; &#125; self.driver = webdriver.Remote(&#x27;http://127.0.0.1:4723/wd/hub&#x27;, desired_caps) self.driver.implicitly_wait(5) def teardown(self): self.driver.quit() def test_toast(self): self.driver.find_element_by_class_name(&quot;android.widget.Button&quot;).click() self.driver.find_element_by_xpath(&quot;//*[@text=&#x27;Search&#x27;]&quot;).click() # print(self.driver.page_source) print(self.driver.find_element(MobileBy.XPATH, &quot;//*[contains(@text,&#x27;Clicked popup&#x27;)]&quot;).text) 结果： 12345678910111213141516Launching pytest with arguments test_toast.py::TestToast::test_toast in D:\ProgramWorkspace\TestingDemo\test_appium============================= test session starts =============================platform win32 -- Python 3.7.6, pytest-6.0.2, py-1.9.0, pluggy-0.13.1 -- D:\Anaconda3\python.execachedir: .pytest_cachehypothesis profile &#x27;default&#x27; -&gt; database=DirectoryBasedExampleDatabase(&#x27;D:\\ProgramWorkspace\\TestingDemo\\test_appium\\.hypothesis\\examples&#x27;)rootdir: D:\ProgramWorkspace\TestingDemo\test_appiumplugins: allure-pytest-2.8.12, hypothesis-5.5.4, arraydiff-0.3, assume-2.3.2, astropy-header-0.1.2, doctestplus-0.5.0, openfiles-0.4.0, remotedata-0.3.2, rerunfailures-9.1collecting ... collected 1 itemtest_toast.py::TestToast::test_toast ============================= 1 passed in 37.07s ==============================Process finished with exit code 0PASSED [100%]Clicked popup menu item Search APP自动化测试实例测试过程： 打开雪球app 点击搜索框 输入”招商银行” 选择 获取股价，并判断 Note： 实例使用的是网易mumu浏览器，开启后，使用adb命令：adb connect 127.0.0.1:7555 连接模拟器 执行代码前需要开启appium服务器 python代码： 1234567891011121314151617181920212223242526272829303132import pytestfrom appium import webdriverclass TestXueQiu: def setup(self): desired_caps = &#123;&#125; desired_caps[&#x27;platformName&#x27;] = &#x27;Android&#x27; desired_caps[&#x27;platformVersion&#x27;] = &#x27;6.0.1&#x27; desired_caps[&#x27;deviceName&#x27;] = &#x27;127.0.0.1:7555&#x27; desired_caps[&#x27;appPackage&#x27;] = &#x27;com.xueqiu.android&#x27; desired_caps[&#x27;automationName&#x27;] = &#x27;Uiautomator2&#x27; desired_caps[&#x27;appActivity&#x27;] = &#x27;com.xueqiu.android.common.MainActivity&#x27; desired_caps[&#x27;newCommandTimeout&#x27;] = 3000 desired_caps[&#x27;noReset&#x27;] = True desired_caps[&#x27;dontStopAppOnReset&#x27;] = True desired_caps[&#x27;skipDeviceInitialization&#x27;] = True desired_caps[&#x27;unicodeKeyboard&#x27;] = True desired_caps[&#x27;resetKeybBoard&#x27;] = True self.driver = webdriver.Remote(&#x27;http://127.0.0.1:4723/wd/hub&#x27;, desired_caps) self.driver.implicitly_wait(15) def teardown_method(self): self.driver.quit() def test_search(self, searchkey, type, price): self.driver.find_element_by_id(&quot;com.xueqiu.android:id/tv_search&quot;).click() self.driver.find_element_by_id(&quot;com.xueqiu.android:id/search_input_text&quot;).send_keys(&quot;招商银行&quot;) current_price = self.driver.find_element_by_xpath(&quot;//*[@text=&#x27;SH600036&#x27;]&quot;).click() current_price = self.driver.find_element_by_xpath( &quot;//*[@text=&#x27;SH600036&#x27;]/../../..//*[@resource-id=&#x27;com.xueqiu.android:id/current_price&#x27;]&quot;).text print(current_price) assert float(current_price) &gt; 40 执行结果：]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>元素定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App自动化测试 | App控件定位]]></title>
    <url>%2Fposts%2Fappium-android-controls%2F</url>
    <content type="text"><![CDATA[本文将分享Android相关基础知识和Android APP控件定位工具的使用方法。 Android基础知识Android布局Android是通过容器的布局属性来管理子控件的位置关系（iOS去掉了布局的概念，直接用变量之间的相对关系完成位置的计算），把界面上所有的控件根据他们的间距的大小，摆放在正确的位置。布局是一种可用于放置很多控件的容器，通过多层布局嵌套完成一些比较复杂的界面。 Android布局有LinearLayout(线性布局)、RelativeLayout(相对布局)、FrameLayout(帧布局)、AbsoluteLayout(绝对布局)、TableLayout(表格布局)、Grid layout(网格布局)、ConstraintLayout(约束布局)等。布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套，我们就能够完成一些比较复杂的界面。 Android四大组件Android四大基本组件分别是Activity，Service服务，Content Provider内容提供者，Broadcast Receiver广播接收器。 1、activity 与用户交互的可视化界面 一个Activity通常就是一个单独的屏幕（窗口） Activity之间通过Intent进行通信 2、Service service 实现后台运行程序，在后台完成用户指定的操作 通常用于为其他组件提供后台服务或监控其他组件的运行状态。3、Content Provider content provider 内容提供者，提供程序所需要的数据 只有需要在多个应用程序间共享数据才需要内容提供者，是不同应用程序间共享数据的唯一方式。4、Broadcast Receiver 监听外部事件的到来(比如来电)Android控件 常用的控件： TextView(文本控件)，EditText(可编辑文本控件) Button(按钮)，imageButton(图片按钮)，ToggIeButton(开关按钮) Image View(图片控件) CheckBox(复选框控件), RadioButton(单选框控件) 元素定位实际上就是定位控件，Android应用的层级结构使用xml编写，xml全名叫可扩展标记语言，类似于HTML，可以看作一个微型的数据库。android系统里安装的每一个app，其信息都被存到一个xml里。 xml定义了节点和属性，每个控件都有它的属性(resourceid, xpath, aid)，没有css属性（样式文件和布局xml文件是分开的）。 Android中提供了三种解析XML的方式：DOM(Document Object Model)、SAX(Simple API XML)以及Pull解析方式。DOM解析器在解析XML文档时，会把文档中的所有元素按照其出现的层次关系，解析成一个个Node对象(节点)，形成Dom树。DOM允许用户遍历文档树，访问父节点、子节点或者兄弟节点。每个节点具有特定的属性： clickable content-desc resource-id text bounds … App控件定位对App控件的定位其实就是节点和属性的定位，Android App推荐使用uiautomatorviewer工具进行定位，它是 sdk路径下的一个工具。也可以用Appium inspector工具来定位。 https://github.com/appium/appium/blob/master/sample-code/apps/ApiDemos-debug.apk uiautomatorviewer定位电脑通过无线或者USB连接到手机设备后（或者连接到模拟机），双击uiautomatorviewer.bat打开uiautomatorviewer工具。 点击左上角第二个或者第三个图标获取当前手机APP页面，在右边可以看到app的xml结构树，可以获取到每个节点的详细属性。 Appium inspector工具打开appium，点击【启动服务器】 点击右上角搜索标志图标【Start Inspector Session】 编辑Desired Capabilities Capability设置： platformName：Android或者iOS deviceName：设备名，127.0.0.1:7555是网易mumu模拟器，开启后需要使用adb命令adb connect 127.0.0.1:7555连接。 appPackage：包名 appActivity：Activity名字 platformVersion：系统版本 automationName：默认使用 uiautomator2(andorid默认使用 uiautomator2，ios默认使用 XCUITest) noReset：是否在测试前后重置相关环境(例如首次打开弹框,或者是登录信息) unicodeKeyBoard：是否需要输入非英文之外的语言并在测试完成后重置输入法 dontStopAppOnReset：首次启动的时候,不停止app(可以调试或者运行的时候提升运行速度) skipDeviceInitialization：跳过安装,权限设置等操作(可以调试或者运行的时候提升运行速度) 其他更多参数参考官方文档：https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md 主要设置好前面6个参数后，点击右下角【Start Session】，可以获取到每个节点的详细属性。 用例录制appium desktop可以录制用例，并生成测试代码 点击上方眼睛图标，开始录制，手动点击左边app元素，右边显示了三种元素操作方法：Tap、Send Keys、Clear，选择对应的操作 完成后测试步骤后，点击停止录制，右上角可以看到生成的自动化代码，可以选择Java，Python等语言。 获取到app页面元素属性值后就可以使用appium来进行定位，实现对app的操作。下一篇文章将介绍appium元素定位方法。 Python + Appium启动APPAPP自动化测试关键步骤包括： 导入依赖: from appium import webdriver capabilities设置 初始化 driver webdriver.remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps) 元素定位与操作 断言 assert 下面代码实现打开雪球APP，点击输入框，输入”京东“，然后退出。 123456789101112131415161718192021#!/usr/bin/python3# -*-coding:utf-8-*-from appium import webdriverdesired_caps = &#123;&#125;# desired_caps[&#x27;recreateChromeDriverSessions&#x27;] = Truedesired_caps[&#x27;platformName&#x27;] = &#x27;Android&#x27;desired_caps[&#x27;platformVersion&#x27;] = &#x27;5.1.1&#x27;desired_caps[&#x27;deviceName&#x27;] = &#x27;127.0.0.1:7555&#x27;desired_caps[&#x27;appPackage&#x27;] = &#x27;com.xueqiu.android&#x27;desired_caps[&#x27;automationName&#x27;] = &#x27;Uiautomator2&#x27;desired_caps[&#x27;appActivity&#x27;] = &#x27;.common.MainActivity&#x27;desired_caps[&#x27;newCommandTimeout&#x27;] = 3000desired_caps[&#x27;unicodeKeyboard&#x27;] = Truedesired_caps[&#x27;noReset&#x27;] = &#x27;true&#x27;desired_caps[&#x27;dontStopAppOnReset&#x27;] = &#x27;true&#x27;desired_caps[&#x27;skipDeviceInitialization&#x27;] = &#x27;true&#x27;driver = webdriver.Remote(&#x27;http://127.0.0.1:4723/wd/hub&#x27;, desired_caps)driver.implicitly_wait(15)driver.find_element_by_id(&quot;com.xueqiu.android:id/tv_search&quot;).click()driver.find_element_by_id(&quot;com.xueqiu.android:id/search_input_text&quot;).send_keys(&quot;京东&quot;)driver.quit()]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App自动化测试 | Appium 介绍及环境安装]]></title>
    <url>%2Fposts%2Fappium-install-and-architecture%2F</url>
    <content type="text"><![CDATA[Appium是一个可用于测试iOS、 Android操作系统和Windows桌面平台原生应用，移动网页应用和混合应用的自动化测试框架。 原生应用（Native App）：用 android、iOS或者Windows SDK编写的应用 移动网页应用（Web App）：通过手机浏览器访问的网页应用，比如iOS中 safari应用，Android上的Chrome应用或者内置浏览器应用，不会占用手机的存储空间。 混合应用（Hybrid App）：同时具备Native App和Web App的特性，一种 webview应用，将Javascript，HTML和CSS执行在embedded webview中，外层用Native App wrapper包起來。 Appium 跨语言支持：Java、 Python、 Ruby、JavaScript (Node.js)、PHP、C# (.NET)、RobotFramework等，Appium是跨平台的，可以用在OSX，Windows以及Linux桌面系统上运行。 Appium架构 WebDriverSelenium Webdriver API实现脚本语言与浏览器之间的通信，可参考Selenium Webdriver 架构。 Webdriver定义的JSON Wire Protocol（JSON有线协议）实现selenium客户端与remote server（浏览器驱动的HTTP服务器）的交互，remote server将命令发送给浏览器，实现浏览器的native调用。 Appium WebDriver对Selenium Webdriver协议进行了扩展（Mobile JSON Wire Protocol），Appium 客户端通过Webdriver协议与Appium Server进行交互。 Appium引擎列表为了不重新编译或修改应用，Appium 使用系统自带的自动化框架：Android 4.3+ * UIAutomator * UIAutomator2[推荐] iOS * UIAutomation (iOS ≤ 9.3) * XCUITest[推荐] (iOS ≥ 9.3) Windows: * WinAppDriver Appium的设计理念Client/Server设计模式Appium采用 C/S架构，Appium与客户端建立连接并监听命令，然后在移动设备上执行这些命令，命令执行结果通过 HTTP 响应的方式返回。客户端通过 WebDriver json wire协议与服务端通讯。由于Appium的这种特性，我们可以将Appium server放在与测试机不同的机器上。Appium Server是使用 Node.js 编写的HTTP服务。 session 会话Appium自动化执行时会首先拉起一个session会话，客户端和服务器之间初始化一个session，通过发送一个POST /session建立连接，客户端的post请求中携带一个称为 ‘desired capabilities‘ 的JSON对象，定义设备平台（iOS或Android）、版本、server地址等请求字段，后面的文章将详细介绍。服务器接收到请求后会建立一个session并回应一个session ID，建立好连接后就可以发送命令了。 Appium ClientsAppium支持多语言，包括Java, Ruby, Python, PHP, JavaScript, 和 C#，这些客户端库支持WebDriver 协议扩展。 语言/框架 Github仓库地址 Ruby https://github.com/appium/ruby_lib, https://github.com/appium/ruby_lib_core Python https://github.com/appium/python-client Java https://github.com/appium/java-client JavaScript (Node.js) https://github.com/admc/wd JavaScript (Node.js) https://github.com/webdriverio/webdriverio JavaScript (Browser) https://github.com/projectxyzio/web2driver Objective C https://github.com/appium/selenium-objective-c PHP https://github.com/appium/php-client C# (.NET) https://github.com/appium/appium-dotnet-driver RobotFramework https://github.com/serhatbolsu/robotframework-appiumlibrary Appium工作原理 首先开启Appium server，它会默认监听4723端口 appium客户端（测试脚本）基于Json wire protocol发送设备信息给Appium server，请求创建session。其中设备信息放在desired capabilities中，包括系统平台，版本，应用等信息（详细介绍参考App控件定位）。session用于保存设备配置信息。 Appium server创建session id并返回给client：appium server调用AndroidDriver为client生成一个session并且生成一个与此session相关联的session id，作为client与server之间通信的唯一标识。 开启bootstrap socket服务器：Appium在初始化时将中间件Bootstrap.jar推送到设备，bootstrap是uiautomator的测试脚本，继承于UiautomatorTestCase。手机端通过该脚本监听端口4724，appium server作为socket-client端通过4724端口将请求发送给socket服务器（bootstrap.jar），然后bootstrap将appium命令转换成uiautomator命令。 连接建立完成后，Appium client基于Json wire protocol通过4723端口将指令发送给Appium server，Appium server（socket-client）通过4724端口转发给中间件bootstrap.jar（socket-server），bootstrap.jar将请求转换成UiAutomator可以识别的命令，发给UiAutomator对设备进行操作。执行完操作后将执行的结果返回给Appium server，Appium server返回给Appium客户端，客户端对结果做校验。 Appium生态工具 adb：android的控制工具，用于获取 android的各种数据和控制 Appium Desktop：内嵌了 appium server和inspector的综合工具 Appium Server：appium的核心工具，命令行工具 Appium client：各种语言的客户端封装库，用于连接 appium server AppCrawler：自动遍历工具 appium使用 appium-xcuitest-driver来测试iPhone设备,其中需要安装 facebook开发的WDA(webdriver agent)来驱动iOS测试，下面介绍Android APP测试环境安装。 Appium环境安装 Java1.8版本 Android sdk Node.js(&gt;=10 版本)，npm(&gt;=6 版本) Python3 Appium-desktop Appium python client 1、安装Node.js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 是运行在服务端的 JavaScript https://nodejs.org/en/download/) 命令行窗口中运行node -v 查看是否安装成功 2、安装jdkjdk下载下载地址：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 按照默认路径安装配置环境变量“我的电脑”右键菜单—-&gt;属性—-&gt;高级—-&gt;环境变量—-&gt;系统变量—&gt;新建 变量名：JAVA_HOME变量值：C:\Program Files (x86)\Java\jdk1.8.0_144 变量名：CALSS_PATH变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 找到path变量名—&gt;“编辑”添加： 变量名：PATH变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 查看是否安装成功：java -version 3. 安装Android SDKAndroid SDK是Google提供的Android开发工具包，在开发Android应用的时候会用到，需要通过引入工具包来调用Android的API 下载地址：https://developer.android.com/中文社区的SDK下载地址：http://tools.android-studio.org/index.php/sdk 双击打开SDK Manage.exe，安装API版本和对应的工具包，这些在运行模拟器和真机测试的时候会使用到。 配置环境变量新建环境变量ANDROID_HOME，变量值为sdk的路径：E:\Android\android-sdk “我的电脑”右键菜单—-&gt;属性—-&gt;高级—-&gt;环境变量—-&gt;系统变量—&gt;新建 变量名：ANDROID_HOME变量值：D:\android\android-sdk-windows 找到环境变量path—&gt;“编辑”添加： 变量名：PATH 变量值：;% ANDROID_HOME%\platform-tools; 变量值：% ANDROID_HOME%\build-tools; 变量值：% ANDROID_HOME%\tools; tools目录下运行android命令，platform-tools目录运行adb命令 检验Android SDK是否安装成功：adb version 4. 安装Appium下载地址：https://bitbucket.org/appium/appium.app/downloads/?tab=downloads 安装完成后添加到环境变量 把安装的appium文件夹的Appium\node_modules.bin加到系统环境变量path中 运行appium-doctor，检测appium运行环境的工具 5. 安装appium-desktop下载地址：https://github.com/appium/appium-desktop/releases/tag/v1.15.1 6. 下载Appium-Python-Client下载链接：https://pypi.org/project/Appium-Python-Client/运行python setup.py install安装 或者运行 pip install Appium-Python-Client 安装。]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytest测试框架（四）：pytest 参数化用例]]></title>
    <url>%2Fposts%2Fpytest-parametrize%2F</url>
    <content type="text"><![CDATA[在 Pytest测试框架（三）：pytest fixture 用法 中介绍了pytest.fixture()可以参数化fixture函数，@pytest.mark.parametrize 可以为测试方法或者测试类定义多组变量。本文将分享使用@pytest.mark.parametrize 实现参数化用例。 使用方法@pytest.mark.parametrize(argnames, argvalues) argnames：参数化变量名，可以是string(逗号分割) 、list 和 tuple类型 @pytest.mark.parametrize(“a, b”, [(1,2),(3,4)]) @pytest.mark.parametrize([“a”,”b”], [(1,2),(3, 4)]) @pytest.mark.parametrize((“a”, “b”), [(1,2),(3,4)]) argvalues：参数化的值 参数化实例11234567import pytestclass Test_Demo(): @pytest.mark.parametrize(&quot;a, b, result&quot;, [(1, 1, 2), (2, 8, 10)]) def test_case1(self, a, b, result): print(&quot;\n开始执行测试用例1&quot;) assert a + b == result 结果： 1234PASSED [ 50%]开始执行测试用例1PASSED [100%]开始执行测试用例1 参数化实例2123456789101112131415import pytestdata = [(1, 1, 2), (2, 8, 10), (99, 1, 100) ]class Test_Demo(): @pytest.mark.parametrize(&quot;a, b, result&quot;, data) def test_case1(self, a, b, result): print(&quot;\n开始执行测试用例1&quot;) assert a + b == resultif __name__ == &#x27;__main__&#x27;: pytest.main() 结果： 123456PASSED [ 33%]开始执行测试用例1PASSED [ 66%]开始执行测试用例1PASSED [100%]开始执行测试用例1 参数化实例3data.yaml文件内容： 123456789101112- - 1 - 1 - 2- - 2 - 8 - 10- - 99 - 1 - 100 123456789import pytestimport yamlclass Test_Demo(): @pytest.mark.parametrize([&quot;a&quot;,&quot;b&quot;,&quot;result&quot;],yaml.safe_load(open(&quot;./data.yaml&quot;))) def test_case1(self, a, b, result): print(&quot;\n开始执行测试用例1&quot;) assert a + b == result 结果： 123456PASSED [ 33%]开始执行测试用例1PASSED [ 66%]开始执行测试用例1PASSED [100%]开始执行测试用例1 数据驱动数据驱动参数化的应用，数据量小的测试用例可以使用代码的参数化来实现数据驱动，数据量大的情况下可以使用一种结构化的文件(例如csv、yaml、xml、db、 excel、json等)来存储数据，然后在测试用例中读取这些数据。]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试框架</category>
      </categories>
      <tags>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App自动化测试 | Appium控件交互]]></title>
    <url>%2Fposts%2Fappium-locator-operate%2F</url>
    <content type="text"><![CDATA[与Web元素操作一样（Web自动化测试 | 元素操作），定位到APP控件元素后，可以对控件进行一系列的操作，实现与APP就交互，比如点击、文本输入、元素属性获取等。 元素操作元素常用操作方法 点击方法 element.click() 输入操作 element.send_keys(“appium”) 设置元素的值 element.set_value(“appium”) 清除操作 element.clear() Python测试实例安装ApiDemos-debug.apk，下载地址：https://github.com/appium/appium/blob/master/sample-code/apps/ApiDemos-debug.apk 点击Views 滑动选择并点击TextFields 输入文本“appium” 清除文本 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3#-*-coding:utf-8-*-import pytestfrom appium import webdriverfrom appium.webdriver.common.mobileby import MobileByclass TestLocator: def setup(self): desired_caps = &#123;&#125; desired_caps[&#x27;platformName&#x27;] = &#x27;Android&#x27; desired_caps[&#x27;platformVersion&#x27;] = &#x27;6.0.1&#x27; desired_caps[&#x27;deviceName&#x27;] = &#x27;127.0.0.1:7555&#x27; desired_caps[&#x27;appPackage&#x27;] = &#x27;io.appium.android.apis&#x27; desired_caps[&#x27;appActivity&#x27;] = &#x27;.ApiDemos&#x27; desired_caps[&#x27;automationName&#x27;] = &#x27;Uiautomator2&#x27; desired_caps[&#x27;newCommandTimeout&#x27;] = 3000 desired_caps[&#x27;noReset&#x27;] = True desired_caps[&#x27;dontStopAppOnReset&#x27;] = True desired_caps[&#x27;skipDeviceInitialization&#x27;] = True desired_caps[&#x27;unicodeKeyboard&#x27;] = True desired_caps[&#x27;resetKeybBoard&#x27;] = True self.driver = webdriver.Remote(&#x27;http://127.0.0.1:4723/wd/hub&#x27;, desired_caps) self.driver.implicitly_wait(5) def teardown_method(self): self.driver.quit() def test_locator(self): self.driver.find_element_by_xpath(&#x27;//*[@text=&quot;Views&quot;]&#x27;).click() self.driver.find_element_by_android_uiautomator( &#x27;new UiScrollable(new UiSelector().scrollable(true).instance(0)).scrollIntoView(new UiSelector().text(&quot;TextFields&quot;).instance(0));&#x27;).click() elem = self.driver.find_element(MobileBy.ID, &quot;io.appium.android.apis:id/edit&quot;) elem.send_keys(&quot;appium&quot;) elem.clear() 元素属性 获取属性值：get_attribute(name) 获取元素文本：element.text 获取元素坐标：element.location 获取元素尺寸(高和宽): element.size 是否可见 element.is_displayed 返回True/False 是否可用 element.is_enabled 返回True/False 是否被选中 element.is_selected 返回True/False get_attribute()方法get_attribute()方法能获取的属性，元素的属性几乎都能获取到。属性名称和uiautomatorviewer里面的一致。 字符串类型： text：返回 text resource-id：返回 resource-id， API=&gt;18 class：返回 class， API=&gt;18 content-desc：返回 content-desc属性 bounds 布尔类型： checkable checked clickable enabled focusable focused scrollable long-clickable password selected displayed 注意：有些属性展示在 uiautomatorviewer里，但是不能通过get_attribute获取，比如: index。 属性获取实例获取“App”的属性值123456789101112131415161718192021222324252627282930313233343536373839404142434445from appium import webdriverfrom appium.webdriver.common.mobileby import MobileByclass TestGetAttribute: def setup(self): desired_caps = &#123;&#125; desired_caps[&#x27;platformName&#x27;] = &#x27;Android&#x27; desired_caps[&#x27;platformVersion&#x27;] = &#x27;6.0.1&#x27; desired_caps[&#x27;deviceName&#x27;] = &#x27;127.0.0.1:7555&#x27; desired_caps[&#x27;appPackage&#x27;] = &#x27;io.appium.android.apis&#x27; desired_caps[&#x27;appActivity&#x27;] = &#x27;.ApiDemos&#x27; desired_caps[&#x27;automationName&#x27;] = &#x27;Uiautomator2&#x27; desired_caps[&#x27;newCommandTimeout&#x27;] = 3000 desired_caps[&#x27;noReset&#x27;] = True desired_caps[&#x27;dontStopAppOnReset&#x27;] = True desired_caps[&#x27;skipDeviceInitialization&#x27;] = True desired_caps[&#x27;unicodeKeyboard&#x27;] = True desired_caps[&#x27;resetKeybBoard&#x27;] = True self.driver = webdriver.Remote(&#x27;http://127.0.0.1:4723/wd/hub&#x27;, desired_caps) self.driver.implicitly_wait(5) def teardown_method(self): self.driver.quit() def test_get_attribute(self): elem = self.driver.find_element_by_xpath(&#x27;//*[@text=&quot;App&quot;]&#x27;) print(&quot;text:&quot; + elem.get_attribute(&quot;text&quot;)) print(&quot;resource-id:&quot; + elem.get_attribute(&quot;resource-id&quot;)) print(&quot;class:&quot; + elem.get_attribute(&quot;class&quot;)) print(&quot;package:&quot; + elem.get_attribute(&quot;package&quot;)) print(&quot;content-desc:&quot; + elem.get_attribute(&quot;content-desc&quot;)) print(&quot;bounds:&quot; + elem.get_attribute(&quot;bounds&quot;)) print(&quot;checkable:&quot; + elem.get_attribute(&quot;checkable&quot;)) print(&quot;checked:&quot; + elem.get_attribute(&quot;checked&quot;)) print(&quot;clickable:&quot; + elem.get_attribute(&quot;clickable&quot;)) print(&quot;enabled:&quot; + elem.get_attribute(&quot;enabled&quot;)) print(&quot;password:&quot; + elem.get_attribute(&quot;password&quot;)) print(&quot;displayed:&quot; + elem.get_attribute(&quot;displayed&quot;)) print(&quot;######################&quot;) print(&quot;text:&quot; + elem.text) print(elem.location) print(elem.size) print(elem.is_displayed) print(elem.is_enabled) print(elem.is_selected)执行结果：12345678910111213141516171819text:Appresource-id:android:id/text1class:android.widget.TextViewpackage:io.appium.android.apiscontent-desc:Appbounds:[0,342][720,414]checkable:falsechecked:falseclickable:trueenabled:truepassword:falsedisplayed:true######################text:App&#123;&#x27;x&#x27;: 0, &#x27;y&#x27;: 342&#125;&#123;&#x27;height&#x27;: 72, &#x27;width&#x27;: 720&#125;&lt;bound method WebElement.is_displayed of &lt;appium.webdriver.webelement.WebElement (session=&quot;cceeee8f-ad89-4d00-ab4f-25b57de58ea5&quot;, element=&quot;a1443341-aad8-4814-8f9b-27ada3fe6f50&quot;)&gt;&gt;&lt;bound method WebElement.is_enabled of &lt;appium.webdriver.webelement.WebElement (session=&quot;cceeee8f-ad89-4d00-ab4f-25b57de58ea5&quot;, element=&quot;a1443341-aad8-4814-8f9b-27ada3fe6f50&quot;)&gt;&gt;&lt;bound method WebElement.is_selected of &lt;appium.webdriver.webelement.WebElement (session=&quot;cceeee8f-ad89-4d00-ab4f-25b57de58ea5&quot;, element=&quot;a1443341-aad8-4814-8f9b-27ada3fe6f50&quot;)&gt;&gt;]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>appium</tag>
        <tag>元素定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App自动化测试 | Android ADB原理及常用命令]]></title>
    <url>%2Fposts%2Fappium-adb%2F</url>
    <content type="text"><![CDATA[Android调试桥(ADB, Android Debug Bridge)是一个Android命令行工具，包含在SDK 平台工具包中，adb可以用于连接Android设备，或者模拟器，实现对设备的控制，比如安装和调试应用。和Appium一样，adb也是基于C/S架构实现的。 一、ADB运行原理adb分为三个部分：PC上的adb client，adb server和手机（也可能是PC上的模拟器）上的adb daemon。这是一个多多连接的设计。即一台PC可以连接多个手机，一台手机也可以连接多个PC。 Client本质上就是Shell，用来发送命令给Server。发送命令时，首先检测PC上有没有启动Server，如果没有Server，则自动启动一个Server，绑定 TCP 的 5037 端口，然后将命令发送到Server，并不关心命令发送过去以后会怎样。 ADB Server：运行在PC上的后台程序，目的是检测USB接口何时连接或者移除设备。ADB Server维护着一个“已连接的设备的链表”，并且为每一个设备标记了一个状态：offline，bootloader，recovery或者online；Server一直在做一些循环和等待，，监听从 clients 发来的命令，协调client和Server还有daemon之间的通信。 ADB Daemon：程序“adbd”作为一个后台进程在Android设备或模拟器系统中运行。它的作用是连接ADB服务器，并且为运行在主机上的客户端提供一些服务； Client和Server之间通过TCP/IP通信，Server侦听本机的5037端口，Client试图去连接这个端口。基于ADB的工具有 DDMS 、monkey 测试等 adb源码：https://android.googlesource.com/platform/system/core/+/refs/heads/android10-c2f2-release/adb/ 1netstat -nao | findstr 5037 二、ADB常用命令1. adb server启动和连接 启动 adb server 1adb start-server 停止 adb server 1adb kill-server 指定 adb server 的网络端口 1adb -P &lt;port&gt; start-server 在发送adb命令时，如果没有pc没有启动Server，则会自动启动一个Server，然后将命令发送到Server。 通过adb usb打开设备上的tcpip服务并绑定一个端口 12adb tcpip 5555adb -s 611DKBQC22SH2 tcpip 5555 # 设备在 5555 端口监听 TCP/IP 连接 无线连接要将 Android 设备与将运行 adb 的电脑连接到同一个局域网 ADB Client通过命令adb connect ip连接远程的终端 123adb connect 127.0.0.1:62001 #夜游神模拟器adb connect 127.0.0.1:7555 #网易mumu模拟器adb disconnect &lt;device-ip-address&gt; # 断开连接 USB连接开启Android 设备的开发者选项和 USB 调试模式 2. adb常用命令 以 root 权限运行 adbd 12adb root adb -s 611DKBQC22SH2 root 查看 adb 版本 1adb version 查看设备名称 1adb devices 重启手机 1adb reboot 查看appPackage和appActivity 12345678910111213141516171819# 1adb logcat | findstr -i displayed # 打印手机日志# 2adb shell dumpsys activity# 3C:\Users\admin&gt; adb shellroot@shamu:/ # dumpsys activity | grep kaoyan# 4adb shell dumpsys activity top# 5adb shell dumpsys activity|findstr mFocusedActivity # 进入APP，得到APP名# 6adb shell dumpsys window windows|findstr &quot;Current&quot;# 7adb shell pm list packages #所有应用列表adb shell pm list packages -s # 系统应用adb shell pm list packages -3 # 第三方应用adb shell pm list packages smart # 包名包含smart字符串的应用 安装卸载apk包模拟器可以直接把安装包拖入模拟器进行安装 adb安装卸载方法： 12345# 卸载adb uninstall 包名# 安装adb install app.apkadb install -r app.apk # 强制安装 3. adb 模拟控制手机拉起、停止Activityadb shell am start [options] ：调起 Activityadb shell am force-stop ： 强制停止应用1234adb shell am start -n com.tenda.smarthome.app/.activity.main.MainActivity # 打开smarthome APPadb shell am force-stop com.tenda.smarthome.app # 强制停止应用adb shell pm clear &lt;packagename&gt; # 清除应用数据与缓存adb shell am start -a android.intent.action.VIEW -d https://www.baidu.com # 打开网页 模拟按键adb shell input keyevent 模拟按键12345678910adb shell input keyevent 3 # 按下HOME 键adb shell input keyevent 4 # 按下返回键adb shell input keyevent 26 # 按下电源键adb shell input keyevent 82 # 按下菜单键adb shell input keyevent 223 # 熄灭屏幕adb shell input keyevent 224 # 点亮屏幕adb shell input keyevent 67 # 删除 文本框输入1adb shell input text &quot;text&quot; # 向文本框中输入文字，不支持中文 点击1adb shell input tap 458 573 根据坐标点击 滑动adb shell input swipe x：屏幕左到右 y：从上到下 左上角为0点-图像坐标系12345678910111213141516171819202122232425262728293031323334353637383940414243adb shell input swipe 550 1200 550 375 # 滑动解锁adb shell input swipe 700 200 100 200 # 左翻页adb shell input swipe 100 200 1000 200 # 右翻页````## 4. adb文件管理（同Linux）### 目录操作```bashC:\Users\DELL&gt;adb shellroot@M5:/data # su 提取到root权限，显示井号即可suroot@M5:/ # lsls@btmtkacdapiadbagps_supl...root@M5:/data # ls -lls -ldrwxrwx--- bluetooth net_bt 2019-03-01 14:26 @btmtkdrwxrwx--- system system 2019-03-01 14:26 acdapidrwx------ root root 2019-03-01 14:26 adbdrwxrwx--x gps system 2019-07-19 10:49 agps_supldrwxrwx--- system system 2019-03-01 14:26 amitdrwxrwxr-x system system 2019-07-22 09:13 anrdrwxrwx--x system system 2019-08-01 09:00 appdrwx------ root root 2019-03-01 14:26 app-asecroot@M5:/data # pwd 当前路径pwd/dataroot@M5:/data/system # cd - 切换到上次目录cd -/dataroot@M5:/data # cd .. 切换到上级目录cd ..2|root@M5:/ # cd d*a cd d*aroot@M5:/data # cd s*m 目录名较长时建议使用通配符&quot;*&quot;,如cd到system目录cd s*mroot@M5:/data/system # 文件操作（同Linux）123456789101112rm -r crash # 删除文件夹及内容rmdir # 文件夹 删文件夹rm # 文件 删文件cat filename # cat,more less显示文件内容cp /data/data/com.android.contacts/databases/contacts_app.db /mnt/sdcard/ # 复制mkdir # 创建目录du # 显示目录空间大小df # 显示磁盘空间大小touch test.txt # 创建文件ps # 显示进程top # 动态显示进程状态chmod 644 # 改变权限 退出CTRL+C 退出shell模式12root@M5:/mnt/sdcard # ^CC:\Users\DELL&gt;d: 手机和电脑文件传输 将手机文件pull到电脑 123D:\&gt;adb pull sdcard/cmcc_sso_config.dat # 将手机sdcard中的cmcc_sso_config.dat 文件copy到电脑D：根目录下D:\&gt;adb pull sdcard/cmcc_sso_config.dat D:\adbtestD:\&gt; 将电脑文件push到手机目录下D1234567891011121314D:\&gt;adb push D:/adbtest/cmcc_sso_config111.dat /sdcard/ # 将D:中的cmcc_sso_config111.dat copy到手机sdcard 文件夹下D:\&gt;adb shellroot@M5:/ # cd /mnt/sdcardcd /mnt/sdcardroot@M5:/mnt/sdcard # ls *cmcc_sso_config*ls *cmcc_sso_config*cmcc_sso_config.datcmcc_sso_config111.datroot@M5:/mnt/sdcard # find /data -name &quot;cmcc_sso_config*&quot;find /data -name &quot;cmcc_sso_config*&quot;/data/media/0/cmcc_sso_config.dat/data/media/0/cmcc_sso_config111.dat 5. 其它实用功能屏幕截图-截图保存到SD卡里再导出123D:\&gt;adb shell screencap -p /sdcard/screen.pngD:\&gt;adb pull /sdcard/screen.pngD:\&gt;adb shell rm /sdcard/screen.png 录制屏幕1234567D:\&gt;adb shell screenrecord /sdcard/filename22.mp4D:\&gt;adb pull /sdcard/filename22.mp4D:\&gt;adb shell rm /sdcard/filename22.mp4D:\&gt;adb shell screenrecord --time-limit 10 /sdcard/demo.mp4adb shell screenrecord --size 1280*720 /sdcard/demo.mp4adb shell screenrecord --bit-rate 6000000 /sdcard/demo.mp4 联网12345678910111213141516171819202122232425262728293031323334353637383940414243D:\&gt;adb shell svc wifi disable # 关闭WiFiD:\&gt;adb shell svc wifi enable # 开启WiFiD:\&gt;adb shell ping -w 3 8.8.8.8 # 查看是否能联网PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.--- 8.8.8.8 ping statistics ---1 packets transmitted, 0 received, 100% packet loss, time 0ms D:\&gt;adb shell cat /data/misc/wifi/*.conf # 查看连接过的 WiFi 密码.....device_name=meizu_M5manufacturer=Meizumodel_name=M611Dmodel_number=M611Dserial_number=611DKBQC22SH2device_type=10-0050F204-5os_version=01020300config_methods=physical_display virtual_push_buttonp2p_no_group_iface=1external_sim=1wowlan_triggers=disconnectnetwork=&#123; ssid=&quot;Plug_C415&quot; key_mgmt=NONE priority=1 flag=1&#125;network=&#123; ssid=&quot; &quot; key_mgmt=NONE priority=2 flag=1&#125;network=&#123; ssid=&quot;test&quot; psk=&quot;12345678&quot; key_mgmt=WPA-PSK priority=3 flag=1&#125; 切换飞行模式通过adb shell，输入命令，可以切换飞行模式开启飞行模式12adb shell settings put global airplane_mode_on 1adb shell am broadcast -a android.intent.action.AIRPLANE_MODE --ez state true关闭飞行模式12adb shell settings put global airplane_mode_on 0adb shell am broadcast -a android.intent.action.AIRPLANE_MODE --ez state false svc命令这个脚本在/system/bin目录下，可以用来控制电源管理，wifi开关，数据开关(就是上网流量)控制usb插入的时候屏幕是否常亮1svc power stayon [true|false|usb|ac]关闭数据连接（上网流量），这个命令不会更改app的任何设置，直接在底层关闭数据连接。1svc data disable打开上网数据连接1svc data enable控制3g数据连接比wifi优先。1svc data prefer关闭wifi 连接1svc wifi disable开启wifi连接1svc wifi enable设置wifi优先1svc wifi prefer上面的命令都要在shell中执行，需要root。可以用script ，然后输入这些命令做成在快捷方式放在桌面，跟那些开关软件一样方便使用。 安卓busyboxandroid busybox解决adbshell命令不全 安卓虽然是基于linux，但是精简了很多linux工具，很多常用的linux指令不能使用。busybox相当于一个打包的工具箱，打包了很多的常用的linux可执行文件和其依赖。安装了busybox你就可以在安卓下下载一个模拟终端然后在里面运行一些之前不能运行的指令。 wpa_spplicantwpa_supplicant本是开源项目源码，被谷歌修改后加入Android移动平台，它主要是用来支持WEP，WPA/WPA2和WAPI无线协议和加密认证的，控制漫游和无线驱动的IEEE 802.11 验证和关联。通过socket（不管是wpa_supplicant与上层还是wpa_supplicant与驱动都采用socket通讯）与驱动交互上报数据给用户，而用户可以通过socket发送命令给wpa_supplicant调动驱动来对WiFi芯片操作。 简单的说，wpa_supplicant就是WiFi驱动和用户的中转站外加对协议和加密认证的支持。 wpa_supplicant工具主要包含wpa_supplicant(命令行模式，属于服务端)与wpa_cli(交互模式，属于客户端)两个程序来达到无线认证连接。通过wpa_cli来进行WiFi的配置和连接，也可以直接调用wpa_supplicant接口实现网络控制。部分命令： 1234wpa_cli -i wlan0 scan \\扫描热点wpa_cli -i wlan0 scan_result \\打印热点信息wpa_cli -i wlan0 set_network 0 ssid &quot;wifi_name&quot; \\配置WiFi热点的名称ssidwpa_cli -i wlan0 set_network 0 psk &#x27;&quot;12345678&quot;&#x27; \\配置WiFi热点的密码psk 三、Python获取ADB返回结果12345cmd = &quot;adb shell pm list packages smarthome&quot;result = os.popen(cmd)f = result.read() #result只能读取一次if &quot;smarthome&quot; in f: print(f) ADB获取手机时间123456789def now_time_new(self): # now_time_new = datetime.datetime.now().strftime(&#x27;%H:%M&#x27;) # print &quot;now_time_new&quot;,self.now_time_new time_a=os.popen(&#x27;adb shell date &quot;+%Y-%m-%d+%H:%M:%S&quot;&#x27;) time_a=time_a.read() time_a=time_a.strip() dates=time_a.split(&#x27;+&#x27;)[0] times=time_a.split(&#x27;+&#x27;)[1] return (dates,times) --THE END--]]></content>
      <categories>
        <category>自动化测试</category>
        <category>App自动化测试</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytest测试框架（五）：pytest + allure生成测试报告]]></title>
    <url>%2Fposts%2Fpytest-allure-report%2F</url>
    <content type="text"><![CDATA[Allure 是一款轻量级、支持多语言的开源自动化测试报告生成框架，由Java语言开发，可以集成到 Jenkins。 pytest 测试框架支持Allure 报告生成。 pytest也可以生成junit格式的xml报告和HTML报告，命令如下：12pytest test_demo.py --junitxml=report.xmlpytest test_demo.py --html=report.html #需要安装插件：pip install pytest-htmlAllure 报告更加灵活美观，本文介绍如何使用pytest 生成 allure测试报告 环境安装安装allure allure包下载：https://github.com/allure-framework/allure2/releases 解压 -&gt; 进入bin目录 -&gt; 运行allure.bat, 把bin目录加入PATH环境变量 allure官网 : http://allure.qatools.ru/ allure文档 : https://docs.qameta.io/allure/# 安装 allure-pytest插件1pip install allure-pytest 生成Allure报告运行1pytest [测试文件] -s -q --alluredir=./result #--alluredir用于指定存储测试结果的路径) 查看测试报告方式一：直接打开默认浏览器展示报告 allure serve ./result/ 方式二：从结果生成报告 生成报告 allure generate ./result/ -o ./report/ --clean (覆盖路径加—clean) 打开报告 allure open -h 127.0.0.1 -p 8883 ./report/ 实例代码：https://docs.qameta.io/allure/#_pytest test_allure.py： 12345678910111213141516import pytestdef test_success(): &quot;&quot;&quot;this test succeeds&quot;&quot;&quot; assert Truedef test_failure(): &quot;&quot;&quot;this test fails&quot;&quot;&quot; assert Falsedef test_skip(): &quot;&quot;&quot;this test is skipped&quot;&quot;&quot; pytest.skip(&#x27;for a reason!&#x27;)def test_broken(): raise Exception(&#x27;oops&#x27;) 方法1执行测试用例: 1pytest test_allure.py --alluredir=./result/1 打开报告: 1234567&gt; allure serve ./result/1Generating report to temp directory...Report successfully generated to C:\Users\10287\AppData\Local\Temp\6968593833275403330\allure-reportStarting web server...2020-10-25 20:59:42.368:INFO::main: Logging initialized @4873ms to org.eclipse.jetty.util.log.StdErrLogServer started at &lt;http://169.254.57.162:60084/&gt;. Press &lt;Ctrl+C&gt; to exit 方法212allure generate ./result/1 -o ./report/1/ --cleanallure open -h 127.0.0.1 -p 8883 ./report/1 浏览器访问地址 http://127.0.0.1:8883/ ，会显示跟上图一样的报告。 allure特性—feature, storry, step可以在报告中添加用例描述信息，比如测试功能，子功能或场景，测试步骤以及测试附加信息： @allure.feature(‘功能名称’)：相当于 testsuite @allure.story(’子功能名称‘)：对应这个功能或者模块下的不同场景，相当于 testcase @allure.step(‘步骤’)：测试过程中的每个步骤，放在具体逻辑方法中 allure.step(‘步骤’) 只能以装饰器的形式放在类或者方法上面 with allure.step：可以放在测试用例方法里面 @allure.attach(‘具体文本信息’) 附加信息：数据，文本，图片，视频，网页 测试用例 test_feature_story_step.py： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import pytestimport allure@allure.feature(&quot;登录&quot;)class TestLogin(): @allure.story(&quot;登录成功&quot;) def test_login_success(self): print(&quot;登录成功&quot;) pass @allure.story(&quot;密码错误&quot;) def test_login_failure(self): with allure.step(&quot;输入用户名&quot;): print(&quot;输入用户名&quot;) with allure.step(&quot;输入密码&quot;): print(&quot;输入密码&quot;) print(&quot;点击登录&quot;) with allure.step(&quot;登录失败&quot;): assert &#x27;1&#x27; == 1 print(&quot;登录失败&quot;) pass @allure.story(&quot;用户名密码错误&quot;) def test_login_failure_a(self): print(&quot;用户名或者密码错误，登录失败&quot;) pass@allure.feature(&quot;注册&quot;)class TestRegister(): @allure.story(&quot;注册成功&quot;) def test_register_success(self): print(&quot;测试用例：注册成功&quot;) pass @allure.story(&quot;注册失败&quot;) def test_register_failure(self): with allure.step(&quot;输入用户名&quot;): print(&quot;输入用户名&quot;) with allure.step(&quot;输入密码&quot;): print(&quot;输入密码&quot;) with allure.step(&quot;再次输入密码&quot;): print(&quot;再次输入密码&quot;) print(&quot;点击注册&quot;) with allure.step(&quot;注册失败&quot;): assert 1 + 1 == 2 print(&quot;注册失败&quot;) pass 用例执行、生成报告 123pytest test_feature_story.py --alluredir=./result/2 allure generate ./result/2 -o ./report/2/ --cleanallure open -h 127.0.0.1 -p 8883 ./report/2 报告： allure特性—link, issue, testcase可以在测试报告中添加链接、bug地址、测试用例地址。 关联bug需要在用例执行时添加参数： —allure-link-pattern=issue:[bug地址]{} 例如：—allure-link-pattern=issue:http://www.bugfree.com/issue/{} test_allure_link_issue.py： 1234567891011121314import allure@allure.link(&quot;http://www.baidu.com&quot;, name=&quot;baidu link&quot;)def test_with_link(): pass@allure.issue(&quot;140&quot;,&quot;this is a issue&quot;)def test_with_issue_link(): passTEST_CASE_LINK = &#x27;https://github.com&#x27;@allure.testcase(TEST_CASE_LINK, &#x27;Test case title&#x27;)def test_with_testcase_link(): pass 用例执行: 12pytest test_allure_link_issue.py --allure-link-pattern=issue:http://www.bugfree.com/issue/&#123;&#125; --alluredir=./result/3allure serve ./result/3 报告： 点击 this is a issue，页面会跳转到bug页面：http://www.bugfree.com/issue/140 allure特性—severity有时候在上线前，由于时间关系，我们只需要把重要模块测试一遍，在这样的场景下我们怎么实现呢？主要有三种方法： 可以使用pytest.mark来标记用例，Pytest测试框架（一）：pytest安装及用例执行 介绍了这种方法。 123@pytest.mark.webtest # 添加标签 @pytest.mark.sec pytest -m &quot;webtest and not sec&quot; 通过 allure.feature, allure.story来实现 123pytest test_feature_story_step.py --allure-features &quot;登录&quot; //只运行登录模块pytest test_feature_story_step.py --allure-stories &quot;登录成功&quot; //只运行登录成功子模块 ​```sss 12345678910111213141516171819202122232425262728293031323334353637383940 3. 通过 allure.severity按重要性级别来标记，有5种级别： - Blocker级别：阻塞 - Critical级别：严重 - Normal级别：正常 - Minor级别：不太重要 - Trivial级别：不重要test_allure_severity.py：​&#96;&#96;&#96;pythonimport allureimport pytestdef test_with_no_severity_label(): pass@allure.severity(allure.severity_level.TRIVIAL)def test_with_trivial_severity(): pass@allure.severity(allure.severity_level.NORMAL)def test_with_normal_severity(): pass@allure.severity(allure.severity_level.NORMAL)class TestclassWithNormalSeverity(object): def test_inside_the_normalseverity_test_class(self): pass @allure.severity(allure.severity_level.CRITICAL) def test_inside_the_normal_severity_test_class_with_overriding_critical_severity(self): pass 用例执行: 12pytest test_allure_severity.py --alluredir=./result/4 --allure-severities normal,criticalallure serve ./result/4 结果： allure.attach()可以在报告中附加文本、图片以及html网页，用来补充测试步骤或测试结果，比如错误截图或者关键步骤的截图。 test_allure_attach.py： 1234567891011import allureimport pytestdef test_attach_text(): allure.attach(&quot;纯文本&quot;, attachment_type=allure.attachment_type.TEXT)def test_attach_html(): allure.attach(&quot;&lt;body&gt;这是一段htmlbody块&lt;/body&gt;&quot;, &quot;html页面&quot;, attachment_type=allure.attachment_type.HTML)def test_attach_photo(): allure.attach.file(&quot;test.jpg&quot;, name=&quot;图片&quot;, attachment_tye=allure.attachment_type.JPG) 用例执行: 12pytest test_allure_attach.py --alluredir=./result/5allure serve ./result/5 结果： pytest+selenium+allure报告测试步骤： 打开百度 搜索关键词 搜索结果截图，保存到报告中 退出浏览器 test_allure_baidu.py： 1234567891011121314151617181920212223242526import allureimport pytestfrom selenium import webdriverimport time@allure.testcase(&quot;http://www.github.com&quot;)@allure.feature(&quot;百度搜索&quot;)@pytest.mark.parametrize(&#x27;test_data1&#x27;, [&#x27;allure&#x27;, &#x27;pytest&#x27;, &#x27;unittest&#x27;])def test_steps_demo(test_data1): with allure.step(&quot;打开百度网页&quot;): driver = webdriver.Chrome(&quot;D:/testing_tools/chromedriver85/chromedriver.exe&quot;) driver.get(&quot;http://www.baidu.com&quot;) with allure.step(&quot;搜索关键词&quot;): driver.find_element_by_id(&quot;kw&quot;).send_keys(test_data1) time.sleep(2) driver.find_element_by_id(&quot;su&quot;).click() time.sleep(2) with allure.step(&quot;保存图片&quot;): driver.save_screenshot(&quot;./result/b.png&quot;) allure.attach.file(&quot;./result/b.png&quot;, attachment_type=allure.attachment_type.PNG) allure.attach(&#x27;&lt;head&gt;&lt;/head&gt;&lt;body&gt;首页&lt;/body&gt;&#x27;, &#x27;Attach with HTML type&#x27;, allure.attachment_type.HTML) with allure.step(&quot;退出浏览器&quot;): driver.quit() 用例执行: 12pytest test_allure_baidu.py --alluredir=./result/6allure serve ./result/6 结果：]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试框架</category>
      </categories>
      <tags>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytest测试框架（三）：pytest fixture 用法]]></title>
    <url>%2Fposts%2Fpytest-fixture%2F</url>
    <content type="text"><![CDATA[xUnit style 结构的 fixture用于初始化测试函数， pytest fixture是对传统的 xUnit 架构的setup/teardown功能的改进。pytest fixture为测试准备一个良好的测试环境，测试函数使用的每个 fixture通常有一个参数(以 fixture 命名)，测试函数通过参数访问它们。本文将介绍pytest fixture的一些基本用法。 @pytest.fixture1234567891011121314151617181920212223import pytest@pytest.fixture()def login(): print(&quot;登录&quot;) return 8class Test_Demo(): def test_case1(self): print(&quot;\n开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self, login): print(&quot;\n开始执行测试用例2&quot;) print(login) assert 2 + login == 10 def test_case3(self): print(&quot;\n开始执行测试用例3&quot;) assert 99 + 1 == 100if __name__ == &#x27;__main__&#x27;: pytest.main() test_case2需要调用login方法（或者获取login的返回值），pytest 将会寻找并调用@pytest.fixture标记的login() 方法。 结果： 12345678PASSED [ 33%]开始执行测试用例1登录PASSED [ 66%]开始执行测试用例28PASSED [100%]开始执行测试用例3 共享 fixture 函数：conftest.py在测试过程中，多个测试文件可能都要调用 fixture 函数，可以将其移动到 conftest.py 文件中。conftest.py 文件中的 fixture 函数不需要在测试函数中导入，可以被 pytest 自动识别，查找顺序从测试类开始，然后是测试模块，然后是 conftest.py 文件，最后是内置插件和第三方插件。 conftest.py ： 12345import pytest@pytest.fixture()def login(): print(&quot;登录&quot;) return 8 测试用例： 12345678910111213141516171819import pytestclass Test_Demo(): def test_case1(self): print(&quot;\n开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self, login): print(&quot;\n开始执行测试用例2&quot;) print(login) assert 2 + login == 10 def test_case3(self): print(&quot;\n开始执行测试用例3&quot;) assert 99 + 1 == 100if __name__ == &#x27;__main__&#x27;: pytest.main() 结果： 12345678PASSED [ 33%]开始执行测试用例1登录PASSED [ 66%]开始执行测试用例28PASSED [100%]开始执行测试用例3 yield方法使用yield关键字可以实现setup/teardown的功能，在yield关键字之前的代码在case之前执行，yield之后的代码在case运行结束后执行 123456789101112131415161718192021222324import pytest@pytest.fixture()def login(): print(&quot;登录&quot;) yield print(&quot;退出登录&quot;)class Test_Demo(): def test_case1(self): print(&quot;\n开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self, login): print(&quot;\n开始执行测试用例2&quot;) assert 2 + 8 == 10 def test_case3(self): print(&quot;\n开始执行测试用例3&quot;) assert 99 + 1 == 100if __name__ == &#x27;__main__&#x27;: pytest.main() 结果： 123456789PASSED [ 33%]开始执行测试用例1登录PASSED [ 66%]开始执行测试用例2退出登录PASSED [100%]开始执行测试用例3 addfinalizer方法addfinalizer也可以实现环境的清理，实现与yield方法相同的效果，跟yield不同的是需要注册作为终结器使用的函数。 1234567891011121314151617181920212223242526import pytest@pytest.fixture()def login(request): print(&quot;登录&quot;) def demo_finalizer(): print(&quot;退出登录&quot;) # 注册demo_finalizer为终结函数 request.addfinalizer(demo_finalizer)class Test_Demo(): def test_case1(self): print(&quot;\n开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self, login): print(&quot;\n开始执行测试用例2&quot;) assert 2 + 8 == 10 def test_case3(self): print(&quot;\n开始执行测试用例3&quot;) assert 99 + 1 == 100if __name__ == &#x27;__main__&#x27;: pytest.main() 结果： 12345678PASSED [ 33%]开始执行测试用例1登录PASSED [ 66%]开始执行测试用例2退出登录PASSED [100%]开始执行测试用例3 fixture 作用范围：Scopefixture 作用范围可以为module、class、session和function，默认作用域为function。 function：每一个函数或方法都会调用 class：每一个类调用一次 module：每一个.py文件调用一次 session：是多个文件调用一次scope=”function”12345678910111213141516171819202122import pytest@pytest.fixture(scope=&quot;function&quot;)def login(): print(&quot;登录...&quot;)class Test_Demo(): def test_case1(self, login): print(&quot;\n开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self, login): print(&quot;\n开始执行测试用例2&quot;) assert 2 + 8 == 10 def test_case3(self, login): print(&quot;\n开始执行测试用例3&quot;) assert 99 + 1 == 100if __name__ == &#x27;__main__&#x27;: pytest.main() 结果： 123456789登录...PASSED [ 33%]开始执行测试用例1登录...PASSED [ 66%]开始执行测试用例2登录...PASSED [100%]开始执行测试用例3 scope=”class”一个class里面多个用例都调用了此fixture，那么只在class里所有用例开始前执行一次 123456import pytest@pytest.fixture(scope=&quot;class&quot;)def login(): print(&quot;登录...&quot;) 结果： 1234567登录...PASSED [ 33%]开始执行测试用例1PASSED [ 66%]开始执行测试用例2PASSED [100%]开始执行测试用例3 fixture自动应用autouse参数autouse设置为True时，自动调用fixture功能。由于默认作用域为function，不指定scope则每个方法都会调用fixture方法。 12345678910111213141516171819202122import pytest@pytest.fixture(autouse=True)def login(): print(&quot;登录...&quot;)class Test_Demo(): def test_case1(self): print(&quot;\n开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self): print(&quot;\n开始执行测试用例2&quot;) assert 2 + 8 == 10 def test_case3(self): print(&quot;\n开始执行测试用例3&quot;) assert 99 + 1 == 100if __name__ == &#x27;__main__&#x27;: pytest.main() 结果： 123456789登录...PASSED [ 33%]开始执行测试用例1登录...PASSED [ 66%]开始执行测试用例2登录...PASSED [100%]开始执行测试用例3 @pytest.mark.usefixtures()在测试方法上加@pytest.mark.usefixtures() 1234567891011121314151617181920212223import pytest@pytest.fixture()def login(): print(&quot;登录...&quot;)@pytest.mark.usefixtures(&quot;login&quot;)class Test_Demo(): def test_case1(self): print(&quot;\n开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self): print(&quot;\n开始执行测试用例2&quot;) assert 2 + 8 == 10 def test_case3(self): print(&quot;\n开始执行测试用例3&quot;) assert 99 + 1 == 100if __name__ == &#x27;__main__&#x27;: pytest.main() 结果： 123456789登录...PASSED [ 33%]开始执行测试用例1登录...PASSED [ 66%]开始执行测试用例2登录...PASSED [100%]开始执行测试用例3 fixture函数参数化如果多条用例都需要调用相同参数，可以将fixture函数参数化。fixture 函数将执行每个参数值，fixture通过固定参数request传递。 1234567891011121314151617181920212223242526import pytest@pytest.fixture(scope=&quot;module&quot;, params=[ [1, 1, 2], [2, 8, 10], [99, 1, 100]])def data(request): yield request.paramclass Test_Demo(): def test_case1(self): print(&quot;\n开始执行测试用例1&quot;) assert 2 + 8 == 10 def test_case2(self, data): print(&quot;\n开始执行测试用例2&quot;) assert data[0] + data[1] == data[2] def test_case3(self): print(&quot;\n开始执行测试用例3&quot;) assert 99 + 1 == 100if __name__ == &#x27;__main__&#x27;: pytest.main() 结果： 12345678910PASSED [ 20%]开始执行测试用例1PASSED [ 40%]开始执行测试用例2PASSED [ 60%]开始执行测试用例2PASSED [ 80%]开始执行测试用例2PASSED [100%]开始执行测试用例3]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试框架</category>
      </categories>
      <tags>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytest测试框架（二）：pytest 的setup/teardown方法]]></title>
    <url>%2Fposts%2Fpytest-xunit-style-of-setup-teardown%2F</url>
    <content type="text"><![CDATA[PyTest支持xUnit style 结构， setup() 和 teardown() 方法用于初始化和清理测试环境，可以保证测试用例的独立性。pytest的setup/teardown方法包括：模块级别(setup_module/teardown_module)、函数级别(setup_function/teardown_function)、类级别(setup_class/ teardown_class)、方法级别(setup_method/teardown_methond或者setup/teardown)。 模块级别模块中的第一个测试用例开始前执行setup_module方法，模块中的最后一个测试用例结束后运行teardown_module方法。 1234567891011121314151617181920import pytestdef setup_module(): print(&quot;初始化。。。&quot;)def teardown_module(): print(&quot;清理。。。&quot;)class Test_Demo(): def test_case1(self): print(&quot;开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self): print(&quot;开始执行测试用例2&quot;) assert 2 + 8 == 10 def test_case3(self): print(&quot;开始执行测试用例3&quot;) assert 99 + 1 == 100 结果： 12345模块初始化。。。PASSED [ 33%]开始执行测试用例1PASSED [ 66%]开始执行测试用例2PASSED [100%]开始执行测试用例3模块清理。。。 函数级别 setup_function/teardown_function在每个测试函数前后运行，只对函数用例生效，不在类中。 12345678910111213141516171819import pytestdef setup_function(): print(&quot;初始化。。。&quot;)def teardown_function(): print(&quot;清理。。。&quot;)def test_case1(): print(&quot;开始执行测试用例1&quot;) assert 1 + 1 == 2def test_case2(): print(&quot;开始执行测试用例2&quot;) assert 2 + 8 == 10def test_case3(): print(&quot;开始执行测试用例3&quot;) assert 99 + 1 == 100 结果： 123456789101112test_setup_teardown2.py::test_case1 初始化。。。PASSED [ 33%]开始执行测试用例1清理。。。test_setup_teardown2.py::test_case2 初始化。。。PASSED [ 66%]开始执行测试用例2清理。。。test_setup_teardown2.py::test_case3 初始化。。。PASSED [100%]开始执行测试用例3清理。。。 类级别类级别函数 setup_class/teardown_class 对类有效，位于类中，在测试类中前后调用一次。 123456789101112131415161718class Test_Demo(): def setup_class(self): print(&quot;初始化。。。&quot;) def teardown_class(self): print(&quot;清理。。。&quot;) def test_case1(self): print(&quot;开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self): print(&quot;开始执行测试用例2&quot;) assert 2 + 8 == 10 def test_case3(self): print(&quot;开始执行测试用例3&quot;) assert 99 + 1 == 100 结果： 12345初始化。。。PASSED [ 33%]开始执行测试用例1PASSED [ 66%]开始执行测试用例2PASSED [100%]开始执行测试用例3清理。。。 方法级别方法级别函数 setup_method/teardown_method和setup/teardown对类有效，也位于类中，这两个效果一样，在测试类中每个测试方法前后调用一次。 123456789101112131415161718class Test_Demo(): def setup_method(self): print(&quot;初始化。。。&quot;) def teardown_method(self): print(&quot;清理。。。&quot;) def test_case1(self): print(&quot;开始执行测试用例1&quot;) assert 1 + 1 == 2 def test_case2(self): print(&quot;开始执行测试用例2&quot;) assert 2 + 8 == 10 def test_case3(self): print(&quot;开始执行测试用例3&quot;) assert 99 + 1 == 100 结果： 123456789初始化。。。PASSED [ 33%]开始执行测试用例1清理。。。初始化。。。PASSED [ 66%]开始执行测试用例2清理。。。初始化。。。PASSED [100%]开始执行测试用例3清理。。。]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试框架</category>
      </categories>
      <tags>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytest测试框架（一）：pytest安装及用例执行]]></title>
    <url>%2Fposts%2Finstall-pytest-and-run-test%2F</url>
    <content type="text"><![CDATA[PyTest是基于Python的开源测试框架，语法简单易用，有大量的插件，功能非常多。自动检测测试用例，支持参数化，跳过特定用例，失败重试等功能。 安装123pip install -U pytest # 安装pytest --version # 查看版本pytest -h # 查看帮助信息 用例识别 pytest识别文件名为test_.py或者_test.py的测试文件 测试文件中可以在Test*类中写测试用例（测试用例以test*开头，并且测试类不能有_init方法） 不在Test类中的test_用例也可以被识别到。 识别包含“add”的用例： pytest -k &quot;add&quot; --collect-only 123456789101112131415161718192021(base) D:\ProgramWorkspace\TestingDemo&gt;pytest -k &quot;add&quot; --collect-only============================================== test session starts ==============================================platform win32 -- Python 3.7.6, pytest-5.3.5, py-1.8.1, pluggy-0.13.1rootdir: D:\ProgramWorkspace\TestingDemoplugins: hypothesis-5.5.4, arraydiff-0.3, astropy-header-0.1.2, doctestplus-0.5.0, openfiles-0.4.0, remotedata-0.3.2collected 20 items / 11 deselected / 9 selected &lt;Package D:\ProgramWorkspace\TestingDemo\testing&gt; &lt;Module test_calc.py&gt; &lt;UnitTestCase TestCalc&gt; &lt;TestCaseFunction test_add_1&gt; &lt;TestCaseFunction test_add_2&gt; &lt;Module test_calc2.py&gt; &lt;Class TestCalc&gt; &lt;Function test_add[1-2-3]&gt; &lt;Function test_add[-1--2--3]&gt; &lt;Function test_add[0-1-1]&gt; &lt;Function test_add[0--1--1]&gt; &lt;Function test_add[0.1-0.2-0.3]&gt; &lt;Function test_add[999999-1000000-1999999]&gt; &lt;Function test_add_1&gt; 打印文件下所有用例： pytest --collect-only 1234567891011121314151617181920212223242526272829303132333435(base) D:\ProgramWorkspace\TestingDemo&gt;pytest --collect-only============================================== test session starts ==============================================platform win32 -- Python 3.7.6, pytest-5.3.5, py-1.8.1, pluggy-0.13.1rootdir: D:\ProgramWorkspace\TestingDemoplugins: hypothesis-5.5.4, arraydiff-0.3, astropy-header-0.1.2, doctestplus-0.5.0, openfiles-0.4.0, remotedata-0.3.2collected 20 items &lt;Module test_pytest.py&gt; &lt;Function test_one&gt; &lt;Function test_two&gt; &lt;Function test_three&gt;&lt;Module test_pytest2.py&gt; &lt;Class Test_Demo&gt; &lt;Function test_one&gt; &lt;Function test_two&gt; &lt;Function test_three&gt;&lt;Package D:\ProgramWorkspace\TestingDemo\testing&gt; &lt;Module test_calc.py&gt; &lt;UnitTestCase TestCalc&gt; &lt;TestCaseFunction test_add_1&gt; &lt;TestCaseFunction test_add_2&gt; &lt;Module test_calc2.py&gt; &lt;Class TestCalc&gt; &lt;Function test_add[1-2-3]&gt; &lt;Function test_add[-1--2--3]&gt; &lt;Function test_add[0-1-1]&gt; &lt;Function test_add[0--1--1]&gt; &lt;Function test_add[0.1-0.2-0.3]&gt; &lt;Function test_add[999999-1000000-1999999]&gt; &lt;Function test_div[1-2-0.5]&gt; &lt;Function test_div[-1--2-0.5]&gt; &lt;Function test_div[0-1-0]&gt; &lt;Function test_div[1-0-0]&gt; &lt;Function test_div[0.1-0.2-0.5]&gt; &lt;Function test_add_1&gt; Pytest执行一个简单的测试用例test_pytest.py： 123456789101112131415161718import pytestdef calc(a,b): return a + bclass TestDemo(): def test_answer1(self): assert calc(1, 1) == 2 def test_answer2(self): assert calc(2, 1) == 3 @pytest.mark.answer3 def test_answer3(self): assert calc(6, 6) == 12if __name__==&#x27;__main__&#x27;: pytest.main() 用例执行12345678# 执行test_pytest.py所有用例（模块）pytest test_pytest.py # 执行test_pytest.py里的TestDemo类pytest test_pytest.py::TestDemo # 执行test_pytest.py里的TestDemo类的test_answer2方法pytest test_pytest.py::TestDemo::test_answer2 打印日志信息123# 打印详细运行日志信息pytest -v test_pytest.py pytest -s test_pytest.py 跳过某个用例123# 跳过运行某个用例pytest -v -k &quot;类名 and not方法名&quot; 文件名pytest -v -k &quot;TestDemo and not test_answer2&quot; test_pytest.py 运行某个标记的用例123# 将运行有这个标记的测试用例：@pytest.mark.[标记名]pytest -m [标记名] 文件名pytest -m answer3 test_pytest.py 报错停止1234567# 一旦运行到报错用例就停止运行pytest -x 文件名pytest -x test_pytest.py# 当报错达到num的时候就停止运行pytest --maxfail=[num] 文件名pytest --maxfail=[num] test_pytest.py 失败重新运行安装 pytest-rerunfailures 插件： 1pip install pytest-rerunfailures 测试失败后重新运行n次，在重新运行间延迟n秒再运行： 1234# 重新运行3次pytest --reruns 3 -v -s test_pytest.py# 重新运行5次，延迟1spytest --reruns 5 --reruns-delay 1 -v test_pytest.py 重复执行安装pytest-repeat插件1pip install pytest-repeat重复执行： 1234# 重新执行3次pytest -v -s --count=3 test_pytest.py# 设置重复范围：session, module, class或者function（默认）pytest -v -s --count=3 --repeat-scope=session test_pytest.py 或者在代码中标记：12345678910import pytestdef calc(a,b): return a + bclass TestDemo(): @pytest.mark.repeat(3) def test_answer1(self): assert calc(1, 1) == 2 多条断言一个方法中有多条断言，通常第一条失败后下面就不执行了，pytest-assume插件可以解决断言失败后继续执行断言的问题。 安装 1pip install pytest-assume 执行多条断言: 123456789# 写法1pytest.assume(x == y)pytest.assume(True)pytest.assume(False)# 写法2with assume: assert calc(2, 1) == 4 with assume: assert calc(2, 1) == 3 with assume: assert calc(2, 2) == 3 修改测试用例test_pytest.py： 123456789101112131415161718192021import pytestfrom pytest import assumedef calc(a,b): return a + bclass TestDemo(): def test_answer1(self): assert calc(1, 1) == 2 def test_answer2(self): with assume: assert calc(2, 1) == 4 with assume: assert calc(2, 1) == 3 with assume: assert calc(2, 2) == 3 @pytest.mark.answer3 def test_answer3(self): assert calc(6, 6) == 12if __name__==&#x27;__main__&#x27;: pytest.main() 测试结果： pytest.main()除了在终端执行外，也可以通过pytest.main()来执行，pytest.main() 自动查找当前目录下以test_开头的文件或者以_test结尾的py文件。 括号内可传入执行参数，通过[]进行分割，[]内的多个参数通过逗号分割，所有的参数和pytest命令行方式一样：1pytest.main([&#x27;-v&#x27;, &#x27;test_pytest.py&#x27;]) # 执行test_pytest.py用例或者直接在测试文件最后写如下代码，执行py文件。123if __name__==&#x27;__main__&#x27;: pytest.main() # pytest.main([&#x27;-v&#x27;, &#x27;test_pytest.py&#x27;]) 更多pytest执行方法可参考官方文档：https://docs.pytest.org/en/latest/contents.html#toc]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试框架</category>
      </categories>
      <tags>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web自动化测试 | 执行JavaScript脚本]]></title>
    <url>%2Fposts%2Fselenium-javascript%2F</url>
    <content type="text"><![CDATA[JavaScript是运行在客户端（浏览器）和服务器端的脚本语言，允许将静态网页转换为交互式网页。可以通过 Python Selenium WebDriver 执行 JavaScript 语句，在Web页面中进行js交互。那么js能做的事，Selenium应该大部分也能做。WebDriver是模拟终端用户的交互，所以就不能点击不可见的元素，有时可见元素也不能点击。在这些情况下，我们就可以通过WebDriver 执行JavaScript来点击或者执行页面元素。本文将介绍如何使用WebDriver执行JavaScript语句。 Web元素定位及操作使用execute_script() 执行 JavaScript 代码，有两种方法实现元素操作 方法1：文档级别操作直接使用JavaScript实现元素定位和动作执行，主要方法有： 12345document.getElementByIddocument.getElementsByClassNamedocument.getElementsByNamedocument.getElementsByTagNamedocument.getElementsByTagNameNS 测试示例： 打开百度一下 输入框输入”test“ 点击百度一下 python代码： 123456def test_baidu(self): self.driver.get(&quot;http://www.baidu.com&quot;) self.driver.execute_script(&#x27;document.getElementById(&quot;kw&quot;).value = &quot;test&quot;&#x27;) time.sleep(2) self.driver.execute_script(&#x27;document.getElementById(&quot;su&quot;).click()&#x27;) time.sleep(2) 在执行过程中，WebDriver 将 JavaScript 语句注入到浏览器中，然后脚本将执行。这个注入 JavaScript 有自己的名称空间，不会干扰实际网页中的 JavaScript运行。 方法2：元素级别操作可以先使用WebDriver获取想要操作的元素，然后使用JavaScript执行操作。 12input_ele = driver.find_element_by_id(&quot;su&quot;) driver.execute_script(&quot;arguments[0].click();&quot;, input_ele) python代码： 12345678def test_baidu2(self): self.driver.get(&quot;http://www.baidu.com&quot;) input_ele = self.driver.find_element_by_id(&quot;kw&quot;) self.driver.execute_script(&quot;arguments[0].value = &#x27;test&#x27;;&quot;, input_ele) time.sleep(2) baidu_ele = self.driver.find_element_by_id(&quot;su&quot;) self.driver.execute_script(&quot;arguments[0].click();&quot;, baidu_ele) time.sleep(2) 可以在语句中使用多个 JavaScript动作： 123username = driver.find_element_by_xpath(&quot;//*[@id=&#x27;username&#x27;]&quot;)password = driver.find_element_by_xpath(&quot;//*[@id=&#x27;password&#x27;]&quot;)driver.execute_script(&quot;arguments[0].value = &#x27;admin&#x27;;arguments[1].value = &#x27;admin&#x27;;&quot;, username, password) 获取返回值可以返回JavaScript的执行结果： 12driver.execute_script(&quot;return document.getElementById(&#x27;kw&#x27;).value&quot;)driver.execute_script(&quot;return document.title;&quot;) # 返回网页标题 滑动在Selenium ActionChains、TouchAction方法中介绍了TouchAction类中scroll_from_element()也可以滑动页面。 滑动到浏览器底部12document.documentElement.scrollTop=10000window.scrollTo(0, document.body.scrollHeight) 滑动到浏览器顶部12document.documentElement.scrollTop=0window.scrollTo(document.body.scrollHeight,0) 更改元素属性大部分时间控件都是 readonly属性，需要手动去选择对应的时间。自动化测试中，可以使用JavaScript代码取消readonly属性。 测试页面：https://www.12306.cn/index/ 测试步骤： 打开测试页面 修改出发日期 断言日期是否修改成功 python测试代码： 12345678def test_datettime(self): self.driver.get(&quot;https://www.12306.cn/index/&quot;) # 取消readonly属性 self.driver.execute_script(&quot;dat=document.getElementById(&#x27;train_date&#x27;); dat.removeAttribute(&#x27;readonly&#x27;)&quot;) self.driver.execute_script(&quot;document.getElementById(&#x27;train_date&#x27;).value=&#x27;2020-10-01&#x27;&quot;) time.sleep(3) now_time = self.driver.execute_script(&quot;return document.getElementById(&#x27;train_date&#x27;).value&quot;) assert &#x27;2020-10-01&#x27; == now_time 总结 Selenium WebDriver 执行 JavaScript代码是一个非常强大的功能，可以实现WebElement 接口所有功能，甚至更多的功能。比如在web性能测试中可以调用Web API接口window.performance来测试Web性能。]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web自动化测试 | xpath & CSS Selector定位]]></title>
    <url>%2Fposts%2Fselenium-xpath-and-CSS-Selector-locator%2F</url>
    <content type="text"><![CDATA[Xpath 和 CSS Selector简介CSS SelectorCSS Selector和Xpath都可以用来表示XML文档中的位置。CSS (Cascading Style Sheets)是一种样式表语言，是所有浏览器内置的，用于描述以HTML或XML编写的文档的外观和样式。CSS Selector用于选择样式化的元素，所以理论上前端人员可以定位 DOM 节点并设置样式，那么对于测试人员这些元素也可以定位到。 XPathXPath是XML路径语言，是一种查询语言，使用路径表达式浏览XML文档中的元素和属性。XPath标准语法如下： Xpath=//tagname[@attribute=’value’] \// : 选择当前节点 Tagname: 节点标签名 @: 选择属性 Attribute: 节点属性名 Value: 属性值 XPath有绝对定位和相对定位两种，绝对定位使用绝对路径，缺点是路径太长，只要一个节点变动就无法定位。以单斜杠（/）开始，表示从根节点开始选择元素。下面是页面https://www.baidu.com/上“百度一下”按钮的绝对路径： 1&#x2F;html&#x2F;body&#x2F;div[1]&#x2F;div[1]&#x2F;div[5]&#x2F;div[1]&#x2F;div&#x2F;form&#x2F;span[2]&#x2F;input 相对路径以双斜杠（//）开始，可以从HTML文档的任何位置开始，“百度一下”按钮的相对路径可以表示如下 1&#x2F;&#x2F;input[@id&#x3D;&quot;su&quot;] Xpath VS. CSS SelectorCSS Selector和Xpath几乎可以定位到所有Web元素（HTML和XML文档元素，Android应用的层级结构使用xml编写），它们的主要差异包括： XPath通过遍历的方式从XML文档中选择节点，CSS Selector是一种匹配模式定位，因此CSS Selector比 XPath 执行效率更高。 Xpath可以通过文本来定位，而CSS Selector不能； Xpath可以通过子节点来定位父节点，CSS Selector是前向的，不能利用子节点定位父节点。 CSS Selector语法相比Xpath更加简洁 Xpath 和 CSS Selector元素定位接下来对比一下这两种方法的语法差异，节点的定义我们规定如下： 儿子元素定位xpath使用‘/’，CSS Selector使用‘&gt;’ Xpath CSS Selector 语法 //element/element element&gt;element 示例 //div/a div &gt; a 描述 选择父元素为 \ 元素的所有 \ 元素。 还可以使用XPath Axes（轴）child 来定位子元素 XPATH: 12//div/child::* # 选择父元素为 &lt;div&gt; 元素的所有儿子元素//div/child::a # 选择父元素为 &lt;div&gt; 元素的所有&lt;a&gt;元素 CSS Selector: 1234div &gt; a:nth-child(2) # 选择父元素为 &lt;div&gt; 元素的第二个&lt;a&gt;元素div &gt; a:nth-last-child(2) # 选择父元素为 &lt;div&gt; 元素的倒数第二个&lt;a&gt;元素div &gt; a:last-child # 选择父元素为 &lt;div&gt; 元素的最后一个&lt;a&gt;元素div &gt; a:first-child # 选择父元素为 &lt;div&gt; 元素的第一个&lt;a&gt;元素 子孙元素定位xpath使用‘//’，CSS Selector使用空格 Xpath CSS Selector 语法 //element//element element element 示例 //div//a div a 描述 选择 \ 元素内部的所有 \ 元素。 还可以使用XPath Axes（轴）descendant 来定位子孙元素 XPATH: 12//div/descendant::* # 选择祖先元素为 &lt;div&gt; 元素的所有子孙元素//div/descendant::a # 选择祖先元素为 &lt;div&gt; 元素的所有&lt;a&gt;元素 CSS Selector使用空格定位子孙元素后进行选择: 1234div a:nth-child(2) # 选择祖先元素为 &lt;div&gt; 元素的第二个&lt;a&gt;元素div a:nth-last-child(2) # 选择祖先元素为 &lt;div&gt; 元素的倒数第二个&lt;a&gt;元素div a:last-child # 选择祖先元素为 &lt;div&gt; 元素的最后一个&lt;a&gt;元素div a:first-child # 选择祖先元素为 &lt;div&gt; 元素的第一个&lt;a&gt;元素 邻居节点定位在同一个父节点下，定位下一个相邻节点 Xpath CSS Selector 语法 //element/following-sibling::element element + element 示例 //div/following-sibling::a div + a 描述 选择紧接在 \ 元素之后的所有 \ 元素。 Xpath可以定位当前节点前面的邻居节点，CSS Selector不能 1//*element/preceding-sibling::element 父元素、祖先元素定位CSS Selector是前向的，不能利用子节点定位父节点 方法 描述 .. 一个点”.“表示选取当前节点，两个点”..“表示选取当前节点的父节点。 ancestor 当前节点祖先元素（父、祖父…） parent 当前节点的父节点 Id定位 Xpath CSS Selector 语法 //*[@id=’example’] #example 示例 //*[@id=’uesrname’] #uesrname 描述 选择id=’uesrname’的元素。 Class定位 Xpath CSS Selector 语法 //*[@class=’example’] .example 示例 //*[@class=’uesrname’] .uesrname 描述 选择class=’uesrname’的元素。 属性值定位没有Id和Class的情况下，可以使用其它属性值定位，比如name、type等。 Xpath CSS Selector 语法 //*[@attribute=’value’] [attribute=value] 示例 //*[@name=’uesrname’] [name=’username’] 描述 选择属性值name=’uesrname’的元素。 xpath可以使用 ‘and’ 或者 ‘or’ 连接两个属性： XPATH： 1//input[@name=&#x27;login&#x27;and @type=&#x27;submit&#x27;] CSS Selector： 1input[name=&#x27;login&#x27;][type=&#x27;submit&#x27;] CSS Selector可以进行子字符串匹配进行定位: ^= 匹配前缀 1[id^=&#x27;id_prefix_&#x27;] # id前缀为‘id_prefix_’的元素 $= 匹配后缀 1[id$=&#x27;_id_sufix&#x27;] # id后缀为‘_id_sufix’的元素 *= 包含某个字符串 1[id*=&#x27;id_pattern&#x27;] # id包含‘id_pattern’的元素 Xpath Contains()方法Contains()方法允许通过部分文本来定位查找元素，CSS Selector不支持这种用法。 123456Xpath = //*[contains(@type,&#x27;partial_text&#x27;)]Xpath = //*[contains(@name,&#x27;partial_text&#x27;)]Xpath = //*[contains(@class,&#x27;partial_text&#x27;)]Xpath = //*[contains(@id,&#x27;partial_text&#x27;)]Xpath = //*[contains(text(),&#x27;partial_text&#x27;)]Xpath = //*[contains(@href,&#x27;partial_text&#x27;)] Xpath Starts-with()方法查找属性值以特定文本开始的元素 123456Xpath = //*[starts-with(@type,&#x27;start_text&#x27;)]Xpath = //*[starts-with(@name,&#x27;start_text&#x27;)]Xpath = //*[starts-with(@class,&#x27;start_text&#x27;)]Xpath = //*[starts-with(@id,&#x27;start_text&#x27;)]Xpath = //*[starts-with(text(),&#x27;start_text&#x27;)]Xpath = //*[starts-with(@href,&#x27;start_text&#x27;)] Xpath Text()方法Text()方法基于web元素文本来进行定位 1Xpath = //*[text()=&#x27;text_value&#x27;] 实例子孙元素定位百度一下”text“，点击”资讯“ Xpath： 12//*[@id=&quot;s_tab&quot;]/descendant::a[1]//*[@id=&quot;s_tab&quot;]/child::*[1]/a[1] CSS selector： 12#s_tab a:nth-child(2)#s_tab a:nth-last-child(9) python测试代码： 123456789def test_css(self): self.driver.get(&quot;https://www.baidu.com/&quot;) self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;test&quot;) self.driver.find_element_by_id(&quot;su&quot;).click() # element = self.driver.find_element_by_css_selector(&quot;#s_tab a:nth-child(2)&quot;) # element = self.driver.find_element_by_css_selector(&#x27;#s_tab a:nth-last-child(9)&#x27;) element = self.driver.find_element_by_xpath(&#x27;//*[@id=&quot;s_tab&quot;]/descendant::a[1]&#x27;) element.click() sleep(2) 邻居节点定位点击”资讯“下一个邻居节点”视频“ xpath 12//*[@id=&quot;s_tab&quot;]/descendant::a[1]/following-sibling::a[1]//*[@id=&quot;s_tab&quot;]/child::*[1]/a[1]/following-sibling::a[1] CSS selector： 12#s_tab a:nth-child(2) + a#s_tab a:nth-last-child(9) + a python测试代码：12345678def test_css2(self): self.driver.get(&quot;https://www.baidu.com/&quot;) self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;test&quot;) self.driver.find_element_by_id(&quot;su&quot;).click() # element = self.driver.find_element_by_css_selector(&#x27;#s_tab a:nth-child(2) + a&#x27;) element = self.driver.find_element_by_xpath(&#x27;//*@id=&quot;s_tab&quot;]/descendant::a[1]/following-sibling::a[1]&#x27;) element.click() sleep(2) Xpath Contains()、Starts-with()、Text()定位测试页面：http://sahitest.com/demo/linkTest.htm 点击”linkByContent“ xpath语法： 1234//*[contains(@href,&quot;Content&quot;)]//*[starts-with(@href,&quot;linkByC&quot;)]//*[contains(text(),&quot;Content&quot;)]//*[text()=&quot;linkByContent&quot;] python测试代码： 1234567def test_css2(self): self.driver.get(&quot;http://sahitest.com/demo/linkTest.htm&quot;) # element = self.driver.find_element_by_xpath(&#x27;//*[contains(@href,&quot;Content&quot;)]&#x27;) # element = self.driver.find_element_by_xpath(&#x27;//*[starts-with(@href,&quot;linkByC&quot;)]&#x27;) # element = self.driver.find_element_by_xpath(&#x27;//*[contains(text(),&quot;Content&quot;)]&#x27;) element = self.driver.find_element_by_xpath(&#x27;//*[text()=&quot;linkByContent&quot;]&#x27;) element.click() 总结Xpath几乎可以定位到所有Web元素，CSS Selector效率更高，且代码简洁，但有些元素可能无法定位，特别是需要通过子元素来定位的父元素，或者需要通过文本定位的元素。 在实际使用中，按照自己的实际情况来选择即可，CSS Selector理论上执行效率更高，但他们的性能差异不是很大，在几毫秒或者几十毫秒级别。这两种定位方法除了本文介绍的以外，还有更多其它高级语法，可以参考官方文档。]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>元素定位</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web自动化测试 | 多浏览器测试]]></title>
    <url>%2Fposts%2Fselenium-browsers%2F</url>
    <content type="text"><![CDATA[在浏览器的兼容性测试中，会测试产品在不同浏览器上的兼容性，比较主流的浏览器有IE、Firefox、Chrome，Opera，Safari等。还有其它如360、QQ、遨游、百度等浏览器都是基于IE或者chrome内核，或者IE+Chrome双内核开发，在测试这类浏览器时可以调用对应内核驱动。 不同的浏览器需要对应的驱动程序，这样selenium才能与浏览器进行通信。在启动WebDriver之前可以指定驱动的绝对位置，但还是建议将驱动添加到环境变量中，这样代码更易于维护，容易移植。下面介绍selenium对几种浏览器的远程控制方法： Chrome浏览器1. 下载驱动首先查看浏览器版本号，根据浏览器的版本号去下载对应的 chromedriver，Chrome浏览器版本与对应的驱动参考：https://sites.google.com/a/chromium.org/chromedriver/downloads 驱动下载地址：https://chromedriver.storage.googleapis.com/index.html 解压并将驱动添加到环境变量中 2. python代码实现123456from selenium.webdriver import Chromebrowser_locale = &#x27;fr-FR&#x27;options = Options()options.add_argument(&quot;--lang=&#123;&#125;&quot;.format(browser_locale)) # 设置浏览器语言self.driver = webdriver.Chrome(chrome_options=options)self.driver.get(&#x27;https://www.baidu.com&#x27;) Firefox-火狐浏览器1. 下载驱动浏览器版本、驱动geckodriver版本、Selenium版本对应关系参考：https://firefox-source-docs.mozilla.org/testing/geckodriver/Support.html 浏览器下载地址：http://ftp.mozilla.org/pub/firefox/releases/驱动下载地址：https://github.com/mozilla/geckodriver/releases 2. python代码123from selenium.webdriver import Firefoxself.driver = webdriver.Firefox()self.driver.get(&#x27;https://www.baidu.com&#x27;) IE浏览器1. 下载驱动下载IEDriverServer.exe ：http://selenium-release.storage.googleapis.com/index.html IE浏览器下载：https://support.microsoft.com/zh-cn/topic/%E4%B8%8B%E8%BD%BD-internet-explorer-11-%E8%84%B1%E6%9C%BA%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F-99d492a1-3a62-077b-c476-cf028aff9a7f 注意：设置internet选项&gt;安全 这4个选项全勾选或者不勾选，不然无法驱动IE浏览器。 2. python代码123from selenium.webdriver import Ie self.driver = webdriver.Ie() self.driver.get(&#x27;https://www.baidu.com&#x27;) Edge浏览器1. 下载驱动Edge浏览器版本与edgedriver驱动版本对应关系参考：https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/ edgedriver驱动下载地址：https://msedgewebdriverstorage.z22.web.core.windows.net/ 2. python代码123from selenium.webdriver import Edge self.driver = Edge()self.driver.get(&#x27;https://www.baidu.com&#x27;) Opera浏览器-欧朋浏览器1. 下载驱动Opera浏览器版本与OperaDriver驱动版本对应关系参考：https://github.com/operasoftware/operachromiumdriver/releases Opera浏览器历史版本下载地址：https://get.geo.opera.com/pub/opera/desktop/ 2. python代码123from selenium.webdriver import Opera self.driver = Opera()self.driver.get(&#x27;https://www.baidu.com&#x27;) 其它浏览器360极速浏览器360极速浏览器采用chrome内核，可以使用对应版本的chromedriver 1234option=webdriver.ChromeOptions()option.binary_location=r&#x27;D:/software/360Chrome/Chrome/Application/360chrome.exe&#x27;self.driver=webdriver.Chrome(options=option)self.driver.get(&#x27;https://www.baidu.com&#x27;) binary_location为360极速浏览器安装路径下的可执行文件360chrome.exe的路径 2345浏览器2345浏览器是基于IE+Chrome双内核开发，可以使用chromedriver来驱动它： 1234option=webdriver.ChromeOptions()option.binary_location=r&#x27;C:/Program Files (x86)/2345Soft/2345Explorer/2345Explorer.exe&#x27;self.driver=webdriver.Chrome(options=option)self.driver.get(&#x27;https://www.baidu.com&#x27;) 其它基于chrome内核的浏览器也可以使用这种方法来驱动，基于IE内核开发的浏览器还没办法控制，如果各位看官有好的方法，欢迎后台留言！]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web自动化测试 | Select下拉框]]></title>
    <url>%2Fposts%2Fselenium-select%2F</url>
    <content type="text"><![CDATA[在web自动化测试中，经常会遇到下拉框，对列出的选项进行选择，或者判断选择的选项，本文将介绍如何使用Selenium去操作下拉框，实现自动化测试。 测试页面URL http://sahitest.com/demo/selectTest.htm Select方法使用WebElement类的send_keys(value)方法也可以选择下拉框（select标签）的值，但它只能使用选项的value值来定位： 12345self.driver.get(&quot;http://sahitest.com/demo/selectTest.htm&quot;)ele = self.driver.find_element_by_id(&#x27;s3Id&#x27;)print(ele.text) # 打印select所有选项值ele.send_keys(&quot;o2val&quot;) # 选择value=o2val 的选项print(ele.get_attribute(&quot;value&quot;)) # 打印所选择的value值 结果： 123456o1o2o3 With spaces With nbspo2val select类所有方法： select_by_index(index)：通过选项index选择 select_by_value(value)：通过选项value值选择 select_by_visible_text(text)：过显示的文本选择 deselect_by_index(index)：取消选择，用于多选 deselect_by_value(value)：取消选择，用于多选 deselect_by_visible_text(text)：取消选择，用于多选 deselect_all()：全部取消，用于多选 options：所有选项 first_selected_option：第一个选择的选项（多选情况下）或者当前选择的选项（单选） all_selected_options：所有已经选择的选项 选择select_by_index、select_by_value、select_by_visible_text三种方法选择 first_selected_option.text返回当前所选择的选项值 1234567891011121314self.driver.get(&quot;http://sahitest.com/demo/selectTest.htm&quot;)ele = self.driver.find_element_by_id(&#x27;s3Id&#x27;)selected_element = Select(ele) # 实例化Selectselected_element.select_by_index(1)# for select in selected_element.all_selected_options:# print(select.text)print(selected_element.first_selected_option.text) # 打印当前选择的选项值sleep(1)selected_element.select_by_value(&quot;o2val&quot;)print(selected_element.first_selected_option.text)sleep(1)selected_element.select_by_visible_text(&quot;o3&quot;)print(selected_element.first_selected_option.text)sleep(1) 结果： 123o1 o2 o3 取消选择取消选择deselect不能用于下拉框选择，只能用于多选，即属性multiple=”multiple”的select标签。 取消选择有deselect_by_index、deselect_by_value、deselect_by_visible_text、deselect_all四种方法 all_selected_options返回所有已选择的选项 12345678910111213141516171819202122232425self.driver.get(&quot;http://sahitest.com/demo/selectTest.htm&quot;)## 多选ele2 = self.driver.find_element_by_id(&#x27;s4Id&#x27;)selected_element2 = Select(ele2) # 实例化Selectselected_element2.select_by_index(1)selected_element2.select_by_index(2)selected_element2.select_by_index(3)print(&quot;######&quot;)for select in selected_element2.all_selected_options: print(select.text)print(&quot;######&quot;)selected_element2.deselect_by_index(1)for select in selected_element2.all_selected_options: print(select.text)print(&quot;######&quot;)selected_element2.deselect_by_value(&quot;o2val&quot;)for select in selected_element2.all_selected_options: print(select.text)print(&quot;######&quot;)selected_element2.deselect_by_visible_text(&quot;o3&quot;)for select in selected_element2.all_selected_options: print(select.text) 结果： 12345678910######o1o2o3######o2o3######o3######]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>元素定位</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web自动化测试 | switch_to]]></title>
    <url>%2Fposts%2Fselenium-switch_to%2F</url>
    <content type="text"><![CDATA[在web应用自动化测试中，点击一个链接或者按钮会打开一个新的浏览器窗口，会出现多个窗口实例。默认情况下的焦点在主窗口（父窗口），如果要对子窗口进行操作，就需要首先切换到子窗口。 Selenium WebDriver给每个窗口指定了一个唯一的ID，Selenium通过这个唯一ID实现在多个窗口之间切换。常见的有iframe，弹出对话框alert，新窗口等。本文将介绍这几种窗口的切换。 iframe切换在web自动化中，如果一个元素定位始终不到，如果locator没有写错，很大概率就是这个元素在iframe中。 什么是frame？frame是html中的框架，通过使用frameset 标签将页面进行垂直或者水平分离。包含frameset、frame、 iframe三种标签。 演示代码：https://www.w3school.com.cn/tiy/t.asp?f=html_frame_cols frame切换切换到frame或者iframe后就可以进行操作，操作完成后需要切换回原来的框架： 123driver.switch_to.frame() #根据元素id或 index切换driver.switch_to.default_content() #切换到默认 framedriver.switch_to.parent_frame() #切换到父级 frame 多 frame切换测试页面：https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable 切换iframe，打印’请拖拽我’元素文本 1234567def test_iframe(self): self.driver.get(&quot;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;) self.driver.switch_to.frame(&quot;iframeResult&quot;) print(self.driver.find_element_by_id(&quot;draggable&quot;).text) # 打印&#x27;请拖拽我&#x27; # self.driver.switch_to.parent_frame() self.driver.switch_to.default_content() print(self.driver.find_element_by_id(&quot;submitBTN&quot;).text) #点击运行 弹出对话框alert切换在页面操作时会遇到 JavaScript所生成的alert、 confirm以及prompt弹框，需要对弹框操作后才能进行下一步。 操作alert常用的方法 switch_to.alert()：切换到当前页面上的警告框 text：返回弹框文本信息 accept()：接受弹框，确认 dismiss()：取消弹框 send_keys(keysToSend)：发送文本至弹框 alert切换测试页面还是上面的页面，拖拽后会出现一个弹框，我们打印弹框内容并点击确定。 python代码： 123456789101112131415def test_alert(self): self.driver.get(&quot;https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&quot;) self.driver.switch_to.frame(&quot;iframeResult&quot;) drag = self.driver.find_element_by_id(&quot;draggable&quot;) drop = self.driver.find_element_by_id(&quot;droppable&quot;) action = ActionChains(self.driver) action.drag_and_drop(drag, drop).perform() sleep(2) alert = self.driver.switch_to.alert print(alert.text) alert.accept() # self.driver.switch_to.alert.accept() self.driver.switch_to.default_content() self.driver.find_element_by_id(&quot;submitBTN&quot;).click() sleep(3) 多窗口切换有时候点击某些链接会打开一个新的窗口，需要先切换窗口才能在新页面上操作。selenium通过切换窗口句柄来进行多个窗口之间的切换。 处理流程 获取当前的窗口句柄(driver.current_window_handle) 获取当前会话下的所有窗口句柄(driver.window_handles) 切换窗口(driver.switch_to_window) 切回原窗口(driver.switch_to_window) 多窗口切换1、打开百度，点击登录，进入注册界面，返回登录页 python代码： 12345678910111213141516def test_window(self): self.driver.get(&quot;http://www.baidu.com&quot;) self.driver.find_element_by_link_text(&quot;登录&quot;).click() # print(self.driver.current_window_handle) # 当前的窗口句柄 self. driver.find_element_by_link_text(&quot;立即注册&quot;).click() windows = self.driver.window_handles # 所有窗口句柄 # 切换到注册窗口 self.driver.switch_to.window(windows[-1]) self.driver.find_element_by_id(&quot;TANGRAM__PSP_4__userName&quot;).send_keys(&quot;username&quot;) self.driver.find_element_by_id(&quot;TANGRAM__PSP_4__phone&quot;).send_keys(&quot;12345678&quot;) sleep(2) # 切换回登录窗口 self.driver.switch_to.window(windows[0]) self.driver.find_element_by_id(&quot;TANGRAM__PSP_10__footerULoginBtn&quot;).click() 2、打开新窗口 12345678910111213141516def test_window2(self): self.driver.get(&quot;http://www.baidu.com&quot;) js = &quot;window.open(&#x27;http://www.sogou.com&#x27;)&quot; self.driver.execute_script(js) sleep(3) windows = self.driver.window_handles print(windows) # 切换到新打开的窗口 self.driver.switch_to.window(windows[-1]) self.driver.find_element_by_id(&quot;query&quot;).send_keys(&quot;test sogou&quot;) # 搜狗搜索框 sleep(3) self.driver.close() # 关闭新打开的窗口 # 切回窗口 self.driver.switch_to.window(windows[0]) self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;test baidu&quot;) # 百度搜索框 sleep(3) 获取当前焦点元素switch_to还有一个方法叫switch_to.active_element，返回当前焦点的WebElement对象，用于判断当前焦点是否位于某个web元素。有时候需要测试打开一个网页，焦点是否在输入框，比如账号密码登录页面。 测试：打开https://www.baidu.com/，焦点在输入框 python代码： 1234def test_element_focus(self): self.driver.get(&quot;https://www.baidu.com/&quot;) baidu = self.driver.find_element_by_id(&quot;kw&quot;) assert baidu == self.driver.switch_to.active_element]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web自动化测试 | ActionChains、TouchAction]]></title>
    <url>%2Fposts%2Fselenium-actionchains-touchaction%2F</url>
    <content type="text"><![CDATA[ActionChains和TouchAction可以用来模拟点击、双击、滑动等事件。ActionChains用于执行PC端的鼠标移动、按键、拖拽等事件；TouchActions用法与ActionChains类似，可以用来模拟PC和移动端的点击、滑动、拖拽等手势操作。 ActionChains和TouchAction都是将动作存储在队列中，然后执行perform()方法，按队列顺序执行动作。 ActionChains有两种执行方式 链式：1ActionChains(driver).move_to_element(element).click(element).perform()分布式：1234actions=ActionChains(driver) actions.move_to_element(element) actions.click(element) actions.perform() 例一：点击，右键，双击操作测试页面：http://sahitest.com/demo/clicks.htm python代码： 123456789self.driver.get(&quot;http://sahitest.com/demo/clicks.htm&quot;) click = self.driver.find_element_by_xpath(&quot;//*[@value=&#x27;click me&#x27;]&quot;) doubleclick = self.driver.find_element_by_xpath(&quot;//*[@value=&#x27;dbl click me&#x27;]&quot;) rightclick = self.driver.find_element_by_xpath(&quot;//*[@value=&#x27;right click me&#x27;]&quot;) action= ActionChains(self.driver) action.click(element_click) action.context_click(element_rightclick) action.double_click(element_doubleclick) action. perform() 例二：移动鼠标到某个元素上将鼠标移动到“新闻”后进行点击 python代码：123456self.driver.get(&quot;http://www.baidu.com&quot;) ele = self.driver.find_element_by_link_text(&quot;新闻&quot;) action = ActionChains(self.driver) action.move_to_element(ele) action.click() action.perform() 例三：通过像素坐标点击页面使用move_by_offset()方法实现点击页面，像素坐标可以使用截图工具来获取。 python代码：12ActionChains(self.driver).move_by_offset(x, y).click().perform() #左键点击ActionChains(self.driver).move_by_offset(x, y).context_click().perform() #右键点击 例四：模拟键盘输入模拟键盘输入可以使用win32api模块，也可以用 selenium的WebElement对象的send_keys()方法来实现：1element = self.driver.find_element_by_id(element) element.send_keys(**&quot;test&quot;**) element.send_keys(Keys.BACK_SPACE) assert element.get_attribute(&quot;value&quot;) == &quot;tes&quot;ActionChains类也可以模拟键盘输入：123Action = ActionChains(driver) action.send_keys(Keys.BACK_SPACE) # 回退 action.key_down(Keys.CONTROL).send_keys(&#x27;a&#x27;).key_up(Keys.CONTROL) # CTRL+A action.perform() # 执行测试页面：http://sahitest.com/demo/label.htm 在文本框1中输入内容，然后将文本框1的内容复制粘贴到文本框2 12345678910111213self.driver.get(&quot;http://sahitest.com/demo/label.htm&quot;) ele1 = self.driver.find_element_by_xpath(&quot;/htmL/body/label[1]/input&quot;) ele2 = self.driver.find_element_by_xpath(&quot;/html/body/label[2]/table/tbody/tr/td[2]/input&quot;) ele1.click() action= ActionChains(self.driver) action.send_keys(&quot;testing&quot;).pause(1) action.send_keys(Keys.SPACE).pause(1) # 空格 action.send_keys(&quot;1&quot;).pause(1) action.send_keys(Keys.BACK_SPACE) #回退 action.key_down(Keys.CONTROL).send_keys(&#x27;a&#x27;).key_up(Keys.CONTROL) #CTRL+A action.key_down(Keys.CONTROL).send_keys(&#x27;c&#x27;).key_up(Keys.CONTROL) #CTRL+C action.key_down(Keys.CONTROL,ele2).send_keys(&#x27;v&#x27;).key_up(Keys.CONTROL) #CTRL+V action.send_keys(Keys.BACK_SPACE).perform() 例五：拖拽测试页面：http://sahitest.com/demo/dragDropMooTools.htm python代码12345678910self.driver.get(&quot;http://sahitest.com/demo/dragDropMooTools.htm&quot;) drag_ele = self.driver.find_element_by_id(&quot;dragger&quot;) Item1 = self.driver.find_element_by_xpath(&quot;/htmL/body/div[2]&quot;) Item2 = self.driver.find_element_by_xpath(&quot;/html/body/div[3]&quot;) Item3 = self.driver.find_element_by_xpath(&quot;/html/body/div[4]&quot;) action= ActionChains(self.driver) action.drag_and_drop(drag_ele, Item1).pause(1) # 方法1 action.click_and_hold(drag_ele).release(Item2).pause(1)# 方法2 action.click_and_hold(drag_ele).move_to_element(Item3).release()# 方法3 action.perform() TouchActionActionChains无法操作H5页面，TouchAction可以对H5页面进行操作，实现点击，滑动，拖拽，模拟手势等各种操作。 手势控制方法 double_tap 双击 flick 滑动 flick_element 从某个元素位置开始滑动 long_press 长按 move 手势移动指定偏移 Perform 执行 release 释放手势 scroll 点击并滚动 scroll_from_element 从某个元素位置开始手势点击并滚动(向下滑动为负数,向上滑动为正数) flick_element——从某个元素位置开始手势滑动(负数：向上滑动，正数：向下滑动) tap 在指定元素上点击 tap_and_hold 在指定元素上点击但不释放 例一：点击、滑动百度搜索关键字，tap方法点击百度一下，滑动到底部，点击下一页 python代码：12345678910self.driver.get(&quot;http://www.baidu.com&quot;) input = self.driver.find_element_by_id(&quot;kw&quot;) search = self.driver.find_element_by_id(&quot;su&quot;) input.send_keys(&quot;test&quot;) action = TouchActions(self.driver) action.tap(search) action.perform() action.scroll_from_element(input, 0, 10000).perform() next = self.driver.find_element_by_link_text(&quot;下一页 &gt;&quot;) next.click() 总结ActionChains和TouchAction实现了鼠标和键盘的模拟输入，更详细的介绍可以参考官方文档 https://selenium-python.readthedocs.io/api.html。]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web自动化测试 | 元素操作]]></title>
    <url>%2Fposts%2Fselenium-webelement-operate%2F</url>
    <content type="text"><![CDATA[简介我们定位到Web页面元素之后，可以对元素进行一系列的操作，实现跟页面的交互。包括点击、文本输入、元素属性获取等。常用的方法列举如下： 方法 描述 click() 点击元素 send_keys(*value) 用于向EditText(可编辑文本控件)输入文本；还可以用于输入文件（如百度图片搜索输入图片） get_attribute(name) 获取元素属性 is_selected() 元素是否被选择，一般用于判断checkbox 或者 radio 控件状态 screenshot(filename) 截取元素 点击、输入文本 打开 https://www.baidu.com/ 搜索框输入“test” 点击“百度一下” 关闭网页 python代码： 12self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;test&quot;)self.driver.find_element_by_id(&quot;su&quot;).click() 文件上传input标签可以直接使用send_keys(文件地址)上传文件 打开百度图片搜索，输入图片地址 python代码： 123self.driver.get(&quot;https://image.baidu.com/&quot;)self.driver.find_element_by_xpath(&quot;//*[@id=&#x27;sttb&#x27;]/img[1]&quot;).click()self.driver.find_element_by_id(&quot;stfile&quot;).send_keys(u&quot;D:/TestingDemo/img/图片.png&quot;) get_attribute()获取元素属性 比如获取“百度一下”这个button的属性：type、id、value、class python代码： 12345baidu = self.driver.find_element_by_id(&quot;su&quot;)baidu.get_attribute(&quot;type&quot;)baidu.get_attribute(&quot;id&quot;)baidu.get_attribute(&quot;value&quot;)baidu.get_attribute(&quot;class&quot;) is_selected()在勾选单选框（radio）和复选框（checkbox）的时候，如果已经被选中，再次点击就会反选了，所以在点击之前需要判断一下是否已经选中。可以使用is_selected()方法来判断是否被选中 python代码： 123456789def checkbox_switch(self,switch=&quot;ON&quot;): self.driver = webdriver.Chrome() sw = self.driver.find_element_by_id(&#x27;id_of_checkbox&#x27;).is_selected() flag = False if switch == &quot;ON&quot;: flag = True if sw^flag: self.driver.find_element_by_id(&#x27;id_of_checkbox&#x27;).click() self.driver.quit() screenshot()截取元素 python代码： 1234self.driver = webdriver.Chrome()self.driver.get(&quot;https://www.baidu.com&quot;)element = self.driver.find_element_by_id(&quot;su&quot;) # 百度一下的按钮element.screenshot(&#x27;D:\\baidu.png&#x27;) 结果图baidu.png 当然也可以保存整个页面窗口截图 get_screenshot_as_base64() get_screenshot_as_file(filename) get_screenshot_as_png() save_screenshot(filename) 1self.driver.save_screenshot(&#x27;baidu.png&#x27;) 其他常用方法12345678910111213141516#关闭selenium打开的所有窗口driver.quit()# 仅关闭当前窗口driver.close()# 前进driver.forward()# 后退driver.back()# 刷新driver.refresh()# 头名字driver.title# 获取cookiedriver.get_cookies()# 返回当前页面urldriver.current_url 控件操作123456# 清空输入框数据element.clear() # 获取文本的值element.text# 表单提交element.submit()]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>元素定位</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web自动化测试 | Web元素定位]]></title>
    <url>%2Fposts%2Fselenium_webelement_locator%2F</url>
    <content type="text"><![CDATA[简介Selenium是用于Web应用测试的自动化测试框架，可以实现跨浏览器和跨平台的Web自动化测试。Selenium通过使用WebDriver API来控制web浏览器，每个浏览器都都有一个特定的WebDriver 驱动，处理与Selenium和浏览器之间的通信。 实现Web页面自动化控制的先决条件是定位到正确的Web页面元素，WebDriver提供了8种不同的Web元素定位方法： Locator Description id ID属性，最常用的定位方法，每个元素的id应该是唯一的 css selector CSS 选择器 xpath xpath表达式定位元素 name NAME属性，与id定位类似 link text 仅用于超链接文本 partial link text 使用方法和link text相同，partial link 只截取部分文字即可 tag name 通过HTML标签名定位 class name 使用类名定位，不能使用复合类名 ID定位 python代码： element = self.driver.find_element_by_id(“kw”) element = self.driver.find_element(By.ID,”kw”).send_keys(“test”) NAME定位 python代码： element = self.driver.find_element_by_name(“wd”) Link Text定位 python代码： element = self.driver.find_element_by_link_text(“学术”) Partial Link Text定位使用部分文本来定位 直接使用“123”来定位： python代码： element = self.driver.find_element_by_partial_link_text(“123”) Xpath定位XPath 使用路径表达式来选取 XML 文档中的节点或节点集。具体语法参考：https://www.w3school.com.cn/xpath/xpath_syntax.asp 比如我们定位“资讯”： 可以在console中输入JS代码：$x(&#39;//*[@id=&quot;s_tab&quot;]//a[1]&#39;) 这样就可以找到资讯对应的元素： python代码： element = self.driver.find_element_by_xpath(‘//*[@id=”s_tab”]//a[1]’) CSS Selector定位CSS选择器是一种字符串模式，基于HTML标签，id，类和属性的组合来标识元素。 具体语法参见：https://www.runoob.com/cssref/css-selectors.html 我们依然定位“资讯”： 在console中输入：$(&#39;#s_tab a:nth-child(2)&#39;) python代码： element = self.driver.find_element_by_css_selector(“#s_tab a:nth-child(2)”) 完整测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python3# -*-coding:utf-8-*-from time import sleepimport pytestfrom selenium import webdriverfrom selenium.webdriver.common.by import Byclass TestLocator(): def setup(self): self.driver = webdriver.Chrome() self.driver.implicitly_wait(5) # self.driver.maximize_window() def teardown(self): self.driver.quit() def test_id(self): self.driver.get(&quot;https://www.baidu.com/&quot;) element = self.driver.find_element_by_id(&quot;kw&quot;) element.send_keys(&quot;test&quot;) # self.driver.find_element(By.ID,&quot;kw&quot;).send_keys(&quot;test&quot;) assert element.get_attribute(&quot;value&quot;) == &quot;test&quot; def test_name(self): element = self.driver.find_element_by_name(&quot;wd&quot;) element.send_keys(&quot;test&quot;) assert element.get_attribute(&quot;value&quot;) == &quot;test&quot; def test_linktext(self): self.driver.get(&quot;https://www.baidu.com/&quot;) element = self.driver.find_element_by_link_text(&quot;学术&quot;) element.click() sleep(5) def test_partial_link_text(self): self.driver.get(&quot;https://www.baidu.com/&quot;) element = self.driver.find_element_by_partial_link_text(&quot;123&quot;) element.click() sleep(5) def test_xpath(self): self.driver.get(&quot;https://www.baidu.com/&quot;) self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;test&quot;) sleep(2) self.driver.find_element_by_id(&quot;su&quot;).click() sleep(2) element = self.driver.find_element_by_xpath(&#x27;//*[@id=&quot;s_tab&quot;]//a[1]&#x27;) element.click() sleep(10) def test_css(self): self.driver.get(&quot;https://www.baidu.com/&quot;) self.driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;test&quot;) sleep(2) self.driver.find_element_by_id(&quot;su&quot;).click() sleep(2) element = self.driver.find_element_by_css_selector(&quot;#s_tab a:nth-child(2)&quot;) element.click()if __name__ == &#x27;__main__&#x27;: pytest.main() 总结在工作中比较常用的是ID和NAME定位，用起来比较方便。但很多情况下没有ID或者ID是动态变化的（比如使用Extjs生成的web页面），需要用到CSS Selector和Xpath来定位。 Xpath是一种XML路径语言，定位时采用遍历页面的方式，基本上能定位到所有web元素。CSS Selector 是一种样式表语言，查找 HTML DOM 中的元素。理论上CSS Selector比Xpath效率更高，个人感觉没有显著差异。其它差异还包括： Xpath可以通过文本来定位，而CSS Selector不能。 Xpath可以通过子节点来定位父节点，CSS Selector是前向的，不能利用子节点定位父节点。 CSS Selector语法相比Xpath更加简洁]]></content>
      <categories>
        <category>自动化测试</category>
        <category>Web自动化测试</category>
      </categories>
      <tags>
        <tag>元素定位</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简易教程-安装及简单使用]]></title>
    <url>%2Fposts%2Fgit-install-and-guide%2F</url>
    <content type="text"><![CDATA[Git是一种版本控制器，在项目开发中可以用来托管代码 一、下载安装Git1. Git下载地址：https://git-scm.com/download/win 2. 安装检验是否安装成功 电脑桌面或者其他任意文件夹下，点击鼠标右键，如果看到Git GUI和Git Bash则表示安装成功 Git Bash是为了方便你在windows下使用git命令的模拟终端，我们可以在git bash中执行一些shell命令。 TortoiseGit安装git GUI客户端有很多种：https://git-scm.com/downloads/guis/ Windows平台推荐使用TortoiseGit，可以通过图形化界面操作git，下载地址：https://tortoisegit.org/download/ 二、Git配置初始化配置1. 配置用户名和邮箱12git config --global user.name &quot;username&quot; // 添加用户名，username为你在github上注册的用户名。 git config --global user.email 123456789@qq.com // github设置的邮箱地址，改成自己的邮箱。 添加局部用户名和邮箱12git config user.name &quot;username&quot; git config user.email &quot;123456789@qq.com&quot; 2. 查看是否配置成功1git config --list 初始化新的Git仓库 新建文件目录或者进入已有的文件目录下 可以通过cd的方法进入，或者直接在目录下右键-&gt;选择Git Bash Here 创建Git仓库1git init 执行成功后，当前目录下会生成一个.git的隐藏文件夹，仓库创建完成。 三、Git文件管理 查看git帮助信息1git help 添加文件1. 查询状态1git status 2. 将文件添加到暂存区1git add test.txt 123456git add file //跟踪 -添加到暂存区 git add file1 file2 file3 git add folder/* git add folder/*.py git add folder 添加所有改动文件：123git add . # 添加所有改变的文档，包括文件内容编辑(modified)以及新文件(new)，不包括被删除（deleted）的文件git add -u # 添加编辑或者删除的文件，不包括新添加的文件。git add --all# 或者git add -A，添加所有改变的文件 3. 从暂存区提交到本地Git仓库1git commit -m &quot;add test.txt&quot; 1git log //查看提交记录第2步和第3步可以直接使用命令:1git commit -am &quot;提交注释” 删除文件1. 删除文件1git rm &quot;test.txt&quot; 也可以直接手动删除文件 删除文件夹1git rm -r foldername/ 2. 提交到本地Git仓库1git commit -m &quot;delete test.txt&quot; Git分支创建分支123git branch yourbranch //创建分支git checkout yourbranch //切换分支git checkout -b yourbranch //创建并切换到分支 合并分支12git checkout mastergit merge yourbranch //合并指定分支yourbranch到当前分支master 删除分支12git branch -d yourbranch //删除本地分支git push origin -d yourbranch //删除远程分支 Git远程仓库可以将本地仓库备份到远程服务器上的git仓库，实现代码共享，下面介绍本地Git仓库和Github 远程仓库的连接。 如果没有GitHub账号需要先注册一个：https://github.com/ 本地Git仓库和GitHub仓库之间通信采用SSH协议加密，Git SSH公钥配置方法参考：同一台电脑配置Gitee、Github 的 Git SSH公钥。 如果是首次push，没有添加远程链接，在github创建新的仓库，然后复制仓库URL链接：1234git remote add origin https://github.com/xxxxx/xxxxx.git git push --set-upstream origin mastergit push -u origin master git remote remove origin //取消远程关联Push新仓库123456git initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M mastergit remote add origin git@github.com:ZHHAYO/vuepress-blog.gitgit push -u origin masterPush存在的仓库123git remote add origin git@github.com:ZHHAYO/vuepress-blog.gitgit branch -M mastergit push -u origin master 1. 将本地仓库同步到git远程仓库1git push 2. 将远程仓库复制到本地github项目\仓库地址**复制： 1git clone 仓库地址 将远程仓库克隆到本地后，会生成一个.git的目录 查看.git/config文件 可以看到当前本地分支为master，git branch查看本地分支 关联的远程库为origin，可以通过git remote查看 远程库origin所在的位置为 git@github.com:ZHHAYO/python_notes.git .git\refs\heads\master文件内容为： 7cf7212890aabea789631a02881861dcd08dac46 表示本地仓库最新的commit id .git\logs文件夹下保存的是.git\refs文件夹下相应文件的变更记录123.git\logs\HEAD.git\logs\refs\remotes\origin\HEAD .git\logs\refs\heads\master三个文件 内容如下： 3. 本地仓库更新如果远程仓库更新，可以使用git pull或者git fetch + git merge命令，将远程项目更新到本地。1234git fetch origin master git merge origin/mastergit pull origin mastergit pull和git merge的区别参考：https://blog.csdn.net/a19881029/article/details/42245955 查看远程仓库地址1git remote -v 报错信息git push报错1OpenSSL SSL_connect: Connection was reset in connection to github.com:443 解决：1$ git config --global --unset http.proxy git clone报错报错信息：123$ git clone https://github.com/hiyongz/GoProjects.gitCloning into &#x27;GoProjects&#x27;...fatal: unable to access &#x27;https://github.com/hiyongz/GoProjects.git/&#x27;: OpenSSL SSL_connect: Connection was reset in connection to github.com:443 解决方案：关闭ssl认证1$ git config --global http.sslVerify false 四、参考教程 git - 简明指南：http://rogerdudler.github.io/git-guide/index.zh.html 廖雪峰git 教程：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 --THE END--]]></content>
      <categories>
        <category>版本管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白盒测试方法介绍]]></title>
    <url>%2Fposts%2Ftest-theory-for-white-box-testing%2F</url>
    <content type="text"><![CDATA[b63abfd0cc043585c7f59d942442ea6d95626d0322384ef6387a416e0602e7b45e817557f1992b34b463fec15367c2bb05da955a0449e13f6ea80ccfea701c3b480350e141d0aa0b79afc142a787b2c8867f39105d8e176b1ef031e910a25c152a5810351c73ff93cbe7127ab4c461dc399f1069fcbe16614330e35940435be4f31b70898895516a6717ef10941525a99925d29effb1017a23845aa8ae377ee7a52ba5d1ecce22c74b7b91fdfcbecad9d9645ca0417df4a9841b58051b2b23f2caf397170e9ec833dfdde33074e8a5d9274be936b69ba7cd17d443d045256935a8c14cde4a578f67f75df31429921f40913581b9eb7b3aa0b3c749217cb524083472f85a9663005b20f6469440b5544b2ed05c6a52d813e1a9c8efb7991fa5862ca973ff90975e526a6c676219428e414a1d57c0d650d00d615af8abe17dca8f05cabc802b3bf74d87bc69dec2b3634a66b02b5ab54f2668d6127ec1ecd5b0b46631ca66ebcb4d276949c4e65b469be11d763d6234f3f9d00563346a283a2d86b62aa1adb508a7bc768b4ac7d2f2834b9f7b439f9385e0440fd738401575e3d952e38cdbe2c394b182af8e7686dd447e9c742699daa4f16993d3cd0a66f3420995c43e3308b3df9b622ac16e8608d928dbce10eca8fd5b2dfb059be9a5f76c810c30cf75455dc7ed5e12d32df6c004264bac518f8bbdc4622da605ea2f8c3a870c6ea8ff67bd8eaabb0a2d9bf4220032e6f38084074afe4420142f810ba7d7b07f1c72d1bc4bee9285e9305369d23ee939078ac8663e2b49c4daa3fc0954fd01324ae6fa073f8cc846da8d06150eebd6e365e8cfe67602a2f6cfa80b61b9e48ddb53567e2b861f070ee0132ac49db4038efc993801d0bbd07eba3dc90009167a44a6a8abe40cc1506f5f7c026995803f8ea613fde29a6e499564553f556d2c1797501b386175019f6c102cfa7d7235f310dfe58eb9a1d44457e9f17414782fc3de94c2f95b84c8c9759725fc6a41bfcd13d32c37a9408a31ba5e16bc0cda6bcbab854a4803b9cc957458f771ad4356f15745c1000505e6c3a91e401f89f83661ffb63f9c89a5f4142de79d1d958907edf46d1ef4c14df84b627a96e898c6208de784f7e25da21ed03978b9fc0244402241f165e263642b6fc329dd20bd3de70d67d75353a8a05a875053dc8b313074ae2f11c76cdc5f29a039b10ab4254449ec2bc6e248895ee5ee008be43b9cc194119cd52cca4d9732e8a3d5193247c9038ef48958a8a2c69ff00362785003ec3d6e6bb44646b22d1cd1fe5393c1b5943d416011faa9c885b3c9e0438888765cc61ebf70632f42c3b9a5a02099a54b96262e05e1b4435c1324c062574face6147d5b8bf6038d8075f7370f3095097f0493284792c3dfe22c4028dbde01dc94fb0582e73fc22234abbdf2f87e684ad65f2f35391a4cce1eb8e4c746d09fc133ffe5f460cba06a18e36ee378171676846760ec0ce9cc47f97d64335a3d5085da23e9fe7bb9ff1c590834153c6c5fb6e4a2a8c35a3ca17ced4ee87142e6f434bb3a8b75dca3738cde192131f1e6605482014947b9975ba52d877f35c902992ffab20a6af662cdff8a6ff8e8373687508581f7ad9716e687d1e58f5cff5c9c585668db81b55fff58f30d6fde755ec7d494e3e98000c0ff36b6382ca29eecd6fda331338d94c0eb41d9ecf693ebb55fa9392f8bd23b76d3f8ff5b20fa71cbf5cb0b66e90600068ad78d47522d80e7a60b66d73ee01c9e014cacccb5e846e2a992fda98b602b77c4839316a696daddb0d907f9690477ac795c616ec15a67ebf4c0791e4347858a5d38ba00e76e99434e230e0b977e96c70fb785d1224a561475780038976b3ed94954efb906bccdeea2f1a123d3aa3f0d3a7a04f7af5bae2697c688975855ee88d966ab9a6d2902709c12fa12ff2986a79e805542bb6c52dc55a1b69fd08774dbb8fae704f0f7bcec1cdc7c1d558c7581612e7ae0e571bd323dc4f9cc29440b479e7d927b8800d9d597b188cfeb55ec3d9175bf332ea99c694cc3edec64af1bfb305fe79d0a24527adedf802209de48951d4ce146862c669dfac28fbdbd0fbf9615998128b14be7dde48c151081b80d60a576d605cb155f826c9e223cdcc04f859d2a8785f3fd281e7eb9320f07bd0203cccf3ef1772599a696e0ba6c8f5e79b2a0d77a49d28ad46841a3b697723a5cdab5ade45d22fdc5d821dc6cbc12a497e8a0f507051d88a2d53d750c68bf09f402f3d3933cb0b415a3588995f44c493b157ce932fe60bf1b7970a39d01e81ff72448182e6a86e3803a6c623de2b93795882b2a0fe050721264807341ea04c68702b987905d7cb8f6587fb9e02ba3326ac5fc44db4028c5dc034beafc8e1329351bdd24006f9259aa2f49eb2c33139779e92434bf3ba8b1ed2c347d281540effc43c0055c4f40a1f25d43b6b930ab98c1f0e580012d50eacaef0bba44a0e49912ce060ea41ee4f40869a6f477324307384c6c20bec31971059aba9610ab037e336cde04f4075ac2974524ee704264bbc308e8073e128afd5e57abda50fd3fcad27647f39e2a7d3f234e9fec90cddedd66f76768c0b25e5648dff31b9efd3dc21c6872cc2f05f150547a26fa2b3c88fbade5f1bbb5e2d6dc8d3142f65bfc3c794ea2bfd6e91dea2eb69c3a0691a1befb95709276a05fe0b2e7ecdc3d45790ad61d6f4cc0017c37c77ee32d8ab6febd47e94bf11ced5a1a41210a41b42eb6b4cf350cb0ec73a0e0e8720c5b3d9c5c45c085f4d92601efc8339321cd65585afab330b88bed889f749384366d7375d967eb79502cbf17dbad56e5ba23ed1cab8027bb3f5b35117d5ec5307e346adabfdb4deb82a733d57cb0ffd031dce4bbefda72c8e8bdef1e3605b6739d6acb838cf478eac600c9113f70695f0ffcd0ad78f90e295e9ebf0105d7fd78273babcc25b8d5761f1b335020e4ea82a5255afdef5f481c48917d30ec07850f0247ced0879293f29a73684d4d22362d5539fd4bffc7fb4bfdc64cf7a382e7735084cfd560768f5a98dcf672942d9b13ea394f3249ec648ce79cf50a4f344e11e14f2189d973ea913e76ff9fe09b0d727e88380eb9c15838535868863daff9882287854bbc47ebb5b33b2c2ed7233c55e8e03936527304a46e679480df5e9efecafa6d25054da64b924d5fa2f3cfeaf119a0b681fb438756e545d10e9ca7a70e2c798cb848254212153615893130a7e19a5d3d57cc5b24204a1a07fb4e1fb1b53b29aaaab72424a00c15d6ea850d3bd4a497dde7e937db0b3b726676a2820f908ba07aacbe5be7617d0c258ca709a151246ca5b846649bd57d2148fd3f2876a3a7b74831f14964ea9b6dd3ef124e967c70e47badba4e9679872bd4e388a7d91d7840bd836e47e4e9167f9c9d6f316cdc85addceea63217fe2b8132ebde0e99d08e0d2047f8b33f852cabc29bd229590fd17e68869130ff03be32989cf6054f57ba53f6fa886c2b8b20220b241d0b961fcd17c9c1b907cfd64d614d0cd44e08fff308e6fccfcbb4cc2bf6c2739ea37e3495fd17064b5b328e7179e5d24490315bda168b984a4af8b4a7a5af07103c7785fa32eb7097b0b0209a2587894b000e22276ae7b36dbe0895ae244dd7b8b647248353fddbb5cacea72f04a136c97187c88bb2294f35c18420e0651bb8fb9e379d0f5da53974a07ad83cd85a583d22632d8fe23f7b75b807a8ae3bd82358d971cb1aabd79f7173dbd20a8ddf6d3f1e48ab5aab0928359bb4af4aee8ca682894b604f03dda5fc536328164ba6d8fcf6ba11fc1a8fb73bddffe2c2bfcdc6b8ef0fb57a30c94a622bbfdf70dfb17d72a620f612e9b26568163fd5586767023732674cf92337ae276a00052e0cc53d5a7d56acced032d00d13f7 Hey, password is required here.]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>白盒测试方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑盒测试方法介绍]]></title>
    <url>%2Fposts%2Ftest-theory-for-black-box-testing%2F</url>
    <content type="text"><![CDATA[b63abfd0cc043585c7f59d942442ea6d240247a15507a3acd7c7d5ba7ed651b42058016a2ef01d8a521ed5a65198751a33f294db0cafdad9cec98fe3cf32faefc51ccd9fd3e055003233c6b7fc472b70a18d7001ed152e3c55ac7011218784fbfc3cc59866f5f1ce70ebba24a249957476050a8bf7875b53ef6462b880c5b70280b181f945cbd95a46187610a891379afd1935875dcee54e3e5328836f25f9b3bea7e2de0d5a65229846c4134e7dd281cfedb57b6fe4b8a94cbb1fb7e96a20038c5c4534fdbf76d69ef8a767f05a22a6ecb47f97eb9743ed238fc80c7ecfdbe5e367debe800d42af47fa065b200c9c98648459fb70b64ef1868c78c58680202d3410aae3d057a675858a7f438af48075db4996ff141b895855864aa4055946f5a89a9e50031ba5f9a0291ed5d37afae81a9c28c76e9abffdca7ed5c74a0ad317813f1fba3288b5dfdf65c3c690f7aa05d1ce3b0edc5e9b51c6677976479cff3c5c52d3a0e89b9653a35b4028e28e3d521129ef0edf13a10ca67d5e36fe7698e71ed0b189ed5ecf3f14ade3aa3d7d9575107b557ccde1389853afe5d971eb8d76b9794ea603f230233f9de98d47c78903283e29fa576f6ab2951758c37b996166a6b9dbde183ec9774c466eab1ba095b7d85e7bb9a7bd648300423873342b7122ca568d22f9172ce253ec50d4b3e363230728285c8a2e04e4cdef79baa5c6de663350cee90b81901b9dc994319e8881e13d28c876ba28ab9f856ce7acbff733cf367459b36da44322f8715cff3936dfeb74d4b0917490ae54a7aec924c4bc08176ed4756eea81be7f6486d93ba39f4029f9d64d0818c3d67d8c4a21b3ef61e54f9a4a7d4d332493c71a9bbbfc1a03f09589920b409317a469803a35f4de03d1d37656d6cd7038ccc7a49c29218679f0624ea4a89e4b269afa1e30cbdd089113c1716c5c1cfb38919d576bd86a1352accf2cafe169068b726c3f2aab36e0e1e09d1730fc79161bb5c19e28afdb7bad743e024d824e47b72d0ba2de396caade8e57aff2f9ca776592d486b4eabe8e785da64307d946cdd78da88ada265765091b835e3baec23cfd1c4357d12ae79529a10a103af05e8cd473799e6f002f4b75e886518106b15c0f629b8e7b5a69af800cb54eea08cbf8517032165690837b5ba10d0258c1d13f806ac390e79206dcb90f268fa17d46acef06e50da4db33d9563c94592d829b195d2ce15b28261100477bc48d0e0e9438a389e4265e517ef6f7e4dcf6cabda79955e2eabe3ac0b6dd5d5ceeeea6795d5c1819081b862a5689cb36ac7dca67b89d4e1282e8e35a73d7ae821cc41b4d8a30fef3a0a689a54f30bd1e6712236e154d14f16263ea880f6a25e4fae5601f4ccb4781e83888b2d1cd343778cc9d917e5ad1cb85cf4899a4d021d65e3274c9cb95ac3aa8e2028f03338a7a1141667fe5b59ba99c0c32f2b67f4e6345fab96ab022be156e797108225f1021944690eac64f8f7d4e9b4079276c58f03f672ed452f8d88504a02bd232eb467723b52c584f91b1f69c8a78af76bce2d8c6480ecb11805483a0e06b92f39164ebd546f2a04e735ee844b2cdd1c062fd827130361a6fbb1fbeae850fd45f3cf1e3ace7f9fb504d5c0bead291774a2bac2a7c97411a373873710eed36aa3d9e6cbdc904285f00524b8635ac7ea1596dc090de34e26494b8caeda627014be68e42d0945a13291fd6c3bad6e2b56f6842a9a923621930541adf4c47c705367cd117efcb07d8a9ab40b7629c2a060d29ff7d7592fa20e1846936a74b53f1d8ab00843cc798f32f60b9fe65e9a686f4f97d5d816f8d48d04acb8e4185b9d6de0d76b5a30a0d6574e0edcecf11b52e19a37484d78243966f5b8c4fb47616f3a91a45da03b0983eefe3f1350ed3a72a7f4d89c57b0648f7e63daf43738e491e10bef831d397a640fb6a4b5f2c519fa54d48e638daae59c4afeaadda82a6b9a828fcfb4e8a260d13f94c724f706e5f044b7be48ac9fa1037303103893306ad70246a1498a1a7f1fe9991d719eab53fad603f3cb02b5205932a0b0a9d78abcb4a1b8f7bd3dabf7a08eb7cc28d1ccc0c97aa2e1034f5088b500f30bac0f7c1f2d2455dfcf22c5997393c5ec4ffe825a4ed145bbdfed42fd8fbf695e09236a7290529b01ce896b0981a7e9c58f83bfa5c83050e3dbb4053d352caa44e06ec75b1db321f5fd690d6ebe4c8f5842c22787e8f43209f4e7c5d92b4169c055810052ca88c4e4a7cf981fad7f218d5b994f741d85d5d5958c48e9bbe9d8c1c5046fb0b20c80555ddb5a0919dcb1a3507928639c2f5c21b8cd4a24b58b2fedfb149b37d3dbad6e6773d4565be444ac6274e879b15a9fd1a4827b96d56ac71d29092e4cd2aad21584f4e1fc799db207f2897708e73068c9afab503f4c41666bf1662f5452ff9bbab1c1494502353f5898cf0009e02b539d551a8c1f872448b8ceda7db59cb5bb56a49649de99439cb5433440fae74122ebb2c63f448c47a69e06b9f57d5308a994376ad8e70e7d88ca634ea954d901462a1164457b3f938ac18947f99b38f973a2df9c6d531a422f7bd64e8dd681d0127c880a157897f2bc78369d52ebe23e27d7390a8816eacd3d042d83d46006a1a5a19071cec2a3d63e2be260e26cc1ce4a37fbe1b38fbb6ae967275bc5c37e43cd9b11d4487c9b291bfec54ccc61365746e23e518691ab383fc8d09bced328e7bed2e7537763b70e037492a31aa9640889d47cf803d5c60f2b16a870b4914ab8c5d1f833138fa027f3cbc20da4b7716bbeb9e2fecb7a86588acd7d27820134b16e362a5d9112bb9cac1cb7724a86c0f487e1d664b80fa9e8b1c5b224055ce2794dbd2fa9d854fa97b9e98047b19600a5229481857978ebba28dde43ec97485c0adf9f3c33f0c38c66a6cc9e1f1520776d745af4bb627e5b45c31707b862186c21bdd29eb7a24bfe4742e570de0939ad2c616dbbf213c1deec617bf546abce10c2b925cd2f25e5c098d03dac347ec2ffbb1b02eaa60195770d3cdb17d1f00a64e2f85e54352731f190e0cfee2858606ba95d8b630b26889f9f7c5d65b49d758af80369da9ef5b2c5cffc4091681ad109eb9848c58eeb7fff75b83309ff7fde67fdac37b24fc0fc73b7d01e6138bff91d50588c7a188831ff9558c8690ee07cb952f4c30d87e5b4137011ced72b756f590c4da9452b0a45cbed7f8763d111b6d7628b9ba9351001d3dbe31ace3217b61bcb61929869b6a0b0f3969407a7a652681a55ca46752e1d28baaa10eff5cf37a449ffc6095c2fa541cafe78aef3ac53a8c8f527378b83860d84c6a7443a5f6a5656c352f4052172c2092aa44f5c753448df5175a295bc3eb7bb073543b82822a2cc720ac45dbbba4e9abe88f03922843f6dcfcba0487b6f39bc118e8d2a6dab504f3c699df537e737379303d6049e01efdff5a2cb9889421f872927ae313d755a5bd3486b5d2bee3eac8d43265630937932b08a15502bb56d3dd9770f859193fd00ad127ea8e6fc3563b4fb41231f5e9e7f864397b5e5f410814b737685d7fc158f088eadd590fdcb9020b841a90268ff4b5b8d9b92974ae8133f43b62010a7437383be4cf1fd0bdb4662a1082133f2729e2bf9f6a24fa8db458556a19a398f2b30e397661b5312e0a919f5b2891883eb0ebfb3150bb9120e4f99fff6499b24930c7cb6ec72b9d6a211fac4e0b69aa7527237878460d6430bb7bc1d368c8d81e431d342860e7c500a52b036d759115d1c3396d89670f4a3e6da01419d4f3b3c674b25acd14587ef27efc6a443f7c5fac326591f455edbaa2e845ee7ae5ec491cbccb65023f8dbdaefbe137036ea711ba68ce0c4fd56b9b1984936cd874f66f5c83ad2c839fd373692fdb8b5c96dd4024561a3004f357f3513192422a24d1cb06eb21709076b2e94ca029a23e5fdf30cde9360f88b93576ad568b7ca1a066b4800790c312a86535409264300f8ce38d662a709b8ca8aae3db331f151140fe08e7c3864db97f2f4e0f0102cb33c920f1a1ff85430954793a7d637a8927d9b92a2b353cf78f288ad9f343537f9da78fdcbac22f9bde2cbb731cde9e7ecb2d7f883cff2a5b36f4c1163cc0537d5c846764dff8b0daed089ac8a7db9cd1f112e23cd3623ca295794104b39e11e474101bc379e328b7483d1dddbc53042fdd3f7bc8bc849e5f74d211ed092858c1adb5944ad2f747315a4c42145056c8bc79bc29b50a8970dcfbc5c8f88240711c9f12eb08b9133bf9338751db5a44695fa54a245fc554e2ff0d2ad1c4b8006e984581ae09dcd1fa899fd13368ed426d970d6238b298a7ced476ac708a33e1f85263c8cb8fe593eff61a782d7422ed2212a5fb5bd09a41a2a2754745b3bcac083884e91275c72594acad56fdd5d19e2f0e6f1666815e30ced36e49bffbfb7d69eddd6208a8dcf8d9923352a844ec838cef15b01b918146bad979cb1c4212153b7853bc4eb11e71396ff2a45b4e5587c571934c9e367efa8a8cc7f3aa352ac07bbfbde0f74c38f3ee1dfe4a58c217aae954c4f8686da22a76627e8bc044c625e8b16b6f8c78c6f80ccafd38e4b7fe39721ef05a7c43f61d423c252ed9ae3200d990e251b8eb6c5cdc2823504115d19e1a79da434aeaad414512e8c9cbb63b539a431a0d7813b1ac52b51a1be6eb79305cd783ef0ba36a4320a1d102381a934937d2598f040f800d6dad4c15a481c96af2f4093b2258c44c4568be7042fb9636de03fd993226d42f4b7d6ef75427b95314ea39ac1f389d8521178d2f63ca84fb076e02df56098560d7023a132fa726fa9dae361b37e86871a8459d49b277eef286c8110a877f91598172044b41c53827664eb7d240412a3bc944dc4df777f9c04205ed74a528f95f8d4141f647b627156115db63b389aeb43ce6ba65c88ecf6178532a01436db3a3a6acb311fcc13ea709536ac52abe3b07bf61dd5dfedfb76dac6dae6da9e820730893808bd339322663da89df9d8cd1acb1e224ead60def4666d991f450ad6d75a8ead1853635770515f5c82eccc7736bb590223ed33e1217871d89d21640a63b4bd3ee9c83bf35a70c74abb3e1e0a8a935deef57652043daac8dd88602b4ec906439f89086b17c63b7ebfa29cb88094558822deb68499e3c1dec00475972c8bda240ba4392e6e3920a20e085ed954fc68d473daa701b4d29d3becd6132b75f847671c99a1948b1e3a4c3d52c53d51ef85e53070248b8e120107153e1ab5ae8da2e3d3c34d4e18025de6c3b7706040e940d363b0facb8c2ca669df747043d9eded5368f2c82484ab89308513fc86db308f296c0e70ab142a043ba83aa52522bfa19453580e514b4627302f9ce2b71ddafc536547e9d8c13660bb5bcbbce3643ed08bd8d098bed17dbf5f757c70365d65802116b028b324602fe585d1490991684b47064f1974fff50d1248df9d26692bd6c3296fdd07beef6e7998f40b978c30989a44a090130ee4b3e2d49c4d0b5a2d0788c56424cdea7888022901d91e94df002c1a4f257e3e3dd7812a344832393fc7c0050f4cbf1754dee58d2749ffaf8373bbafb9e04d9f3a9253c3c74b865a5d698162a58ca60b5ba685385a70c119522212464d38012b47002990f9c0203214ccc9599927fc8215bccf0d3844e19e59d9da6d2e2a63a9e173511e0fdc9f15507326d0d27d7a639fd64378f54efb472291594d96b220477e23ea36d4028b070f1abf1404fa50b0a5efbecd1178c33e68df657aaf18c3d2e835696fb6e3c80223cfece5a02500e9ce95e4f433b5bbe511e0d7b4ee31f26d377d1c0ec8e9863ca11cc7b9fa1a8587aaba017eb0fb6efb657cfe743f2554ba47a0f6d6bfa85287b2924582dbb19777b566a314d8a98ff3db3846a81197d96d5b0b60b6eb3b06da70ac3769ba3320a8237c2dc7abcb09ac35bc3c9596f46dde2f99d20ab3f684c756d888375c3cb3854ba7dce192bc45ecaca1ae4cf5f564d621315064cb27c036ed243513c5aa5c466c8cf89da27f07b371bc65d727d770d02bd55bb3215741a182bd5fd185ed809c05e990e23708f8f6597ea8679fccae21db5d2d570a2025f1f9aa563dabd055ad6a4e36f52dcb4e9c5595cc0a6cdcdb5e7e9affae30a0ccf9e9ad170b7fbbb7fb87cab4d121a2390cdcc39f318aec0abd88e46315953c7af6d068d7f1659b60c859ebbb4b7321553cd492d2e56da881b6426212302c1386833ea7b16f0ff8f29b87550495dcae66e9c54c90424b439e6ef469dee19f96fff75297c1c497bed76e0d5d900d02cc0411a5772fd16a512b8abe303676fd647503c75fd437c84e92ac2ee0a18fa552aff1d9beea66f1f1bc7d1a82834add883534386e0f196657a07eee70ebc3d1c0b7cf1e7eb961ed344729a3bfae2d75ddfc69c07ac9c97ebf4224b7803445be97b517f069dd4cad72483580e23f39368b3601d8b2d48e59b19969c1d82ea7746f387aaa04d345f77f84cc7bc8b45ff61cb6f0f5b84476ab61c4f84975bad655d0189df3572136eea5cefaf63a39071a521eb6c8786910c75fd6dba6014c121086d8d818d1816f29559408c7e9f1c6c57644b3c5976631d0a5013a4b60aa66aefb1ba5077f0640d91032a64eb6bb9edfb0a98770e7600af999379f07d10e2fc03b90dc1ce0c1f6318f8ea5ee11bf46e9c6ce2eaa8c37265cc544e74e44b91ebae4ff20d5570f6d02c7e89fed8516052fe57c7bf06005331d8d6eebb5788f4820390877450c627d671c71bf3f62ff16b2b18b91f5d636530262e2120a840293e7a91e0d8386c1585af2bf4e6a184dd2f56aec0a9ca75663a91b0904215cdd0f8a0a8022bc89be05c13a71893ae2bd84071a3da1e3d17da9bede6483251dc4cca0a27cf9e95c1aad041ab92da8d3c535723736ae5fa8b19303a2cb8635256798ec7ff9dfdd359353ec9b0f062c5bad3b85a0b0e7547ee89388536fb18a40dab16401e6b7325748e625d62d6d4371e85b38c0cc1c010850c190a1b44ccca6ea74fe152efa19c2d96e1fdb86a7759411602ab214bf7aa8ecb8d9da7a Hey, password is required here.]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>黑盒测试</tag>
        <tag>测试技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用测试平台]]></title>
    <url>%2Fposts%2Ftest-theory-for-testing-platform%2F</url>
    <content type="text"><![CDATA[b63abfd0cc043585c7f59d942442ea6d95626d0322384ef6387a416e0602e7b45e817557f1992b34b463fec15367c2bb05da955a0449e13f6ea80ccfea701c3b480350e141d0aa0b79afc142a787b2c8fa6f6ab157248da45d590e316b708788c01043c17f3e28214881b859b0236b678939bd04073824f50ac689fde8d316c4a31faf38b03cdb8130fb17ef6940c3fcfcc105cb0a8ca8cfa8e03d6b8e9922c85d271566cf1930a69945b328d6a4a43b1ce37f23567dcb3fa90a8f26c33da4fb5095a533108d3626c75b39c04f018ca6799cb7832e89fabdc121132520ef9f2f451bd2862893a2f485ebe03cc4947952062e8a03d9a5c8a3251caf5da732794faf3af904739605a33f40bd23a6487ae9c57b5670a2fca8aac6af957dbe7f38448b4c5854b50a1bd8b506861099cc22e2c8a31789ece3a2b99d89a546b41521218e703453b1b00c1b90b6e2265290dcbfbd2e1c19baa194537e7d8d1cde830f79de62dbf54d78a817bfc583e920fdb2b14fe32b46ac5fc20bbbee52d2e0d5f31e8b510fd9b16adb7ca15ce60f2bd12382ff82d831937527513ac037e3d44b74b8ea39ae0d93224bb474e27fa34928f9bb047c97d3459dfb0a9840aaaf0a5f4907465d211842a7a65716326becd82e6a8e877c65498be5656b8f6afd3badeb99606ce08c2f1294d73b8417bc3911bd8830caf2dc2a85e8bdb92595b4dbd817823313fc18e5cfa47d169b5e48d13121c956ed1f6a5d11d8a4b94aae6b4f92f64a3fa6a3f2e2d7bd7233ab2bda6a8dcab3df0cf7e6421e4981036f5b7188becd09b26e2867d5f1f844973b9c11be469e834cdd8e866b2a47db5607c03b35397d5338085998d21439fa76f6aa1376bef45a6dd7fa2e790a8e127121365fa04b423e637fda63943b8e75471c5d17edc6c56eb3c6d84b9e13663087cefe808e5fd80fe2f7d79ff38409264504f4d8d2b68fcbaec262e3a9e8d7e16e29faa0248305022436701e747b671998961fc05083d8c9ffe3ebaa28b180588b8f682a0391a01f5a82137ccdd54ae33ea8ad167e5be5722a262c6e4e1aab19bd20f1f73bea83b7fd6e24dc0bca1486b7dbaa4af8661bb02eaf0847e29e0de5fc46c603deca2d0984343991850353e0e319dfc7d466dd1f8f6cd4116a4a1b384654b085459a45dcdf09cdf4a6579521c52cebf4dbb1eefe5b6570c94ca9763daff8080b7bdd3f73be59d7bb161167f479998b707224cd97d3443443ec2e30e70fb931f2ce5050aa90e3f36501f4e405594abcf46d225c4d8fb36e6312747cd96c50c9e39d2a68c302d611334faa9951adc4319ac9e39904deaf297173040e55746ab7bcb06c05e974b7382da46d54a5659c539faa121325f64f0e8bff1997bc5bac0ef49726f37190fbd5d1a7616fea3de80325b286e50940041e7191168392962f8f89702a226cdfeb9db3a11b6da6679bb721bee20ffcc6d06ccaedab73d0a97c27374ad1a9f1d671331145fc740634677ca8a049042a5762d5159191fe4defe4da45cd5383eac4724fe9d284346ea499eecef384f20f6fcf9cf029bc079c0f43c3d5b2a9280d5d9363205e85f72ff98544ca4c8deaa00566cf9c6172771c46195c8f06158482a3f25b596c19782073888fb13fa0b7de1af16032f2692142f0656a21cf8ff5609d2c4354f99ca4948486e6065bda0f20ae433250135ea4485d5be0a327d4da118b3c780f6f88a3e8c87489ee762204ccdcfae4681f0d5f673227e264f1f711618edb7a5cf850b9c1ffd767e182c380cedc4c60c6a08b2991172ddc4fc40ab156307c0d7f8e5169ee9aee5c2a859cc03d8a1efb1ae02718889941e5f6982860badb88e5f7ea0cde36c2f3851c320798dec99f1f1c33108310d40e6fdf5ccdd6762c9ac2a9819be16ad0e36ca2d5c71a8535a344f12e957fc3cfe83606315b59552e29ca9b945da51761520ebb5e9078588cc8eb35f81152dc9c0599f887852ab73939912ed83758a8fadcddafdf9a50cd4bd9741fe55ff8bf2f5237a00198255726989823439e846c6497ae1d65366b6c6a80563b35823b9f126d554b33daf2f67fd3a11159e649897187e4e677a0dd87cf2ebe1b6172fd9b364f5c9a3c22b815c01e14052e0366bc90d16a6a5362f8658a98740e71555b753924049b14cdcfb6d6d62158aa6e6f312d26bd5b3d7c21b57440de97143cbc9c38a28a634a264649e6fefe169bec729caf4e08a34ead4e4527054752b4b0538915091a71b154d8ff318ede84c6bf8e46d643f1dc7d103a6c8d8f9d286bb014d8ea0f2678ca9756bda46bc50282f5260b1df1e31bd7e32a11b58b6f180dfd39dd4525a8587b65fb29f2828bab700b30d087c4f89b86741034f363544c48b991c8c2d0aa7272b370bdc067750d5f56d441e5b947d280e4fd5749d8843937b6429949c950337ccbb05bc60af223174dbc270c62d53bd0c4b96af030024a3573fce630561a88c3396eb0c021511a946e76e2dc9bcc574c36717c786ee8ee5918e400f1cafef102c9d9138b9edbe9762dc92eb987fe11e2f7157bba26b3983f8d2b95f0a32a0c7c74fb9552eee30f6eb9143189b9037f6cfde3edf632d5f970c754d7ede846ce642b9c523f855f85124115edd3a5436f37ac345dc99501a4639ab235771412b31df7028bc4bf62c0912361a33000f3c405fb600c387b66ac9115b069e6b7ae2b1bc213546692ba98301cc124877f7f873d2a9eb6fac9d2a406bebe79e88cf8daa30ecfd570c385ada7797d23b18e7d6d48ba676b3607bfcb62d991148c817c77a5c93130d8ca0e6189690f0ef2c22deafb0006e16778ece6d2f31da8ff3d6d594b63c68ad1aa373323b107106b44f065cb945c8084663018eeddd55de8a2f50e59ef6a69922576f73e97ef73f5be8229d761fb243008b1fdc17251f13e7a35b6e76788f68b9b68d09f5d361bcf093d5fcc143b42b224145f2894a226c1b112a693af243f1a28bb9a9ceffb386e18e3446592089d6cfcfd5fb3374d920c8f089d52648a3a68ac94bfb69684f327cfe4c3150284d535f49c2f25ce8f99989d4944e71021d735f90ce76bf623de15d57ce8bf24a494f4d865ca8e55e4ba27f8538cbaa9151594c1b168b6efa5c289d83197f818275d5386cea840946a12ad90c124641a0294e3df50bc2bd4cf9b0c15f8c31b42630cc9c2c90c83c890692404a882a6b078c46e551ac4520ea6c19605c44bfd8f85648c203ecb3f09a00a06f41cfb6b5ee57b54ffdadd190c25e7f0c605f6da191a70cd128893faaaff9e67e6d033624582ab89ad17f62c2afc8af0d8b89a3da6fbadac0cdcc2659126c6ac7390c0a4e55d6b67a37d74453e0b3dc18ce44fd62295d6f9104902587e264539adc93a99fbe5d9825390b92caa1ea95fcc6038f9f3594ce287a0b4052557146da390454bdda845e426fcef97c7b2fb986a1fce0bf78953fd Hey, password is required here.]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>用例管理平台</tag>
        <tag>bug管理平台</tag>
        <tag>持续集成管理平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试技术介绍]]></title>
    <url>%2Fposts%2Ftest-theory-for-testing-technology%2F</url>
    <content type="text"><![CDATA[b63abfd0cc043585c7f59d942442ea6d6cca77e36707d958fedfe9c0c12830280866ddb907da46f5753fb06637c3698804e1f1fdf146fde3e515dfbca9e46eda5e5b99326fcec6b87c8542a24d4de9546ee89898b5a345c1b8d0174112b7fff98814f59f87910ee1aa9c1fd28a3a27bd2527eabb5c966c3cfcccc1a156a08acab774b0b4fbe2fa6c94c304f7a1a546a8c7fc71a0f4aacd72594b886b287784483727b010a62553240f23cfc8ac2e8a9f03abbf50ebfae57e9996341a55e9a191b09188f940ba3c74f57216cd942d48aad00cf1b6e9b3cc7eb0993090573dba05b17307446c54be5b5f55795c2cfe8d0caa31ef05acaf1ed2c298fd10a6687d8976fed18d46372eab6544928159f8c7a80b1aa9b585d27d82e1b257fa4cf184ea152d5688aaa61c1fba493bae410ed8947782a6a28126c7c64368a309579ca557bdfed270a4c76563637a09095769f67c5a4309f96cf4dd4c1cb133a142f51affcbfbcce490e5453fa18d63da1fecccf904101ea10fc8105cae1b434da89f304080e55a6c0460ee72340843b6ddb88ff2490ba29615897b4db71969199915c687c8e47229614bbda6a7327034ff591bc45006645ca269f426ec478458277a1cbf8c50b7ff4c6fd1b74b6ea08bd775855523efac29418d05b23a2f58830c310af90ecc8d2563f924eb674690a38ec5e6848200ae172da29960220fe0c38ece2f4302c709a08c4e449deead350776687b131f103656a19fc3b72ff97e5cc6a3a8a46d7daab7eebcf99809f0043d8867fb118f557c8a14e0abf33f6c07e739675ecfa6c4e5008f2997ef63652d55e732b4425c8e88553e219888f2df596573b3d4905f608c3c5261a63e7e5241984af7d45f924f6a411ea55528aa2e908eeffad39c4318270a93a1d023918458cc16cd72edb78840d927d6c12664319aa903de2bab29e1cf4a5c3b5acbdb5b959d59ac1dcafe2a6803c798aca2aee0ea98471f44b0c1c3c3be6b24cecfb86ff859db3684f7fafd0ec0f6f5dacb2618b830f121b0104883ac36ad37043b99928fe11755aba35478deac49591b5ef1cbc744560227eb15317fc66f7636d4a6b15498f0aee7a4e39ae33e76b05eaa174c5701ecab2a788eb329634771450e39d110ac8d75378f80ef5a8b376a818c15c1cb5eb790c9d96774462fbe3edefab63e6abbaf8168037e232090ba40d0c0af4acd39568f8ee9a9c9fe7a2bb53720075bb631516f793c927dab153e643568de19886f69723e5029d295bd86406e84a27b68bd23f08b46ef24ca4ca717eeb6c26dadad5ee579f6ebf121e22fc2a8e9fbe851c715b9a0f3b463213c22e81bac7c678c0e1bb866f5ff66a3825711e8bc4927fdb1e25747ef2a834b76cb0fd2ebcbc084ebb4588e08a3f430a66e281d2525835e5c3044fd2389a0c5164fc88315fad84fcd477374ba73ee00c9ec2ea303c89a0eaf1ce50b8f2d0dceb8c56c93f2578d3f5d83ea6cde012a998cc4cca562069a20f79be57eb7befe0a9fd8d512dccb6a11b2388347a12318d980e18f72eddf932b2dc863b2f46d7750d16de3afd58a9397cf9d95ccffe3739020a9efaff07fa31db91f60ff125319dc1602a538d55bee1d42c2001c15a8b6466dad645d0d3e3229527edaccff755237a090e31b347b8f04e9f971f8db54f6eb546e61909cce0a7d8d1e4fa7a8dbb76c4f390068466651d9f2459f1d259366d09285967c93761999451ece0b57a02bfb4d7579cca03d6a0e489072fde5e0d9fc5b6e54fe3a0451ec246d78a06a8ff020ef9992ba148d8b5ad0f132cf18aa3ebd7c3ae93e00fb9abfbab5aaaecedc7817d504c227f2634d1db1422eae64eef6ae267535f814613555bc65e82ef381f0e560fb44ccb1d0852361d85b034520850e8b80a60fddc44c13063e1a4d5a151af30cffda4f970056567d75c54dbbd36d9a1a6b96320662959c2191e83b989e8148f94e2fcd11ae3fd6d17967713c926a4835f43d934fe53021989a25c0242ec6e466154fd7b6a0bd37f8fdccdfc2aa77b792679261bf68f28828761c4da0b3be33a19e1579ff0ebbcf7350042546e0088c1ed679d2bbee3341641036cfc78e2cb524f484677fb214203d5ef7f13e895172988fde58018f76ebeee7f96befcd2bd08c26349087c2f3ab84d056ebfa6dafeb7e85050e59fbbc6fea7ce886a61e555e15b14e0ab948e8070094ce72cd74f91bc45dee64e55a61360faf188bdeff3e04a13ced2aa397ee543c48954cdf129886ce702909282798876f93833147c139e0e1d045019ab6a419dd1929e97a63fd0f721ca37b82deea087ef9d92534bb86109be8be24d939b427ed9197578109e541c67112d2d235939ee04828d8a61e55e1f985c07e8b9f6c11fdefcc5a11305c52f148b3c4f83a8aae8268db0e0a8b2f24612b349f68b9f1379e2c855a94f8fde3cf6ddffc2053c82244647666085c847c3645def68dea62c38514d1bdc3d78f69b13f555c6c4bca098ec314a8cfe83e01b4ee43d171c93de2398ef7cc2cae2cb97519afbbc518bb0ef80fe9783037c7a06f1bf3fb9b5b45a1d3639673a2b384c0ebb6c3187a85a280cb493a52b2365ee40dc1cf9286feb653c8c486d751902d534ab3e2f29838cffd7e70efef14e1616c4102b8133bdc0cd5d2d581d77b9ee64d6479da3ccb2082c51fde7b79fe5fc51bc4266ac16e65f4c2dffe357d7fbbbfd46e76ef077e791c1d0a7b54094ae7b97a33ce2201044d2e3e52843674149a07fde146aa5916a56a2ea8fb7bb2d96aabbd5a3d71848765956a4936468c725bd0eecde5781a07e5f6f2303dd7e2c0ba2971845771f9355c9e83a8ae5b01243ab02e1c8908f4c9cd1e37a827abc3f2cab43b13f60cab00763e9a2e8fee1da80c7a4b089e6b60659bdda17288da360aa8a9341a00b4ac4faa0cb00e3ca0dd7b8b08442bfe037fd8db689af4f85497ec1a86574c757d406e08a431cb700203b1b48715dd38ee9039bc2f4112788cb4bcaa41bdd88da8fce84725f5d422e69ee50cc3c06ede5ce6e9654d0be3aad59e6a2705b330a0fb881ebece97f811ac9744d184c5e02eeb75469a9e085ae3faff5768f81e4b546a7de9b3c7a237e8ba4cfd988b750cbb5ea479960183a4aa36a8eedac67efbcb2553bed45048e45375b6597f3e060b628ab95e36838d188276fb1539de879fbda47e71eba189122de1a077ce29d28b4c3238875d4b8bf72253f7960b99c3138acffdb2703000b42498df5257b7082b955aed6609f9eb2b1b23e730874036be5fa23722504fbfe312fcc1e60b9385d9eea95e673411e233014beb6ec8debb4706dd30c1ecd21db96b5e5a464a723f2b17eb0650b7e53ff0c61b57e887d8a3687543525cfb4381d975254a82649c958052c08a1c67ab8d021bce405238d9870182b2329b1b1e495766aaff33cd56eb727724afaf1a1251ee6e4891fa88852f41859a2903276641925ccf381face0b33e42ad21e3b5563d57122a3ff59d1d0c596c0745c2894abeb75a1225d4f31d2db8c1e72c5752f1d981e63d2469a9313cf339ac49a0dbb89e67b999f1a99522cce4329b1fba6c07668a53dcf53aad396c66488fc75b198a4d40719ba3ea6dd277bef993256a2ffea0bd8f916cd749c05636caa915fea9d096dfdeb83eadf40cb247bb6c2962acacd6b517ef81240d1cf548b9e16bcb435e4469d8a6a7e19c77e1947e92d121cebe89e00eaa2cebdc1caa9966e9a15f7a846852a531bf38772df929734322aadc71e376d33524658e7d11de92c1a07843166924d66de12d6a93b13e4c1389809c1cca68f2143437c62ae1061c757eb7618aecd543da34c1fee737886ee473ff41d65912fb01ad7a890107d1e8aa105ac9631f95029f3949cdbe0b1102d9d0c048f2a64e09800fb0a3ece43f1f3a8d0501393b925168ad5096cf5e2127a6d97ecd68137666dba1d5c33fbbbe360ba2e6b8257c0c03b319cfee0c2e7fb60927ffbd72982d3e66b24e3183b3914a95cd1de6d589ee7ff73bbeb6127ef11514d5591990e677de7557ed67a4e3b638451e47796b8e6c506e8b71d4d1fc582fcf94f6df0078e8ad9fd36e1e0e474e2f539c6e22226b2811f3cc548a770eb616eaccdc48208e986b7cbdf3f494c4a0a3138982b4e6709551f54558494432abf823741c85b4140d29581c1fb7346b568a76ad24d743a817e759e350b901daf1007606d67c0d2f4bde5404529fad240a3ee19a78ecd3542e12e8096a82a5f4f4639f1863d46c86f03be06a81abe5f271b40cb836c68b5ddde765d698743c8499c87fcd1893f47956887993c80139193f6b7962c3208224114ef58afffe0f2541df24309970c12c87f6c36fa33fbf64d2f078bb747388216d6f7d8f421b2038e529f5617c2ae4833832f68ca40647acb439593b6461d99d3726fc93416054c916b05504b6efab41e63d8dd36ad88be573ac60d2665a473ea083393e6123a64ca9470a43df0d96b2860af0de690fe64f67eeab28d5a030decdaec4a535d29d94a9234c85ff2be812d6ce9713fde95c0bf6d990a4488bc12ca45c163e56715492f3e248cbecc303a054de1ca147703df195e3523ea807606660b879a36b5ede8506ee01d3592445f2f80e7cf433197058ec6d10667ee6fd81d473c30c966e9eeec5770a3c178cd1b9f77ffe289983074f2bcb8f380278f9d07962668a0cf815bb4fd624b51cedc35e9bcd13715cc4786df0074a92b702711389bf5f64af29b471e703bd1d6871443ead08d234f70f295a87ee746450fb43b63f72b5b1549fff6dc5e7ada148d26a275a65c20d181f10e82803bfa3657a93c2c59f45b7f861e0319b16804ca61294be069a192b68cab6c7793051b68fa744384339edfb808eeba41f4cc21efa772802709abb2a8fb7a8b6c66648f498b2ee0320215d7c49541359b7704a82bd228a1bf00e387d76b755f7d3f4b70e9a0ae3d4d17266903d75aa8e2dc52de793092e8b312669729a15fe6b03e4023a8968b430a0970a42195b86d8dbb416561ba2b5d1b6abc6e40ca89375298b7ea45003937b77f618886e27309b374101664511d3fb7871b3328f29c1f512b12e73cb3c3d95f0715778b4fca1dcbcf958aadbeeb97daf849ae3ebfe5c598590af0489331a04c405c93bf4d8a3ed73013173cac5e75e70169a5141a779616938c2fdc911083683f4f8af26243663fcdd0f5b46236514cbf41ae92a4496299481b02ab0f23ce4080161cd2e4d046ab93a4bbfdaf795d399fb00109b1ee079e92f92f2633364f71246290dd3c24408653f7ebe9ea1a53d6fdd4e436328af7e3bc3f0bfa3450db6c0622b435b00bb3f765f3881cabd186089814b736f37e2929b98a253e5863b589734ef1e1f83df5d723903b8a16cd6e4eea12d26f83e011cc912e2447affc57079fbcdbf86a4d0bdc8b9938f0c6ec5b836dd515392bb3f2a294708153dbf9dd91b7c1111d68fa7a2c8612eb9c1b7e000e459c6e8e3ca06ca97aff42f5463d3a73f8163bd91c8c70e4bbe2109e41f952ff70bf2a7753c77f627b4b14f8ad0840b24c6960c4ca6ed1dffa63962e795f4f5cfb0288d67545327d3d9b9baac0f79f8ae170e048c2d318496c4ff6a8c1a86fe39ff1553baf33a9f277fb2ed613ecd3dd6ff7337a91dfcd50be3048dd781112c391f9f81d896ac0013c6902eae2b1439c03475b54a287aacc5bb47445c81feb011f3b11136ba77502f570a5d4a99b3b002f6996bf524970256f40b370351197b234fbb59172ddeff558f1dfc208ebe1c2cae618107923ab3f54de7b6c20260b187442ef190229a504377de5ad98ad0823dfbe89bbb7bed161ccd4aecd2319e7b1f95a02e11032c1e5e21fdf2bf14a7cd41f6831bd6229a6e2fd93ed2ea534152dfd6b0daa43faa2ee2536215147875a011dc2af02104b2eb15584bdcc02623eee6735bc5717debda29e49a453a24786a6aa6431e484578d5b4f6bbb05769aa8824f35c764dbd223c664d42610885925622587db00a79d3219e5db9d6114565e962f007691c94888ce5590e491c158073c898dbd03fb0b973b9d45e3ec1b99933a7522395e1a080d1b0f5b1e676f472afa82db97a127443fec04b08afbc1b4055b6c1f113b39b888757863bb822651a97f00259d2f2ce136a1fa9b68c2ec7c68c08646dffbe9557b5c69b3ec7009ce7f4331477111f4c33a1bd5e8cd9c93bff8552af3f685816b112ba2a29f3ed731d18d6be64130579ff2298f890015963c34a767636d9b4ba8f6794af966054a189374b6b4dade257b2f1c2d7e21fcab51a3fc2dd6143aa20182fdc994686f5e55f24724b194f5002f18c3eaf9643b91ad8e29278806f689f10b9a1b5e136ec8397d6848739b384abee00362c18f29ee3cac1f175b1dc6821a1e7506dfa1189dcc0397b02ad94c6f129d6e5a0dc72b3d010099f4e13bc8d97d74f9e680051011d17158ea9f72901979004a991e5da9d8f5e39b13f181ab781f2b2b63a644d3324926650a19cdf0c9ce9dd734f2c5d63c2b7f249081c4bba208e88600c3e17dc537d91a6c8b2c3034ee7379ea57f38f1c935674e7b885a48b2e7f7bdcf9544dcdd0cd554ac5c0c6fa41f8d678e15e5a13f0eab9cf7a7141521a4ffd06b1ecf5d29f94469aa7a4e9b0a73477efc8aa992f04d1f2899e3374abed8002272f17d6ae7ec06b12418efa6aa0f39db8c82b56a9632c2df6f643836ee3e06c027103e2dcb2d41369635b84cf234aadffa74e3dc9c67514599188b4a7e4ef14699412931362605eccf3d27b8dc4f2f7cd5c9511e93f87cb26f4d0068ffc50666b47ad8ede156f8c02d05a384aeaf2479b6e70ee0337b0ee824fc7565e085edb167535b91278b12327e6015f0ba7aea8e83395528ccf076aff0458f0f8e740065c235bc8160bf8ac98c2fe7f5b9da05bf1496a34e452e877cd8269d345827925e6c154c9b71e3e7e8419939fdab290b143e7b71afd090829b864ab329b82c205721e364ce0d4d79703cd64b239191780ad28b5072eec508ea315ac7fc66c1fd3a0d979e2e2cbebeb4c6241c1f0c6bee778ee43cb4166d9ae297dd7baf21c637fad9e394ed4dd836e4b031ffe18158fe84a069028779d3049d050e335402aed6c52e73d0518d71bc8294d1f92d6f07b2b10212d99cc29e0c654a7880abff2b32150a17a65fc9a84eb474c25feb6e8ca9fbaf4ce490be719d2926ba03e9cdc6ee094f065ec63346833f0b027cc6499f37382c55c9f6458d5df6a2adb26715cbef91c83b47d5306f535dc2fbc4951a9327ab003469f64d473ed232fd11907189e5d0dcf06b16716f17e1ef05569536f8f0531791268411803c619382bcc32166648972cd215004c35dfd9ff3c9234b6695e2cdc0abcc4027983654bfbc151bf767a02018089e6653c727892dcbf6d38d42c92c80c38e1f2db2fdea1ba94b571c194aab215d959d384558c78d54e97b2f17ad46f761dcd22f386ad17cafc09516b2a6b4bbd8832bb7b2986d192b98d4574992da05eb74e33b838c6bad27985f6d6cc965a7339b6b095dc89acb6c1cd282008be0a9890680d34bbb4406350c0e037e45dc54b05200342e9faeea49863b47173221c9c2100850284b6781f028da4f4cf45fa7b3697596b88a89ee238bd5f73ac2f3e3a1125f522d2c35a94402f19658b0850d96d5041520c9a5954a15140c8e4407201dc8a3633868b8c0342a1ba0fc94b5c61cb9d2576737cde1458dc7193d307a1739ed59aa0c0760991e01d12e902f28ef3876518a60c34983e4ec27a387c6541fa00477e7898d9806d35198821dd40569de4be782e8cb61cc399d34458d782be4045f967a28f74e75c19c304c800e0aaec501bdae422dc970f4f1c34859433b8d2d3869f22f0d84cfb7d299b1d34a87cf7ec78d95b66e4cc40d02fbde9425b67dcc8c92cae7c7433040e59eb25d6b4d099fc0a9ad6ed61230f134acc33a14c97edc56d02a7f6a32e18d925d39a5453ac030b5fa45a9901572afb394d43dd02bd49f73c6451d4da915077d96f80e98ba545440baf852899142a019f7af0f698074a06abd1ad10cf09b3e048e821fa9f5d1603915d0ca922d1311166087ba003332ca19bd00ea03c6e00bba68ed33ccd77a44abbb1dd739bdf553ea9ba17001c2f5b948767e9a92d308f6bbd172574b6b19524eb28275b9b4751c0f193d1469544b27b9e8ac9b8202fb37713dda541e0631abaee80e925b952c8b7dc75b6f958bce0bb98be1d03c02bb4218780a4f6c0df066156c0c2296b862050db3fec68acee210b4ae2b04e04e158df01dc673a76fb4824306a584edd10c132dc8bd338b1565895e3cd4641dcd47e80ac7f51f52d41b9835d4eb375efbb3f48e42f297677806e1b36fb2b01955bc7d42565f690ad1ebdf36a0b82a849156226598cd1a1e5ae8e9bc43835c83895c95354f5b630413648a44bad5a3acc5808abc8931afab2f310c2351d8e721deab252c7ce419d13b58aa04d14d8aab66ce4059795aa37b8bb477440049993df3a539f4b156beee9960ad947bcc82e88e3d716967906e3ff3d064c6e804b87c0bf9651ae4c9b958c6122ef0e56dcd176b457f07c11e9780ba03925683313a10611d5061469d0c12586b022fadaa56cdb561487d5ef0b0d38df0eba960d4a999108cd90430ed15a2358bf48420949768ec5313368582f296e082a99a85dc1912a409fa84f3a4e2e477e4cd8e28b924c5db3985491b56cc6c8aa24e079088145b42c0ce181733f2116bec57dc4009feb4b691c14e68c60950eb01e1dd6e7e5678050835cf103c6a0d214929e5dd21f8cad51ed2bcd5f718c607b118a24a6248dbebbb60b63252f9795f7c6c30c1e36e236719d70de683cd5c632f99c4ef6600b004486388229414954443f211e666389d18fe896ba9c60dd745aab33701df33c2e41800d94702a613585a6f5bc78d3f757c3c35bbf7a2dfbf0c654a60b93e3f396e67b7dd9b4bd04e05cb0ef409d3142b257400219991e75c0ed554ad49f9757748ec94c831a7529e3e8ae0520dc6463a7cf3115436cbe69327e5a9a650d20baa49ef380d51c1834fb747996ccfddeefe587fb061cfec02033d293326e165f661b748969e94a43462e480fe6c2bb3b2a7dc1ac4fc2c08be45e0cd22e1799a98dc936672ecf86ddce014dcf344b7b967b5883e7162cef80b9c2e3c5f7db78a8fbf014b5eb027bde11ec67ad956cef1c3a5147901528b8a234a77dfc82c8eac0aa7eb92b9ea385ca18f25332a4c724a82990595f4653827b57f0545e40eb64c4aa06414017135246094dd1153aac56e0fed2b36aafa36c68160835c867130df4ee4cf4d3ea85eb5e0bc565d6695f0ea14bd11e8fe56b06aa5f1dbf5a88c0da8d117eccbfb69a6a6a334f4518e1418dae548763ab20fab4793590e1e795dd2de1edcd98d9d969ed9d71e21fb4826bfab79e9535566c3a3ea30e2d493583d6e3147fd3561031137a25fbb6e2438a91c71228a70caa012ae6c9aeef79af49816250f441cadef725d50ffc9aee99e42e6220a5fad1bae48520e3c249080d67e1fe021a0d3d45ce261944b586dadb64e4554a0b176d461f3f96eb255da9b8619826dbf63ab1d4b12dd5c002375b49f4b3e01f4d4fe5a324bb9c7717bf97d739e652cdb4de036ab2f5d95cab3a236bcda729e6b51abea9ed2b2001e2b83dfda8fd6682288b824f285bba2d6ed39cbc3b36f7cb122412383a94f3c74f824c104905cfae5ddb46328a95578f3d573869c325b86c32010101dfb5b3a8ca667855daa378db8973d729a493dea386c4d24a6b52f151256f269b20a0e372f276859306b21837348f37f791afe796d07ccdf611c86e871be22e93b8e6673f17ca996370962abbb90d8ea046732dd13fd619880b9129a008a67980bf177d7c40ceb4d104e282fe009c1c4678806a55ba5616f76f0538fb8598f9ffd15198759ec04d1178f6dca27a26785110c3c093c63ce51911a518903fa303cb7d834c6e50095d9cc488dc6696f66fec4bcc9fb1ff030eb7270f20b7e048d4f44897900063ae4aaade981594649b4f6ace1bc841fa6c86b01d9851825bb65877f0d0391d21a1c3f186026f86c1e9d81b3fe66898057405b2dbabc8bb75e7bf4a92000861c227f9dd9d642fc743d938d3fbc3d24b59c0a0d36365e6efd11bc5c6ed1943b1487c1a3640913ece3920504b89c2e7dd066547cb1d6445c8b7e4141b824df4f9c3be8a44fbcf057a219ebbd1e0f7208ad1d6652ca0534b39a9ab2b85a041770573a61063c709aebc927b2118478aa1ec6daf5f92505e6339542e20c16ef6190b1e50a3d4dc1771bf55223d5c23225641c89d24c2d09271c4870d6ab644168032e343266dc1373f534cfa7d3c5feed24a0167ae63d843364534e6f96ad68ec3d85db2af084acc0741bf554b74aed70612336dd7e0517f17b6faa49fe92604216b039e3faa5ec174c6839e59d0689bd5c5f557f620ccf626c8dbd58953e49299bc2597da72688294e75ae0422dd8961ab4162d0644e9c1092deedab01975b23b176bf5ffb0454d3205b743760626346f5e8f6912995a43f59928062ae52a1bc798c8d434d19a395b43967105d596f669a60b09ae028cf42701ee11a2b3f45dc2b82e7028e5c43efe6236a446f26ccac33730898255ecf93ba40c6a6a1beb3de0566c341452c3cabcaeda556cfd640b811f19a5faf64b6c0e7c58ef165a4a0b4fae2e58eb1859a47dfc01f686fd626771291be5aa9efcafbd8e4e4f0ee52f030e006134b1cd002c6d1ebab734231dba04eb30498542de21c62e1b818eebad0ada0f6aa78c4e6f5ddb7321f567b366d38f08afb7261cf1517974d8ad3b7453e3cab49e2ac3bc65b67e4387ba058055d1c53fc3470d0380b8b40863c817b73196b1a87bf7f97ed17c8dac8fe964edebc38da999d43093da8b75a6a80540e85a823b2d488b19e5ffab25e4e1808d1230a47ebfd3897fb6747d4c37ae43df994b992a91f7345662b8cbb347b3e0b48f1fa116546177c5bf60c6304cb34f89bb6670eecb08daa540b1e285b72ec7b94472f9a10b494bf9abdd64443228ab89393f324786d14443e547a2d37cfbe9005913a2c7c13653a068b8b70b1e0d7149e75a5fb53d2e911cc9548d7b694ea06137bbe4c567d9346bf1abbdfad897a0e1a456a2fa680497b8366398916a47cdaea739f5f36c88a2029604ae1f9ccd51382e91ba8ff9ba2ba8f5347e792fc9784e0fd9a5dab9fe3b7108150c14cbe3c8d482951d0009464866762e1837e3d2f466e5a03d2fb92500ef0e213818c04634b3351d3476759dacb89338a034ff0774ce36f5936012fa02f5cc8f8a283eaff0b37b8b75a2b115b50d6bcc6306e1a69d73c5b4c11ebab96166d1bc4e501f78b92d2ffdb5fa6b06264e55a80f67f3bceb74ae0328e3a978dd679f63891d6e15de2e263bb35effeb5c5c030e986489a7d241b55da743ba78ea0221b2f18aa67453acaafec4b1082ffbd72b07c1f6b045792c44a3bbc98c521484c2d06438bbc7aad297e9a57a27be31a950947628f42bb176522fc255c94f3248e9627751a680b7e5061f641a6a60eaa54fb6e189ff3f5bfc2c63ca1f7b3b0620370245bf30c428f2f936c91f21a2683d58a9e30869d4cb3b1d278a21edbf6c5ac9d60f56066572444aefecdd4269e63e36db9ae3e06cb4588a9c916db02222b7e1a69cdb0156dc723f51215390017ce6ff5962b4a1a069916347440c6bfd3836d22cd5f1e000d1250da92c660ee6d9d172dbe6c2be2112c3f5ccc25b0b2d066d9f115742d50bbb2f19e94a7640fc618084cb0329630954ad06bd8f3623d21fdb0148024cb85eab7ef33b3675c57d0d54652d93002e039619403e932ccdccb7b3068da427977644c6cd84223bcb2b9e059cfc6397b6222ead83888c4bb5761e0daf1d37850d3d39616c9b46419ecaadb5f84189826daa6212bc34da146ab28fb168f60238b9ae4dd11ecdac559484ae404e2878e1d530385351a494018c53dae515e69e8da11d6ce82a09d089d4e48e721aa2d4bb1bde5bc3d1b59475bf05bbb49e7ff03887c4d6c3d96e655985c414c63209aa8b3bd754d7cdc8cced1f68a9562ea60f3723043b1f5ff4f2ecc249ef5fdb990c50167d27e3769912b5624a9c3d33acdc85a3438e6dced976dc4bb9b08186cc757be4acf9beaaa548f095f9c1590a823eb309d81a002e4a79db0e733758a0add9f3c72751e79b6f66ebfe8905ba9bb172001eea850c6f1635a9a35b85fde30ed878601892a42168d34f8a81bea328867e5ba751d5d01a259018cdbb2d6c97707d9c2086ea9753a4d66c3bc76a612549b0c312b630c49a84c3dcbcb7aca69ffe0bd67df50236b0adcf607519ee8077bc1afe88b9dbe359aada9a863a8fa14ecae2b52de207c56db1d8989998fc7a4f8675e9283e6be38a2b6e556944bc420d90f22d8c33f9e3eb84cc31992832c62683bf1e34cd886af8575270db9b07b3dbdbd5089761fc075c2bf144a3500df01f9e1c5fd5bae90f0bb4a5c1e0c02c379812be0b51f2d7f63bb4b7af21b937b0681eaa52303e225e34bb942875989791103124dc594367d842db35c6647cd61232be43e27faa9645b5d613bb40e05a51d286e0f0420bfc1d1bf17f11985173784daaaa47012e3b9903cb58b3304e1e7c38ec5bf2bfc43910a4d78254c3de1aa96bc5575f56ae644936b5b5a9e980c515b629b12d774daf4f165b1ac500d63531650f7972fe5aab8fbc509fa48fe037beb5452ef0b4eadbd4a102665c1282136cf36b4a9f6412cb5cc684009ef2916787dbe1871d5933eba3e36d532715a17c0cca3195350eb864b925463302167d72227ec1f90d67b3db73aa4f828261405c2e5807651f4f5a7d35b75cb3aef8a1faa27e59c049b4661f205533a69c293b881a064c5d4231c262a45b348026cc6393d4b058ea3ed3af433bb5743a62020d18efff673042c6b6e0e3b333dcfac47ac5753b8ca6e866cb3a7b4cc217dd43ae495f33041e41167e3c69a4263d553170afd728f73137916b9ae03365160be41a0a68a675b7c21125e753224587e259339963c384900d2170ed95353d2101b2c36fa29b65ebc62b02b49c8655a6a63dae8a0034863364ef7a8726bdacbfc28b748f749db3410309c46fc048dc532fb04d4fd9e71d6340bc78664ac3356b6e56f0106b93abdcfab541d3c1cec03d7ccff69e116de234742eb6b0f00e90dd26ccd244325da41fdcbc0405ee493f82c2dbf4e134eb4bb81289cdb3046f320d0ced99139d968cc7d0659b2f472400ad816cd595bcf6207316f4d5588bcb359c7e7efd43ae1d29e224a5bbf0ea5b504a18f25e6a190086b8c19912ee0fcbd8c4591fbc1b31ed6844c2428ca36e6d5ce37167e8833d860d4fbfa3fde3ae63fefd1052712ca490a8ad3571d52c1c941e9a45797bacc04f4452762645164d8c7977d4694849303b1faedccba493d708493fe79c8d8f8dcdd79eeece59b45cf1ddd6511d6892ed30527ed488855b5461a29f2b025b364c78c75a7ea05d1974f82d6d36ac8672f828bdfbb83da3666903371c40488c7c3482315d2190e0b3bdcd51d6a4153a44d64727810c2a4cb9725a76d2033535f6f7a4f3c02d2a2ec0a52b69e381b9c86c6b644924813fc158407aea1262d4b512d2a9f73208ac3ed01566129e9e698793310013c90ec9dc3b908aa9b883a13ad6727d26a9be8cda164357e428a4deca5ee191973a92cceac14878e4f0a8a0e553145418593a3db150c9916a5957b033f5a4a002cc07aa7b2bd510bf3a797f5640986660949860ec0469f94960093956346f9d258500335d7c9f7cde8212c1444f2ac09086e3d4d2ad8b8f8d9108b11da7b40b5b79a9a8d42760056b1e2b44941666d3ec5ee84379a7396a7b42bb9beccd5c62f7142d0e6e38ae23cb076e4f55656ad8d58aa41e59d2692d2ed76792efda316d3f7a7df04dd11efa9e0679b51cca99a7db44eb48ad906554e8f8dd221fd87124bf63ccd991eee9b23bf3a2ecbd73f96e0e46d6591186951c792863753d990e83f980ee7dff82f8642c90aa7392330727b56c8953d11e965021975d3aadf84920486dfd985195727dc80ee661485916575fbe4616f0bf802ddadea36a0b5dde9a36e33a6fdf651c5b41e4e5ca049fc4e98e1bf7ee2a587c8bac69652a9b722ea3ebe23c72c14253d94aa36fd38b28ea96077aae43241a97e139d950abef276719a509492faf05912af828a2d3ea5a1c326a2f3ebf13760326baeb6d63d46466503fdd317c2449300227de5cc206fe648cb362afeceba0ca32c339680c1fb307738d4c6915e36ba74cb14424c8b7d19515bbc87593db0b6065975ef8a1b7561adfe2eb655dbf13e7c26857006f9c3e15e80d2bd9e261c4f98fbf6067b5085510b9245f93fd9027f325ee1ed3ec7f2c479cbbe6c7bdcde275809b95358362e826c0d8d82c035c7ec359b98c312f553a964bd5b52483b00b2d1206906a7246560257f8f1d61972e519d2fac050b49dace21063f6e75d2cb031102cfae97e0bfb6250ce3fd5d1b470196c80e65484010e9feda6478e7eaf3f23ff44c623ce0c54c4d02634bf956c1c6bf930a53ea8eedf77cbc8629e2c0cf3d7a2b6df1f6f3db2efa482a15598d88c59b37da9ae9d63a4f94eb702df0fd698697de5d85994b732b1e3369c93f313be4475cde02c2ac70ab455e2ac6592c86312205b53658a6f36384bc2b459c3badbb5c444291bf4650e523e2eef47467cbb972a6c67fd7fcb82952ae1f6371f000e7bf55dfb93fe3eb8183b94de38465e895a07abce2f9baad25f863656a257c27e66f08739b4c2fcb5c29bb803fdc69bd98bf848e8cb718f8a3f764093a7ad7966c595d43b6036d92eb3846bb516acdb93ad88b4ff749f0e1155ab728240db81fc5a6327b167bf7432341a361971e8a3fd423be1f7fdfdddcbaa14d298b81e08714ae84207e57b38c7412796e1741d006def776314b63860b4b7fd3e467d54eaed97ef0ca3b1c6a2cb63712133e4c783c3905db55198f44e8f8655f481ca0795670418ff7a1037bec636a115f2f4064ed6ef35e6f607ceaff770605696d4887eb8d2a030728745f8ca716a17b88e349f8e0cd7533a86143f7b4e399a4c0164749aaa9c438252428549453bedd2d0b62015e35043ad802b242dd3e886dd37f87a0d25a49bd835b17f49d4a9d94fd35450e9dce14c567de50e03634a4de36bfa9b6f4d1405bd7b62f9455a79ac963aa892f1ade6e63843d396041199b5b67ff26249733985cd6f299ec1c5c1aa0ea90f54fc51e7b3a804687d798a0d615fee58cb2952c3e467a6bd80592bde4905147d3da0d95e9bfef71275272f6732e773b46b2a42653de8e46be92ae9ed9c939b067e567dd35c9c9825f86e83d78dbecf3340a0df00811f2cf70997cbb01469a2ef034da3185d5748bbef5da9d5bdbe559ccebfe3e8fd7f50e523df7b4cef19748c6eba6e9216f7d42d4b016a4ea4e700eb2ae7e9bf06bd5129b98eee6dd7797751df5cf6245f6fdae482eee7d83a9dfc44a2150ea3ecc121b3eabf8184fa61f8aed69119ec8cb7a5cad910b9eeeb185ecb4cafd084b0af2e14ac5230afb5a1bf2c5995fc540fbbbb89927c6207021ddabcb83ec873f6fda5678b8af2ed27ffcf60d1d8e48aac777450e68f2a9061a26caf996330ecb2fb96418b6da76f74f49f44c53166d023035b18d5d040f876dc60e609ea4a7af74220c129694c641c495a93d0e249b3adf8212ccdc7d3edc7437e95feca4919dc3e140ebb7a687bc5efe9f7ae274700bdc85e87e38f597e47c57eb8e543f1a342f73f3d6d6f24f4f3fead4f73cddbe6f4ce8a76846aa243d340eb094fc2fb625a195705308bc8411e5b68c5032a0ffe42cf538671bacb08ebdcc6c9a69e97b65ac13db9ca717eb22807de76903b7ff8744e9694a9e4e39a1cb6c2d0e76a99b02191e3d00323b234e8c1557922d051ff57154ac6b00f84779345c28a44a0910e6a4bc9de4452d813f805e95446c134d7231823e87d8d85f8c2fde0f994db5ee2a990e247f1a3503a2d09ff5a8ae59767937b6e60f80723efb067465eca26ec3731b49c08fd0f456ec966a83cac39bdc432d626483d7e366ee55db1e2ce2212b47c724b8044cf9a2a84011ddce40a6842adb2b472faeee1fe15961b43a099fe2fd5dd905328e361e5b6e623414fc4431351226ba53b247ad1465cdced09d23294a8c2fe8bd09cd2753349cbaa6c4cad7a2dc49a7d024e639103fa7f5546649bfa6b13d5ab87396e7cdc0504998f7bf5cec973f2b6d6d4fcc9cebe785513e575404e1f86892a19525d3073ec764dbe34e70a5514043fbf5f193b3d830ef5c6985a5a45d30c9859760ad3daf3a992564299aa74bb91ccaafc51cabe69e9ff97866eadc75c729367124bbb722278f89410e15385aaad2a99e333b2d40d1c94bc8fa9cc3d1aad83c63e97e333e3078e4f3ff7a97765de36312cf37fe5d459a3388eba675dc8bd35f8ccb14864f889b7419d93f8f3d880d96bd208bf6be64ce5878f38be0dfb98af98b24778413fb5e8be059fa2579856e6c0708a793ef3f367b5345892e83da7eb3a1c7c1b5f2fc5066c65530744ef747004b1db4ecf80f6259be222309feda70e454e472c65bb2162e36d7ff867fd56abd097005e2110b9545c0488327ab858f5d1a8c595a1be7f24846acda79ce79b02244fc638a03013cab24743bf0cdebc8642379b5d5269f41a818c844643309cd16b7a3b7458b6faf0bdbd15e07059d0c9708665d03355edba37548e97df471c2312e122f03f64124d567f83cc0222c835cc473e4c751ce8ad1f21605152b86e1903f176513eebd0f0fd52e9e372711ba67f3bc9f80bd20771026b65226b83343ecf9343ce02840f4fa12e2920df3615bf5192005e33330e3f0b59324e01554c923a7e0efe8481269a5b0931966fc7ba6be953d916f4e2a4e8cd409adaf43b49f37bc05cd295479ed4af5d7286e71436115216e22d04de597b4bcd3ddb9b2e03d735a0e99b6b92224a85a292bfb20241fa7901adf87ca9ac1fdca24a682e2318bb3d7ae1b0096afc96a99625dc300aecbf0a025f365255695eb8fe57fc05c7418ed79842072588eabff122f52c65603234f5d6c949982c11f91d3db2db9d75a9599b25d91ec5d6d008cc7ad9973b0c14baa4ff66553707571be5697f20874dc667fa4bc825696eee3f8121cf543df6b5de88d904383dbd096f67fb278fc4c9503eee640ca280d904528f549440e7a5a85b263dec5de0f7512df1d1b74d1c6b034609803f8979a1946c95875773d4ceb9cf4d4feddde663b37adff544e5b1311180f0d27c118dc32ef7a876818eb8565d15bced0afc10cb5db5c54883e5260ef4a07b47a281876d91c0ef4079f016aef948a0c1f9841491edf8970edb0ff8e6f4786d2a406d4c3fad578dd0c4bb524896e09bdf90878a30712e187e1406e1f45bf2ec71cf920301f2efa6c5691e7927c1057c306772974d5b68c027923bd0e505eabf9e1413399bfdbddef5511c0ec1787b59da6e55717edf7d0c7beeb4619d1c2181e17d165728c0a4f6a4555c7443b9c150c22af9fa8927eb4b7ba7ead3872c2df6994de92149e559a698e96c1dbf29cc6311cef9ae2f0c746e254bf3e8fc3c82cc78fd3370f134a8f2e0a80bf927a4598bb9319d617a24f1eea87d4de6b24ec71fda1587c4fb25b081f5e51cf17376c6174dc729d149db433e76f7a63fbf8b80b444cf5b0b2b836dbb2647f17ccc7697ff6e047947f7d016e52f360184bd861c17fdf21d6222f9da28e44458ea6cadb6c54532d42dc00a00c6845782cbec0217ffe5e8b2bbced0390597fee3a0dcf1769a1255f0e958d8173ad27914b54b98d952ad43cfec8d4d838f6a841737cdb27d150760ae565739876ca1d1e3d028a207acf3908a99c51946db3d346335112ec2d5fe6ef002b84ee8d3e51e1425fa2d4914c54054bf3dcc7188230881a11632625983312c722f73556feea802d6c7a1e50a3e2547efab77501308b16e58d1567f5738629af7b8bf53d17b35f76eb7113985141dd50b2e8669a0e9c389cc349309a3f19f405647116c2c3c6bef0d934a1553b001a40eaa885cf6ee3c0d1cda70c7839c03c5644a9f53db331b3170cfa887e2d54960439576a90de32094c3482e5262993907349abe240fea9be7694fb2f580f3d86928f8f0cf280e4c41890b98ff6bd9b5024064506860e2088c95508434b078cbb1520d379ac6dd9984c26090b49c94e82d333cbc4c1514e807c94d5441f4eb5cd842ae9751cd1f34ec565b42ce49ca98b140f4f200f9d0b601802390ee031d173139648c0af63e1b21a46fe468891c48728729553210ff91267cb0ec9790f3c656bbb5fd9f5ccf9e9fe0e1a1c2bf1ffb4b104a1f5e5908507c68e5d8772f0b410c91304fdc96aa480464c1488f4221b6f0a10b435d31263f87a87d4b5f462322f70bfbe5ec006f973e655f7a84d8c85a951bbc8d9914d5ea257c788447f1415d9c71b135562c40bd167b4623a22382dd4d1aeb3a6212ef7102c3edc7c0884eda090503f6ee7f380d444eb9d7203e0f472039a4e1f3abce57802bcb3c6f29966adbef04777e518665bd3d1fc5bfc8c31ad1e9f755496775fffd986adb73f52a2d06c6abf92de26c199e4197c7fb2b2d355bd23899f7d0503120975209a824fc6f6c6a7e846af89ff747ea4ee1ecd07583677aae830e7c4747f7e2e2c46be2449905fc3ba920c0c248197ed2edc72b9329b15cb265c80a0eb9bd2818c98ed6edcf6f903e43adfb8e727604a8366ccca27f6a5187bab994bde4d7f3642ac2f030e81c9e050232dc908f8b15379f2cf063871a63033f11eb950e0c846c6ad483f311bd51ab857a0a8e1b1b9edd761f6a7fa7570d893f35481247c47896ce368aa3c1ada030c6c53cfbeea55bbe8a43ddaf9e0a712e16fe4966152b01db5d6f0e40824b985ebf31500740672aeb69f0ffe9748a2f595d1f3075509a50f0a4a7308ee95b31563d84ba89eb9df3cf52d865c5e1b23770d38251500d67c0966d43ca33d2ef149a376b991371200ee807d8ed3c261119a3815d3023f6427a92efe87187b1d6d8216f59ccfd6426f87bd2d9b6330c75d2e1fde7842e230c1b5965a56922b7c2f1091bed30c55b0f4998b4036ae54fb3da1cca850d0ac54022ba3c24726270584ee05ce81137d4b5d4a80e230327e80428899dcfdd2de6c0676d05335ec386af37ae486df32b8375be06bbe6c3c6044567c982262908b9c608d5fc74bc4c0f769e862d8cb256ad30a053f13e13212a2088d383ff4322b81d47667f9f0a193fcb3054b3eb8b354dd55bdc23152af5b910b97ef2c70c6edefbe8bb481314dcc21bcaa1ba213111860e41d85fae646affa971e448d2af8b1b2378f67d96cce944bcb241ad2770403c1d53cdde111dde4f1416b5c9e2aa0f0c2746e094111c461af8fa4e4faeeb26b07b9b8de40d2bc570e8997dc1eac8be9842ac2bb754bbac89761d9e6505d656354e91ce1067966385944be5cb734d9cc41912949bfcaf18e43b0cbd3f2cfb936269f3d6f273656c874b29d39ead3002b76ca585b5982e43b72e09d5db1755ddb04ee6c879edb651047ff1e7cc571796b973e142cedacba15a690c7a28f826e506efd6085a3abf442b430ee7ada78c636cafada746f855312369c874d4327752e42c60072b21700dcddabd578b2338697fa244add6cdc5a1a18dc0fda4679e6bcbed185c7a7a2faaf800e781e2ba1381888f165fbeb26b5b529eef5758d736a8997b9a22ec889bec3c37900c837b0fe641bc90127a56051db4e7ccc76b166e378053b90fdc9382967274d46c66b83e30eadb1d33bdd7483dc2115e0d192043eee51cd903598783abc5b89fa31f380a59a18040d0774be422cf9147ba36c672031295fa981f6936cbcf8226d2cc9fbcec3d54494cfc032646d44d2b5ebcddb53b81bacd4feae20246d9d042c8fb86ae74a587fc34d1c69f3e0f0f5f00a320bf94195267520b0b6f4837c999ddc0c91be331feb149b7bdb5e056f054bbc78b02b3d2d54d55663c246ec2d974255f8a5a7283e795e4e5cb85ee5b07010d6bf803868ff78c0a52aba796e5e0bbff9a12bf4805985ca25fac33a797dac35cd68d033b17dddc96ce1efd2efba54410502e5932b45cb16f96a1a8110ec885586ea6dc84aed7660422a06cb7b69a015fc29e385f6f5813168629c27d7c6810834565ac54449fd0efc2f8e8f1e561d1073389f65d8f9c9437e23227d3c6af534735a0106405a6f9e138f95238c87f422b807c4695c38de31005d86242ba48c8e1714f214817b11930f381cd8e608d842200544d2c6f20d885aa9d9fb720428ef6abf2efc65d22abfbb80d4bee3ae1b3f68b56c180b728650d73ba0d04d0f180473d0b3f8688b5398d892cd11f0e50b14113599534fbca652e947f15ad500eceffc7058d622e4a01289c6f687737ceb7c4151a00a64f837758509e79a6164ae004b72bf86fec5f17a856ce1eab52bc3f2e8a0543af509718d6bd34d69499ccd5bdf66049b518fbd1ebe991131e113096aaf493a3b0fe3c4b88443074a448839bc5a988349542e66c11338f43f5b19e72f748c20f18d144e112c2272a1710c5125d0fd38ba8dd11c5870a4445eba42bfd83d8d58299170ddbaf5bf0d7aed482a284cf4dc21593bb23b4abebe6808ff8e4406749323d6c2d77b5a3a2f72595631848ee8fc259c01bbf22aec4fb7914fe131407ed012010522f667ae606dc42ced29059665055edfd7eb45db205050aba18ad460772526d0ee47a39aaf4525f9d0475dbad06f74eefdfeea754f568e1f096e83957f7e7f800874f2ad24b3b824b6e5e0567edce32475fc22b128ef6374558e8818f429d47c38a621abeae81479cbae146817bc09bc8faa595dbe030b10f423a99fd2b72a02351282cfbc7335d663ff33cca8ff7a7a6f0ac8a6aae4865e2c73fc19b7d445859ddab9b22be82c5e759d1a28663e2bf32df94e474c0256fb3ddc38741d86113e2aa4d68452e0f214e4261a1e5faaf2b1a33c92f6c967416e4265d812c1030a61a6bb89ad8e25cbb9f4781044b039eacb7d6c82f372e0fd0c3ce98d335966cab755c4f153ec609bb2529504c17ea587ab423be6addbaf92ff9ea77b8aba7b7eba542cd6306adc035a9e9c32457442532408 Hey, password is required here.]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>测试技术</tag>
        <tag>测试分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试流程介绍]]></title>
    <url>%2Fposts%2Ftest-theory-for-testing-process%2F</url>
    <content type="text"><![CDATA[b63abfd0cc043585c7f59d942442ea6d4699e462251a37067c709d14aed2418104a209148d11dd652e438e825c50a72954f0d29751077183e74488b210e3253433eaa5f24b48956a8a9de80ee37caac6886422f9c66c37efeb3a10509c9594efacec185ed439214b63fd71c7b57c138888c981bd0fe04fa538b8be3643340fee6301f15e24acabfaddcb7f89a38edc7648d84ebdb60b680fb268e512be2030e1e79d94edd9cd1c19abd50b4c2cb3043cd5c24414ae8105e5052742e688944ca61735488b645164070657edfc6075861d704339ce1dd68e4ce5f51b2e99b9d1d1af8ec1ac3db4c493cda1421def65ef2cf7812f9ca09ecdfb0977e1568aef28e4d8f9f581110539e49a294826b1b0711be6f09c02e940b11e9371fe25f589216774bd97593076fbb4537ebf86b8f8fbedc36e2aa5aae0854f77b3696deb3047e300bc44682608ded56b66b5a66106dc092ffe8d11094b12d8bfbc6ea4640ee85f6466e665cad9914c9cec25ff2a949b8e77e8cedb9e779b1a23e8ee3c62c9c5f9464388fc854381c4be0896e632a23cdb22854d1139d99e4be13d4852a0560226681e17ca5a3533fff99cfcf58f6771b7604441775cbdaaf2a3f9d6d9db41019853725d82ea2e0d7717b925e9e886552909beb964bbcd8eb1748e1e846f359be606da97fc8e03134eafc9b2ec145b7f05a21d88f885896c4e95bdf4c084a31a142dff43009f69848ea9de392e96fd146cb613e104ac949662625da3877db1740ddf1d418f3d4e1e04b87518134d57d20927b1d00cc0ceef2a45d30a60c809f25f94443c337412648bf8c9fc0b86cef6d9dd18cd784a0b98220e1fef21545fc21eb2a7b067f2914d7c567ae27f4882f4aabc3c621f3b741ce02b6b68ee1711c9f87405791dd3dd75a21e5506655ddaabff5b57377e29c11c22ea6e7d3620321c908ace814b2bb3bef2fbbfa614597de7c7b4247ce4f23a9ba9356509275fa3acbf911e1b4607fb354bde1a7e1670cdd557e93b57502fe110838bebba32805926551bd177753a59d0d04233ecfeba8a9b468c33a8f5448ad7c9b168b4549ef247debd143c1b3c8daeb581f7f017ac6f3c0f0b924ffbc9d2313c157e7b3c70ec0294756ea4b24155096df88f2912f5d6f9664276c7e55a6372b3adaa7539ed546345e62928c6bf13a530c42c6d78b55995c7dd14343d1dc454d1888d7eaaf02baf8d949dc8882ebe5d10e468b48abe70eb215e8acf48d9c1d43f5b280e8df8f05639df5824743d2a6b2c80e07b8655351d8f58b5e4eda1e7d842d32b1bc6af6f1427b8ecaed12d2ef014188970b0273c83434bb11b2e725174661d5f100ef0d88ec0cf7edbf7a26fcc8f7ba323ab71a9218df81ef04bdd4fdeac000c368d88db8af156c330f205d41bfd0c4e83b875689dd0a27a665fb4d9bb1469c94e2cd247a2373c57ffdffc39cd88398a5d04883b373be3275aad67f14707709220e56784d076ee914df79cae5deb94c2e82776d547fca9439e786dcf901307d9d040c6d7661854cc2717b44c97082a94982251af382b5d20b39a3b4b2a4348d81979f0802a1a870ef9c6cdd0dd50f649db8fafeb55519df862c7e5970e6867a3fb203de7f82ed6c20700afcb2ea1283ae25d6832fff576ae66c138688d17d3098a7c76a876aa4b756da06f62ee3da3bcf97e52e4c6c2d6fd7add103ca3c9d0ea8a70236259ecd223c36962b47b672d620ffac4a82142e8ac02b563e9b9db07422c272c2c2921a5c938bb2e6deeb611a056ec17072c9e10b9581172f013f0590ea7f905dcb7b8a31b145f6db318cc6c279903fa424ec85e83217a505fb4b7cf552ebfa127c410b1acc7b7c0da295dc24e936e3796d9483dfa7432fcd6d110c33a55f9822c500b0b6c5aeeb72239e6b804a6799922f5b3d51eee1ee04d9a5296a380c4583f10dd288e3b3a806b0f9a0f3402071d9407843556d3089140363686e4cfe932b6e2ecc966961bac9b68eec38c9ef5370550b211af954b9b37a69d0228da6b3dc2eaac18478a673bf7cb9bff67468c60bf4efb853d02704b1a65b7c035d6bc31113c1d184f43684f123671b64edc6620e63d2c34698a280b5839d637749e43b8f1837b625510687601698fc96a0334a61a378338fa3ce51999e078d5b1526f4403218c628ec09cf1cb49699eb8cc037840fc6d9cbeecf3eb5bc7aa66f58350061b5457f6f1379a73fe264c034e3aad2f275e520429d9f8743ad651010993db0ebc8c56b7664166372af3593550a61246349f241dcbd5d034bd9909aace36fcd0df224da986aa425b7b1e33facdfc2c2bc2e32999a3b0de61b741a187ec74bf760848fa36af0ac5f17253ac5618fbd5c191ec22d6a455c94910d10667deb1b72dab2f8bd6d878c8d420660333b4d5ba89af96b0f22279eb68918e67bf5986ee77fcb9e3bcda43c03e60c7aad422a3d57052a2e0d0464ba70d6964368929019f4daefcaf528104646c88cf2b84ab22e9d542948316e7717913b0d4f96fd2dc2d415253d34ea108ffaf39fc62b51b05084dbab658f37c20a5b9c513455e07f0bec49dd3f90205f29c59c22542ef3e3db56f66dec0c84683ee3725e3a8f19340e00bd2d2350ad157ace06496db907be5224a8b56af86ea34aa49e8309b992119376a7821e52030e6a926f4987791f0fbeff15739271cb081fbd68ee3655496176245fbc5c5f2463d16517856c46b6a00588e1ef3904d9ff67141d14867ac6212bf96d70a21fbdb91c5542b8de3082bb9a44aa38b73bed921d6099fca9331aeb315d935ad16592ba0db19298dce5e2f8dbaba6ab10320a127143ad0c8e540d3c47fcf96fe4f1c1f3035aa33794cc7289f3d36a57ce1faf58afee9eadc0fa098c77bb832ce9a78c886a2150494de30e049e18bfb03be395102687cf32d78a0d3c0473ba6b65126a2c565d002a84401f33d6664586b002e658e1d8751e8f68dfcb1d1effef026ab3e6af62bb84304bacafcf496391b7dbe04279b3c13ea4cd63b9fb96c4cd3b4283d43bb226226339cb0785b292ff048cbcd6e75a53f3886b1c77ad9e144d7d290e69988efb55b59986e5ffe5f629ae49df39a60edf96dc81db770fbb45f6c73778baef1df2776b4015d73d215fb2df3b144de5168c3122aca5c141e58441cee0d118290acb8d89087c7224aea7451ba49530917492face33bb233bdad79bfb12425fd8ce0dc42a58d75d2b1e583b24a7b444db7eb291118bfea0d3f50c452d3857f36064cde53c6f6f9b2753644e324dcfcd0478071cb4735a73801c983c2a8ec58cafff0b3f914b52fcd0f909e64658bfb8ab33d80d01cd4164cdca989119ef2a0d032fe2c6cf868569fa47ea66c25d9f17eb28ce55a1db954518cbfdb2a97ef4657371dba5c138cf7e91f18a0b6b663315fd4862951b2299268439b4246e89902a9ccee6bb00951d32e65b933b9d785af425c97c825e8ab05cad98166dd60edbdbef92009fa54a8f5c5051d901b3375526689eeb3e08e9a41c1b4254b6770a1728674beaef43f2f99589ce85ba33a4022413f84ff3e37d77e4db601cb8318c477472caaa64c875a6b62580c0b6cffbc06a56be0d9828f232397a87b3e40c80bcdf03263da0ac1408777936c121d3fe7533c8241bc6181ac6f717234b96ed7302102b8eeb21bc47cee9880be799ab6d6cb45c3e1c8f3f10e46c8b1d9de7853d186d575e0e447e20b6eb37526e7cc2195bf51b76f3c82366e5fbdf5f72eec664c10f2ee6636611917b3db1f1eae4629ff85c1eb6eb8f40756c5ae10706d729f40a895eb5c1a5fab261cbc7ba806a76e0fb699a24307a5e5657f4a7d24498b662a29924514f4aa356a024d889dc98b2696fab5543b1aabab22b001a591d7302c831cfb8906598eceb633caffceeeaeaf64282287095812be0857720d4f9b3a046e54447d57544e0350b52a36d5a18f8f5a74f87e4cb82d43800e047794b091c43bed736a967a1258b8dfee4999662e8ec94a94996fa88273a6a7eecb17368ea8850a58ce148bac03f25cb478d5f6cbf34e7ad39a54911fcab403ca76075466c45f211f60d7d59f2bee31043534c507c584ae89c724b6644a27d0153eae808ce9744a8c648a3b5bb94caa7d4638d6d7e4806f7e57d5f5751b6b07943e4cf1f8f4dcd3ee1317d49b3a1b1b0f8cb87dd2e9cea0894d735702207f744d4328b66af04816a46a10e642c82a3e191b8ccacff6b8a26636f8611fedd1439a10667c9c97449ea51bc990ef89f41c81d26a6d6148516c1588868a3a0984ec9b98f9e5cd27097e591d35fed1c9bd2a916b417c5f4c9376e73334dd62d1c70633fec9d023b3cb4c132c6f39bc79e7d4b7efbd8dac37559660c97e8e634f9433f10948e651c79c9faee597eb815a63a2749a26e8d5a6c1bd5877776835191210741684919710acdbae51d06e5355bc851c302b799d2081b2e5b68ed8a1c2d6ca8e2f1b29fb49d1624d0b23e86f0c3f2a47559826bdac947d12e479ae734d9a0ed6f9c4dc525cfafbb1e3352cc14f9d625bb5ee3030bcb014c053784045b0cbfab90015cbbbcd94088a87fda2d0a9c747e75ae59ca1dd617e8b0bf7e36ae631a06ae3deaf262dfc29476435078cb7285b1f2a1108d810be754c56524a90c919d1e9c29e760be6624e1635c2fb3a80cb1a577e0e23f19991e4f90cf4f7bf44fef139080d73df6b0e9858ae2f888da0a7b695f40bf6a4bf47b6748af55d4c084615593f3fd22512c3a977d1e718a60f5011932bcf0b903d95b0a5806eb91e6e0acd7a6654d525a8bf3f7859fbe576f3c26c306d398b4d890deb012f99cb4b66b1b1217b5081eddaa3ac4f4e2e4009ea7df8a9cd44b6359f37423b44fcc921227ce5425c9ea81ddb5cad15c538728cd54c5665f03efff6999481cad010dbbdbdd5116b039107d0614752d69e07b7e7f9faf18441a66a1aea81e9e135eba997138f7fd02a326fc4c5949c43480027148c6cc668efaa257d198d4c0373891cdc66d3781e457b5140730856cd929c831d3b9f2b20119695bb0b39eacfef013d15a4d16eece820a5479491c639ac2b8fe1c003175c31e365538772c13f8572b67ba769653ae9c326a3351006882780724c89d6d9219abd4be070fabe18d9495878e4e929b306541ff244013fc5628a17449163731404de43540ffb8af6d6ddbc2efa9803659dedb6b42b7642cfa0fdda1f26585fb660c643d487e09a73751fb93886e68bb526363b5473b3305b29d2ee1d8cdd6e1c666b3432f23cf3a61c7e67f74d953e6b3f169292a8e52dc03a5deda7edf100fdccaafe09c036777d51a6e16ba65856b886235aba8ddf9ee6a91bf03f2061b9f9e76e5f576e77de289a0d6fb7fac29af710c4b1e55948db116c654190e37985adbd9c282c53b6392a8438749f9dbb57ec9d349f376f3240f05bf50e65b99b1e426ebfdca87de6f125752c88800f1c14adc2c89537df9d6d13c31d537e64b0a1ebc107129f464ea73a1d3fd9f1388ac90a9b42087f55ff2849e20ebba75515977865d062b0ce3fce997e66d9eb5c7e1c4ffc99d9b8beec4d5ecb399094ee0d7c6e2e9c1e9a40cd990b86cfea1d32b892ec33477fb4b41459f937b1af96f630d29b0b7046345bd5701b7f2455a08445a4a4a44c1a841c749c8eafbb853fde0fdf51005a32e074c3da033d8ebbfd1ecc766e15b9d64e8d29aa62eecbc7da32676f3aa39475f28dda77f967fbc087b19b5051a34d724f627ec0cae9595a5e6fcb725416a10a3a6184182b78ae54dfd3c211ea868823c5d015051f040dd1a04662003f04c6a36a8f2d96133b5df7b8e0f5c1cc1f1f856bcc3018e099030ac60c319430cb7ee51bc289d507505fa93b0c857d2e4d50f655903bbd1f2b1ef174a8ebc0e464c82f20d9003f44276dc69c84e7384500c4e9481fe86c70db15f3a7bd886566dce32648be24f5ff9d397a33510d2cf82ca049d7bf1a23153e00115f22cc776702afeea42f8c4c5a05f914c063e7ed3de6c74e55ba5b2b156b35bb4830f7da03949a07e606bd681a000e61f33c5defa568e3b71900d186336a42b6e6aaa306591a2e3d09eff8d46db1709e9b673e0ef8b5c657822f9f196414ab630da439712392ea989f4a03f0c287406948b2b4e6c6adf547b7fad3e708d3bd1ef27dd1dd731e222fd717a0fa07c1d16477c67600c22cf8a603b3dfc53e45fb0b0b5b1f0e3c90cfe90f7f065312b6d99bcf2a27c1b0f15ae08a856e0daeaa991fc87d2f53fa37f44a4eab54e62b48481437ceb6c551e011a05c26d22fee63b6f8f9c547d01c1a50dd3d142ba8bac2418b5c1daddfa06ec357af3474e10072fc3566f86ee222297babb5da9bbf1c34315a7019b165af3b17af41cf9ea2b3a243f360272c368a7ba895581480e92b31c369c91116e93d0220c0d71b9dfb15bf93f7a5905026aabfc268d71160d7d56b9f6f2dea55ca1c0fa85f4f094137f4f192745f1742a9306f8f990aebfb6227f7e4ea8a782ecac08cf0d079a9ff2d9fb3281db18db488df8183eb7c3402fdc3b840ac86ae703ad9c71900e96465bea40a7282305bea2b38872240639e03a89b08eea89b19779fccbd69de517fab6033eb3f686103501531ad2baa5068cb3ae08fc906865019dd28fe78573e51dff907c0c74f21ca1d8153ff43fb200a405d9560fafbf4782122fee835610400ef4a87c1a3c6fe89c0fc31e690f9db7ecbee4ee07d11207397052751a38d7ad88a4fa543e94eafeda2ec26bb135f485edcc45f6f553292124645c380d0e33c7d43a625267482c2c3cc94f4b7fd32a8f1df87916ecf252d87d76ebdfab14b1ad71499dc93d20c11bf489700b1c00217f5a84630b613df67b0d35bfcad8ca088548f23e4d35345368468afb61719dce2d8b0eb3aab1978f564bbc5f50e30cfdcfc155924645d8c5ccab6b8a140f736b8798adcae768152bd98be8e99256d7a22cf73b675223f864c4e3662507509ff422873e165ad7b4c7e7a4e5ba753f12e5e931a656350b9a064978d4fbbfe8c1890988f2625e50f5c3e16caec0501da5a9a16d5d7e557d8bb9b5b7e02658cc164ad8a122a5d599a945cd070cbe4ccef45c59a193fd7e56e8ecb8371409052ddffe886e187a3fcf81c0a653c896dc2f2d0c1a2e04987a6ba473972bbb74a72c498c630e99c7e01c62f723d6a80f97711a74be90d8411b5012c0632009ff0652a6eac37e30c3bd3609bff92926f2a8edf5a05b5cd7b80b7199795e042778ffb367c711e2a7ba6303b64e395afa954499f3505593265f8860da70f2b981cedc3a4ecb7ab21c50fd0c62b94283055b9a23dbbc08cb2545ec207a41413edd6d371d8b5ae262f3385ddcde653f2304089f5912768c5104ae52e00538750d8f559b07539da316373a90ef9ca4e768fab500f1177394e50093b1f18ac746ff4264870a20f5360315f8240930c40acdfb935974ccbb413d89dd94435b6c6beb29c88b63f7e29896a6c690366d808abb7e7925b36d61d18063e2cbc89b46da4741b9f91cec36528d0eb073b532b955596a66c99993484ae5d01338472863eb9983b710be8eea0aae06b83d782b1b4c0e6249ffcd488da49b7ce5d99b68182983a0883a34f318eb8fba0deccdd19b790b8a6c767441156954684e12be7c6b9108b8957de5ebfc2a4feed9603e0f44f15126c8440e0da1ba160b099545d7d8ffdcfa438468daf5540b8e03cfd380478a252655cd31cba9102be7af4708d450f9c88e860abe98cd1eb065494e4ed786fe1088f9775dd29baf28e0032d7398ba0bdcf6cdebdfb0a5cb5403b11de3e172875a57c619c9a0ebbe990bfe8523e54d681975f4b014b42e80c0e49ab6050cd2b552b96134e649eb5bf3db5ce374168923485771f7d19c7c9ce5c8813788daf53e7cbdf423640c1204afee54534d2d9175b20ba7c18c21a3016633745c13b6bf6f72386537f93579fc28eaec3767141defe51107d7ac6cd35ad5009236cee1bbf7eebf74b3a507deae5e6297e15360b65a5719e2496207decfef242f49fc491d01d23e1394f15486156f642e87d2800708ee3dbe54e6364b11e5e934dcf77f7851fe7edca8bd2ec9bb69b09d3f46a1d7ed45bf490af2db03e5378845a352df5ed332e9d537c3facc9fa5ca5b6a07d261ad24d195128f1f34934a1c2d7f46e2cc70b3fa841ea3ffeadd3999bda5b581d1f9ab4905b290378cf97816a34c66cb28dfae15d7c91cab26f8fe2d27093098f54ed45297909751ef6ba81314b73274e1837f9f02fdbfe3b6672c75b8f7218acbfdaa1dd0dd861c806e99b5f80fe06ab4252252312ad3679e8e4d98a6d1945ac5137fb4a49cb3e4c6b90c52f91a8c15cc7066aac608b5e794f16b4f5c786032e9f0a9e18a1035b2e885dbcec61064d98c42a93b62d31854975a845011cda4c8ac37dca8fa3b2da8ab28c13f65a594ccffa80f4f71bf96291cda829014fd17c1fe722c9aef8dc1101f729c417ccd95264c66b83d689e78e75ca052e88cdeb03ee33feb960975f4f7c8204b532174cde320efbdb080d93540b26360d1d611e14adfff7591a7176c8a0977a567b028bc41ab010112941bca85e77845f795adbbb7c05408da6ad28cbbe34cf6085a56d4fcbd30a3371cb02ec708d1042304db3b4c69994a014c48a8151c7b8064af83f30ad742abfc563bf7048458c35be4509ffa6ddae805b73e215164072a8b10f8001ad48fc94fb23facf45dceaa9775a0843d310c9164bc3e67f972beb0cbf193b87f1bc60e965e9af553c59d6bd061fa06d443d0e18fb434f15ad72dee304539e7c41557f8532b3da3c9fe994aff370099fe424ec0d3a5196936ef4e2434ba2ea404884f338756ca57b08151d5d4fb613ebb29a2222962c29156a7f54eadae7db3912d3d11f630ff5e58a3a1330d57697cbdff4cf5c3a4c3cd7f4765538a4c7c6a1183b3c0a93b62736a4fe7522ca8eb337b1c66e25236f73aa83d6e6862bbba0ebbf63621e28373132a20940229889cbf8e04839a96ddd223b136e74d11326a08a99df950d6f8d35d04489c0b92e36b44f1026449f786ecfc7cbfe7647f8c38a4e34bb1795c9eae86283a5eb565330352d2fc024bee867ff31f31c1eaa96dad3d4b3c0a71c8e4dd5f5ec23a059db65dd9e4de8737a1818b0469138c33c767c81196b8b1854cd4a1710a3fbb3ca658282b805d2948e6970c6e17cbcc7f273ef897ca73f0e97fec27732735f901b95fcd925527baa544ceb2df89a64b40dfbff7edf25102e23597d26cc9b46c5934d9ddf2e5d6371ec9b18493e0082e9c0a9bd3db779e85b652ed13cc1c0d9084e9488f2b496a63d10cebd307b4877c2d0ee94af9039d1f476e150363e5c466929864d5ecd1f96510a8d158d58db61e1de4d5d766460eeaedb2bc439679e80f52664ece81864124aca9c9f4b453093ca5d7e104bf1f049db69aa27fbedd6c0f3e06da7abe23a87e668f714eb47b5fd4aaead40acd72a7a1eca06cdef6fbdf84fc54dc44992c233750454cb5064bccf44d8a59302063e7726e3400a1838c2b62db6f3539c100d5b986eedbd5c055bb0b0781b20b6bca3c1a8c1a555557611f6150993ecba5310b20aa4f134dbcd603eef9875e856706a8365f8ba2e72b82c532112dc4df3cdbd915a0a5f7b769a230d513c97278f84fc6995ea7298da7378f67015f434638df0b7ac8a8d0ba0a4c161bac97bf1eb0a980f56cac2630162e6593474517b6fbb2eeb6779f2d9a80816a7f06fe5d8342919b6280cbb0eb55ad0978a525a93a5bcc0fbeb733ff70645abe37ed83045a5131a50fe18aed826c73e1a484bfce55d781c99502e29d21392f53e6dc34c7449ef54078e3116297d7a8ac99304f3e1d23a62658955cc9c36ad6e09bea5d93354fdd5c49b04efdc8f5418ceec74edec77b122acea4ef844ea5fe3c829de25e3448272e011e3fa150941d0001a4c301132b227fb4ea801415cfaac51b11e0e913f37416938e8af0b3b1886b7e70c9d065330e0587137852107ea8e583e08a16a18ee0b068b21bb163eb94c5e64200faaeeda32eedf5d3b0088c2949838b9bdad4fea4778babb546a1210333169a9b005144351cc6df351a4fe1708f1aa267ab789bb78ac3b5dbcea709bee96003d0b621775241b351b853a90a41b9c5840f0813c68d96f830a242fb3513207b622427d0e552efc05e3c96ba3561ee1986897d4b97e26579e0de32ce7ca953090e53288903f778f03cb45484ee881ee6c8cef1bd7b9befad3425ecf68f7ed3e0cbf02e4008ad1d61e5c177cd1529ea6b4dab15418d4b2ecdc73b7d1823540b00db50fddb749d3313d19a134302b997527f3f5b3a482fdacaedd6d8d9452796866e3980a64a7bd80cca4936d67fd2ba21b035ae380823dfc381316e76db255b9dc8d53b77c4ebc73821154b9bf7aefb1e7b8fe67822715bdc108736f70836834bacd531ac008006d7015e0930d2ab02da6a7b27af10d59eafa66296ecc8b3d8d6c78df99fffd5ce731cf7be8de754aedb907a6f1ff0b7f386d274bb89fe528a0d2640c41628dfeab75abe0a569a96339b7b5165905ba5ca425faf0c4419376157f13f2b437698faf1be0c5326ec0d791161a97cfe5c17159041e00b6b04bee110c7d02a9809c563c653686e0274764d5d864cfeea4a7b1aa96b448286889b18bc97ed54d4b8a593eb77ea4530d60cf3c58afeb12aed02f91b3a7ef4ae6af68746dacd72ec662592c11a7dce9f9b8714e34f0733735a3bfe167bf68d06a6257a2e499afb41b996ec413cbecde46eba8966f295f901aa212e597dcaf054a43d72935352bda67e3c1f0f5343955d1d8698bfc5ba3cf94dd348e490379d897d41b6912339c293476393367f04d7d826b4d450cae2e8856403c1db506382b9ce15fad0cfeb63fc21aeeef6ff6f684293f75a9cbf5ed109a672528917ad6ff19b38f8043527783ab8f22fc4b182326fd201ebfd50f3b4f7b45b93600256a951004cb089b6ba727b0551099b98b7cc512967903d2a345f892452877b83084ec41940ec05573513df0ec602dc7225cf8110f3f2d5fb11580b184beec234ae638c116bc8a92ef40190f8bc1b545f32d2170cd35d6cb474f90f652b81c8720275a89abb57c019875c437fa33832431c0fa2a2fc1105744ec1a595f81a6e8b9e76d015dfafa9695a2f9c4745a8cfd9c36ea6b2f3879823d814bf6602fda07cf1e6a494f5229ca94d395b15ac4770893a62827c784117391e009ec6fdd68770e7df355370082569acd96f27db370eb2bac8fc9e57af5a129dd68a0c24d89488177da4081b16ef5f41c3ccbeefff55159a5fec68e2b0f919091dc34a5354b263b8e2e7f9735b5ae92e0222a252b5f34bc22d069516aca87b96ea206b9545c7047e33bd9cb855e511868768bef283628bfe0d5320a57aefd276b28c0485b85e8c766c71ab3cfd41580e418f79e152e9d7f590728090bc21b5e5ef943d949bc37823055fd86eb8befdb73f603687525cb32af0692e8dc4c0c55a6e4d80b5d23069eeef2ba3e9f01d084d4e9b06ab7dbc5640be57a6cbee3f7447ef38d64a3a36b6c41f8e6aa313258f5332e408cd149176272dd2385bedda434b9daf8113d4106fe7c853b41fab01a3b5d4e5f0a9d14ab294ea1c0121cd0d68cc3ce32dcfed47239ed9a2d1f4f4f19699cf94ecf92e7d220e7afd5fe21cb1e97125a33842e1e6beb749a9285d6aacc09176dad3a3cd55a836d25c6b97e8551d40fa938b5546945ac8d09103a758d03b76a56aa6850e6d568ed14bacdd3ccc548bc3ab0acf1d5b3517b708aa754dd34b3ae704cfd18d8a7fa8e76b829ba092220cb782765981276e8192c54d954c8693ba67207061775045a0d5400dc5ef22fb92bca9f0b7604d1d09817704344c6d9acfe942dd5fdd65d8d09695ee458a4df3a87025205288ddae63d23f94eb5a013532bf7db1c971da2e257c8faf07b050e3537a079604d0afe3621c73531e62cc40971760a508387efb774932e56b22318f9b092628c5e3e513caaa7488223b156e6ac45e6e2e950e7b9b287268000aa139b5712c5d23d432616e8b0a961dec94f843fca5d02d51c732e789ffe9bfded64f45627df83a7521eed983551f8f199221d2e2008055bea926f88ffbb254f7b42ed4d9b812e7a72400498d486e905dde081ac95308d4de730137ce87a8107a9631e977b8796e6659b31f14c4c913e16e5a061e21e368204dfc2266165c0401281f6877ab529a539589eb531657cdde4431271b344d0bf4f2f7a50b1cd4fa62ea3bdf51dca11af5b932ac7c650e42b20d8405f55961671e096e7e1e67b2751d9eeb21155e7845f873603598aecc8483dcfeae00744a74ed17f32440cbfaaddabc4d1bb9ebde20dfad4265ca3e8a14f1426af466bb03a00c37b3e36adae5372ebc03b6bb3889b4a6a39ae1c656adb940268cd6e21683812696be1b94315cbee0c44a826a6d3a0695ee8f8ed2f4cc56251bc88094dfec1d7d8d5722fe6e819697d6bf79fcd240ff6656ada41201e8e107b1ff5d40cfe451af9cb3734e4817008a08ec2213e697bde134f067b3c483103ae3b4c8de86b10746222f53eb14558d5d641b3f78447bf895c4d15c8784fe0c59cf4bbb716d45be4dd373f97cefd8a53292313f907037492e3edde7f8cbb27096213 Hey, password is required here.]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>测试流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件开发流程与项目管理]]></title>
    <url>%2Fposts%2Ftest-theory-for-software-develop-management%2F</url>
    <content type="text"><![CDATA[b63abfd0cc043585c7f59d942442ea6d5bbb3fe401e8c0374876af3f208da5e6afad485d6d7d28b954c9218ad4198390a8f6a71230253cbb802391f23e62a27dbf05bc2043f60a718fa0b8f44c0ef27dd28d069a6b5a832d93ee94edcbb14d363d30f3ccd2f9acd83ecccd13091b54b0caeed165fe158634e9b223a49465c0d432896bde0d9c59413ab95e9fd7810cfba8ff20a8747c4c2152494b4c5e68501bb1ee359728c8ffc9b2b00920fb036ec219972138a01247f9328795354532d3d0c7e8725f19b502c3e85d169eedadc0e593b169a0315d16bc3467d3e60e3217ffe6265e079dec05e302eca95ccab36ab2fbf0289c8417e6495c8c9307b5729bb3f45a1f594d85162b023d6b52320682ddd9c4fc8414d0039783fe50d570ec71750904525f08eeca54b001af21a1718d1516f2be1ad45945a60498b4044e152a55871856edbfd2af10885ab62f5d632c3f1e4edbdb0fdb8952b8c56e2be6ce0b282ec578f7a62bcb0c5a401cf8a25c86e4dcc1006a02a9f964d85db97a54879b210e879974bce8b2e04e25e6758a91df9ee5df7e21a5a94013c985aedd0bdf277ed5240351b88a7dbd071686c238728ef948534b86b491c4a5b2d58daffb557cfa9053762942120926dca2bd6fa6052eb75d2c976da9a12e12c77f3e8b412b0cfcb27cba4cba51148f0995bfcc956b52461a8c2d879343de91bedf6336bdd2548e1f11a27a484b0a62257e2b63740270775cf6bb2ebf074774129b2ad3f59cbbd124652cc6ea60e3ef880cd8e4247006c2f3e4e2fd9761a6ece089483acb9ef52bd62b15bbedf467773efb3c9a02ebcef6ad4f5fea7f8833d4b93d8f0353441664d918d7214e76a550cff9e8add1f66ed4b8cbeccb48ca6cea49e6a7ab94c614a25d7ca2463527e9c50ad7ad0e3c4745139a03dea7d2107b41b0743fca03eead7cfece7d0584c44b2edc9b7072c40935e6d03d2e4e417c1d3ff60928706ea339b069bd53ee0e8d1dd4235d2fcbd4ed3ad5cca3b6bbeb848d1208b6b2291b258bce0b56e52477a1d90d761d90643d562db8b91c3eafc9762e563646501459fa22e6452090b208405d6246d0890fcc1c15a8854d2c0e6cddf36bf421e518d7e5c8ca478ed3b7e3e948025830847e3e3aefbae5c223d6910c851161d37c3031d3a0245c1d2093036c9e0307b2d10fbb1cb25a79f349286f24f47cd6f919957fa3b6b198fdde6fca8e4485c732a912f4cd8045bdc81de6a14247554b89b7b1a4ee6c90b31902d9caee4d559d809b5e19a8ecc3981c67b7604c0f2379c8791ddbc1288128b1b7a20e6eab674885da67810788dabb0e02c8b89a665aae0461e7efcd3509da57ef3b6b12a42f369de60f659aa2e5d885e8fdcef786ffd3c6ff345a3192cd676150e7ac15dddd4c5f531da4eeb723f22d77eccdc0b2484b0f2ed0951f5a9a2d42d9fa193683ae858dae3589b4008196d0b34317b16907c404ea53d896e3088a39f32f110e36d7c801c80ad2059e69444d21393d5e1289861c75fb7830b9d9dc5546ab1e5cda95780d79fa4bcde5be3441a14bf1741d4e14807e7930a2849993b85cf8c3d4ba1a87c12fccfe8f17ba7398131289237513d994d8f973a42ca0b98a5b0d3c319e316d559673105ad0891b078d342adbcc76f913da14b1985e785cb80863d36b5d50e93e9223a2884890426c6b1ea92b829c5856d8ed4f68adebbd641674a4146eb2280b6304a7d6216502ac2446ba807488f10901c4ae879547673ffddb506104058027c2402ea6f03b9429e71d74dce9e7ad12ffba70241ae44abcb84c7de04e1f73b431de69bb41691ed5cd2f40d957205a036ffab0b4253d655eb70fa1488a69112655ff9e8c011e0f98510e767a39c61bb8e73c3b6e057a3e1f83420da00bb833737a0aa2fe4fef160c72c5ce9bddf8e7e71e7ffdbcb5418603cd8dc5d2e893a906b7e6ecac117579036d02f1b864ba3f1d6976d1581d765d2285ed126dbc9139cbb3b6b92d76e2cd44e95dab9996739bb592e9611d87c713e1bd1bcdab85118f1be6598d7b344cf2be6053094aa2c254fe545e5f0609e416bd2b837fa9317b91b0b3d78938449d2fa37244feefe69d44c5590c4af17811fb334cc1ef213bc5aee0b1ecdc9c6a52d801dc777a43e68ca023c38e09470a8cdfce9395ab6c111a870dd7d8a7014a738517446eb016e5732ec9e4f486f67ced9fed94ce2647da09c59cb69a20718dd6f3732020afbea058850026d369de05a2b6e8c593a5bea2ee39026bf17766aa758b15b14b1dd54363b997faa040fdecfc974d060763a458fb38a16ba57d767663d607f54581d79700ebf169f1c4dea335affc27c71a405f85c33749194fc1079f6fa4d9186160c3dfef871e4bf4ef2befa33f5b9d3f14f7cd9a2a12efe871c361461d543678d1c650a0bd1b5cdf34bcfcffd3bc5e3d0b93862bc2d186805726a3c7a6a5f41a6830052c82adeb8c993d56487d21fe524834c02bbd99825191c101ce3657512f00666c1ae8a8e0536a41c45a7d400ea595c60ebf3d05cb15d8a980c2ef1f2c132422dd06ec4127576fb8411e2b09dd1e84fe4a391d481a38bc2703bfbc15aea790d20e0103895c3ca497a9f8285edd00514b8409e46ab74c84502dced35a9513e1e1bb5ed6a308f6b2095d02517f47a2262eff8b9f83608f98b2a7453e3e5cd82ae76503265aff78a96a6b2e8b2e71332cbed9d940806c7b949602f03f992e9a131cb55a3585996bf812d9a76d4cb480f90b0a9fc7a89f248c3aab39a42639be8b04d884a0414836297d0563b644200abe1e22b65e1fc5b690166c79e7a8b8b79eef26821a6aa115758ae70d2bb6239513153093b2bd086169e543c96692616aecf563f988f2a8264a3195d373d980202956c709f309e7897e3a9ff326808a01bdaa5e16054c697c968ed2728eb81011fc427951b3e73469bdf0459f2a00355c6391050cd89bec87dcb1e84942ea0ab3f95008c328ea1cb4c53551f25e350e4ba8ac9323c1f6a4d076ab5cae591462d375f1333e52987f82bde6519692059c6f533127f8eabb315d93b11464289f9e2907bdd7550bd3fdb918a7d06f59f98b437c0d85d606c686f4d0a78b4b4ae400c3fa7d34075d9e71eebbe8cf33d9167e9c145b4d3ab37ff2de87b1a8e237cb5e34cc14cd649388f8abbd68984c4c9af750840e3263fda8ed85c7e4e6a7a9468ce94ceb43863111ca27a5a2d46f171054b1d138e3f4834192b75fc74642581a480654575b72765cc58f07ecff45f285923859f64df143bf5c947b00fe24fb862b462ecadb8b9dcd908811173eda360fd6def88d32a3d054e48c360563d7f51eab76e8c90f37f3250ef36ecab99c45ee660a37c15c1debee6b9c195a1896b97c07ac3581797aed8fbccef32ac7583ba2b9844588b53c79d523248d3943a9ed19e253dc7fbf54e82a84f9590d973b89c8edd416e421f9350723fe927986eec26a7cc8fc930c39656ee5fe25f6aef1ebd0a789c7c0deac6ba01708bfb5fd5b8fa3748178c67060294a66b6304dd736c007f6936e3a5feb7ce650bf54bf4503c2db0a3e858ea19365c8f60bb01a3da7c32c81b315f93a9d99b5bc2ec919a4cecaee9f2e5a211513f914b580d5fd9a5812210d2a8763b68d68d43096eb56c4e57869de93050bb48efd1dd3b9227553546945bbbec0d066c284f3a940e0722b64a60f5568b5cdfc8ceb862c960def69b41e49f7754d63086aabb85992282e24d693ada815009c392f6131488d5ffd2796738a710b07e6457a2d72e24fc9e000e04aa4bb4ffc701590713c33172a4d1fd8d8c0b851438877a07554e612fdfedc93d0e9b7c6d30086b761149313e739bbaabc778c2397eea2e9903aa7b818c0416c17b5569ce77e3c9f0bac815ca7b65bb4c422e009279e759f3497a6567f5fec25f81f96bba30788a80e0ac5ab1b76b252c12eed42ea77aee3ead031e5e7cdf5523d780b4b03dbed3099399aff9e096d13b411d683a566a9c76caedc6e1bb2cb83f1afc074d6efd7df8c9fb4f5b83bc7c0de14fa6e0819121af48e30b361dcd3bc193c414a23133a92f3805389137ded1f58f581fbcce63e0e9a20e0cbae550eb93229088c9b41b973ee2e3a9a370d04e25b5343daf28185c9f93dd4f8386f6664e9eb0c398e0f1c7818b291d03d131e81bc989ca2fffc4c454294d9b210b190057202d8047a4d7e00f500bbd8a3d8ad1827723e0e6e831ecc08525eff2f4d81a559e726a46e2f99135a74ac5d0ab08295077efd94d92cd559da6a707de857578ea327170b918daf1086d17429dbae3419230cb077538ad1f2b55c2c1caefa63a9d0b7b0c537d498541c9eb23975cbb8c5b0d9e398c64660d69c3ef9e2032c26b1e840f4bc0eab9a87b8dd4866bc1e6bdab657b5b5793e4b2e189b3591c9e0a0beca833769e2c5cdbbd9033457cdf2c0d75ea72260552c50bb805bbf817d5a38b60708fe662f25ba0780fed1445c003889049d9eb7c070fe5eb0410b981accbf35d46cb183a6c7ec45dd7c8d43b8ca8a12d7b4576c7967d16845e2930c1e44b684d86f90cd72f0dd71122e53e650dd305b1a5d698713e1e7c412d66e7bb89b75f8406da4710f5cba60564e7c1387e4bfc2c235dfbefeb27263e217bf938cace22de2a15088348cca4df8fb078f8eee11cfeea4ad4fe19da73ab7ab527c93c01b567529ddf8f07ce872a778d1eb6e2c4e2d966076acaa7166eb340e9bbd0a2331abbe3a64163adb448404f317f1274bfc15bf650c3934e33516cbfdab1d5cac00f656505c53868100770d6e797313fbe0235f2050625f3043afc44dc238eda6fc5b2484e339210c55d8622d0b96d05a0b92614453c19f5f263f35036ef84bb0685bc26d281321f8c2b7f3cdf3e6f6a72dce6a959d6d2e910ba674837c40b7f97571f4d91126786bf11873f920e98c649fd19314d90440fec134cbdf6eca28a625e8cfa502de3284f0803b00ba1ad4802a3f5b94d19cadf821f2c500fd6efdb2ae82cd50b239dd4521cb6fe6378db78206292761e3199cef80c2e19c204a1e699ce53d7277f3ce2b8dec5fba568d1091feba777f7a10dcef8c65b16ee8d3c726e97cdd26aa5886fe210bb0515f237e8b44ce1e8714c1e55bec967d3203cea217a5e15c9c8b9ecd88647a5049c5e7c570515f59fae3389f24847fa39ae544df6b668a6bac939e495612968be578fb0e8b5da6cc807140e9d7413663b5e35924872acee6e77d591a6d7751e3acc59e9276e2e0874433be9745866ecbe05c1e7ce8eff4a7011eee920d2e10cd8e8aac808586505da9ffabe35acca1e9ad9116601a53e0061073ffe7a2e95e4fd69366de2630c1a036a286f44aca1e8d3c43d474598301246d656d6c87c239ce34d4af501d488f7f071e50d6917882ea417b79fb53aaf22309d643fc22b7cd9c26d30f080c9a3db1106b9ae9684ce80c843172e83c9edecdf13e108b7e62ef728d46ad4d5679bdfcf233422ea387c409b44997791fb1941742ca4f6862e0ad4e37faf005033c4b328b70846d6bb4ce6aad304477f16083e2d5698c957395f5f4ccf207dcd568466eaafa7c352ed1e6a40df3141fcbe83399e8b19539ce88f21fbe2b35f556dd74f86626e9fed0360e8e918011c61bcaf751f538227d319a067403637a73e6e49ef6e8cef83404267b592c062bd0c19963c30a64144b01c1f828bf5510b3d2738f103065a4495236d62d405ccdd107482992fdc4c85dcaa697c68c3ff6a17443c5354f1e59a3e31e2314dc991bbade21a8d565e6d81ff7add26d3614ec7a09195288c5afdfd421dec8b23d014ae8416c86d45766dafbbb4dbd4d457b5a7459764d07648b84a4305c85db73d6b6aa915b9955d29202d52cefb0df5db2963ba4555eaee5068ae11f0edf9173c26dac1e58a5d1f46f15d57f4d21614924db46a497f0016a304b34489c56755f5ae34d8ae529badac7ae345be9f50c89c70ed0a5f332272b68449723154016f5e1cc7c2474392a64d808f3903d9ad79f7e5bb1eb6dd2fe2fd84ce6d7ac83a00c09dc4643e4436fb3fe47e7ccaff1ff7121bad52ac95bc4734be7c5022a051b033448bf3189ced1457fed699b5ae9785aad1e80f4e977ec53fb08b9053ede2a3a6f2415df6c1b7ee977588d12b0ab59f70f494d2ab333f235ac2a2309f7dcc2927dbb2fdd2e1270efbef378875b6c810a338d73c67f1945bbf767dffa06904b6455acf8bd40803c55dcb3403aa72a14a94efdf675e6e15d2a7444faf520cf727a5ef75adb361ab5aea58646b9604e4e464bc0ee5837755808b2aec3f0f49b18ca8cdc625b08e100d4234fd076fa1d4fa0ea497f3f62d5aab6baf899a639fa1615271620c6dd496440a12d63016d9b10eda121ef18d85d5497b8aecdddf34e03893be709ff8ac2524978361c757ff9fff2a1272966021697c1d3cc6590ac427aa44a8127f64c786a2289e657048a04959848b5a4a5c15690bd81eab070f84c8c3f93638e6d1257ff87d44e142c71b553b53e131b47ee805ee30b897d529a782e0d77858305cae9e19d17e7611c4d4692f4e0095393981e6f0be23dfa0d5e142c8a8e172073bad5dc28d8a32ff9bb852d7db6026f0e150552bcdb31d68e8d3c149bf469d8831d63851c912732b45a0c35633409d9e74fdff6fb778470b34c9588504a028df81c051998ddda543ed55b9a51cf01a9dc122159bacfaff13153b8122cd11e1ba28eced24bf4d61d0cb0bdfcfd2762c6718b17d278e38f021d06a0d4b6d4d7bdfdab968d2187fefbe497c1097010df5f8e91adc431e71d42bbe1f0a12710fc873aca0fbb11c2b9a8bdb98ec237438a648b2fb0cf80a6a7f7acc0daf7a729385e0204c4b599ca749524442273b5c495794da4ce9c1e9174f2d6e7e019a9561f1f4c77d24263da9d5b1765c7050294d3836603c55956040f1d09f45dbf07a3f9beafad7041a3aff742e3f71b9f812c90e13770c230fa96ce0cb766d6a4564e85ca1fee5338e9648ff0c3434febb9ded02f81096cc77b299249c4993b14cc255be982a13f221e80e7561d22359f5b8a00472cd8e9397a919838c1e5ec4f6d457b051e049eb7a35b35b6f64dd2c01c217816f44cfc1e3fbe15b33d7ef6939ef93fcf4a261a29e58e81744a4eebcb829aafc621e7ccf30c9f060d4e493005a41b4c42c571f18173295a515fd76dfab13d8b5c3e64ee09db8bb0518bd39357621afcd54a74c515e802724c6e65201b8ed9d729cc28ba2210cfdc57e02ed46c064529081fd5f5612102efaf38d15f4a4e8b8da8ce80dbec473d83a28ffb506e0598bcb299a7107a759c250e83a813f24a7325edb95fca603f7c6bf6e7f1d0d76c39d88abfcc5ecb151de83deaec6806fccaf8b37acdc126177e666c53d1c3dbca7bb0fbb7440282e8367dd8c3ce41f44f3149bffeb9e111d3c12b25247d30a959ead441abb00183e3cf3c1a73492e5603bac081192355c122c6d0f60665e4364fc8e7017f28dfec8285020b62b480c18cfaebf1238ee50f42954fb8ee3a31e642ce74880d5fbc1da7bbef74f4d1db6f20dafe3d37b0f4ef695f94361e612fee439e7e98a540d04844fb713d862e3c067ef690a84228bc7d338134ad9ab15dbf76351d4605412a03bc3635c50f93fd02db5b402a4d4f8c11f33782a46881a52cfb9b2abbc990b39edba7bb9a02a0c3fad4ac413ce3a205e8f6f3836d616f5198ec28a99b9b09ec6b955790b9d726e2d5334a9f8859add12c23b5124398e892f6108cbe87a148ecb1e837b7f61721f174947812c0a4f1bdde46c9d76c4c7421f4d18af3821cc8a92d1dcc6cee3133c2438d4c10779517916f23c47da13b61b7641ddcb08d3ae32182c7684af05819354967ef00cd4e5a0465159c0152880a80130aa124075f978c3580136fb8f6ec30c0535ba61937be14e9394705992c15871ad58a019a7a536e6dabd272fe9868c4e5e1296d360c84a73c2b554e07fa765c7355f75d398329f377e13bddfed53f4a3daac68d1efa2ecb4d29a29d5630825428c17facf59c0a79121938057caaae712824aeba0a2dab8205e7deaf7253fe1d7c44e140e5146925460216fd8b59d0e53a2689f3d0771ddedae16729794907059205148e11cdee0db4e288ca24f229b0b95ea92b9cb6c4e2a54ef006c3e939a56319f4e73a8171bb2b45b7beb175b50f3e9faf483310eddc71ff389e3e2159b2c86922528b265c10a191340c30bf35b6d44b7071ab0b4df4923fbd4535ecbaf08cd67f7f63312859d826c731e1930628d035de76dbdff0ab7f66fe684220fd9baa35f74c894d8b76ed20d7fb2eb95e97e91cccdef3d81a5ecffd5d6e8c75c4e5dbab2344a76ff3885761d1614956024a37502111248e14c7dcfb3c9522a5375970b350bf3b4d0ba2979630305578167f8f5b51e2f6249411c5b1a7ac8157749121b68f75743fb864f51cdf5158478f9b9e773e518e5fcb7422fb78403000eb37a28e9dc311fce6493e2539726343525e725314dc8c5baca4c1c55525baef47518e981112af3112ece7c98aabe24a8a92dea520057104f635febd75f9fbd56e1a0f03f17da32b4e0333912236eca990060f002da8ba3cb9ae2355d9ec7502df9c62e75cb952f3ae8dd4f2855c22225234a83b7ff447477b7ac5d4616d4450087e2f27cc1d272dae294fe0163a5dff686c0059650b36d9654bf1759be5191c47bc02a3c2920af9575fa3f91c00c940659c990db1bc5b5135a9af740337de1536e95c454d6506411c9672681f2156ac85b81c2bbd5870387c7eebe7ab762fff41753d41a0e134332c61c1ee54a00d42e9b1df9034a20bd62e44ac83c7d2f00b701793c07eae9bb18326de753f022b4f75af9af89a5d02232a273f9d77968febcb9a34343d7b507384ae5159d79f7ea6836cb8a7f82642f5ad7ccae59540698de6643943d9d2e46cc7716a8a9087b83480090e1824f07fdfde1be3f28a44ba6679adf95584cda5ed395d90008205930e9d1bcd620c5f6a08ae7f22148ce7bb383ea342d0e915a192874e02eb11006a1c19ccc6f848417b6f92d931787a41250373e2a6e4a2ff0d9d9e4cfb321a154569cc831b405ad1efc6058901b92319aec0dc2fe24507cace980881619676a989763a010fad9ad9c4f5ba37e3d5105a122fc46625db3faee0a6f66cd66705a2be3c716afb51b586101dce460642cb8e70cbf46b1c4c19062d6bcdde49f34f6a72f4625283e29fc243b2091b392551e452d8a929c3ee6caf9b87c93c6d983e7c5a9bc6622d1fdca9c73caa7e02aa55ad2707b370b73d7c41859e930d2a4c714a620cafce56f0cad661b9d30351b83c55599790f3c6af782110420dae4ac3b8922e1fd49d0a5ee8ddb2931a510694940ee2afb7025955af87289dbf55ae058326e563fceb926597386080c88e0be0f81b7e5cf2d5348937cc8e215a21671cd8dddd29be538d67f2d8fecc9e8f576167a14f391f91ebb3c6d1d9c9ad77c25ccd04fbec4e878e6c663e6d118c55fa34e17e807d2f948d1a3aa2aae700ae7e77e9e458402238798d04c20a1bcae520a0243a36cdab42061412994730a4bb73bb5b0774b8b9855163b9553a23eef032cec4ebd2e606a6dbd9e800b712ed0739fe0415c8b8a3b9a800e9714006138c8352c1823e6c42c401ecc8c61c6af1b0873644391a9ed1ba6fbeab21e16d81d12994206dfa697ead5f0de33295a471c0b74cc594a955efe5969e73cbdafe2498580e5cbfecffe7055de6448ade55a19201e3017eeb9f3b2e7e296365c8424e2a318c28db51dfeed56d5f8a67e4adf6db4e11a35889bbea923d8734da9f13b9dafbc15b9385c4f0aa42267625bcc5d75f4cc3e289bb601f749701d277e702a8e02aa5ff867ccc02a021060451abddb88926674bac2b8f4da72a812eac1dd9871bd7deec67d76d4ccd0601278707f0fcd0da40a35a56157467fb28b48a021079d326f0e5b133e114506c10ab4bb9c03e3c0161d2d7c14c9d89a2a45c0470683e7ef2740c88670486a3470c4244180fc0485aa61e2941ab6853fd2dd8c149bf3b59ace26b6c760437a2798529fd8fef23a5b3f0cb1928b2119faa4ba707f49a8b43111b041531afe995f19b267a8a511748f024d0f1d3a72623e693a793a7ec1e664a0238e7c8297850e1fe16585d059e27ed4fbb120abe822b21385b96928e533d5a3a9634845871edec414097baaa42752775cbe6a6781c1c9174fc0f5e9d1e0e13ebc2381205d98032e24b394f47f91e85a920d1bcbae9078d58a0de3f2f2f9d9d475262071ee24a59f7724f883b012ebf7d9028f1a837dcb30b2ab9cddc7d0e94cc0916f222206dd26b9b319c78f7c192c44dfe0660b26789483858e772988b94777a1114426464cf0b587e10533957ec621b0e218076802052acf4b500afa264ad935622c979bfc8cc7998250225dcffd84532f2b13c8f46c52795c3b6f25dbc39f0411a5e5f82c752f429201b8b06ac30e76555a3fee8824e688e8f2c2249601577b205d653e48863307c15ea87d9881a5b26209066cafd81406ad62b00d005cfa65afdd5a244da22d40e1508946aac6eb876b35466dbf3c1f280fb367122f1e7fb1d4ce0b3cab89419f4132b220a0db58863b34a00bfaf41f39c48fd27beda716431aeb5fe62d1c9598b1f5c1d5d7a960d0a3a1359385e0915f46bbfd1ad3ee03af7e6de91cd67de517873044eab984410123ed968de588e4b7e2b881a65f7e8b7980b0bb427e4e16985e2ac327c020507d24bdf0a4867b60563c387be9ea7855a9a6c6d72eea1a5289cd37a4bb2c470bea35f4739bbdbb9938b964b4c2fd96e4953094c5f36cb37567a148b5e8b8ee4773a2a4b8ffbde1805b38dea9f59b5945174920a6c62a18b8491e1e9c9bf6a895b152170acb22c9c670bbeed455362eb3fb761d265eb27ab1d14c9fbfabf9f43cca78979fdea7c67cb5b8bb63ae1b47b3a863e87cae4a7570059706566df651ec416fa1a38447e07278bc3005fbfed748ed15ce9047c30c60db0c9fade30cf4e358890ffe3581c87d44777f6d44f46806beba5b643acd9196d9229519960f6de280a272e0c001ebfdc215404ddb93e557d179c6b7e9f5ed546edfe376d78564a1e4ff2cbf9892966168991c4dfa1a7c50d7386c3085817f8afc29b66bbad2155a731e8d18a73c7aeb8008346824c6cf43fb9b712d8956372425d02af5921580c1cb7956f21253a152fcf097039abbe9e3369d8b62bb8082fce331f1a3c84aa812ac6c229841a68ca4f04a1edf3940136086f7b8b3d091bec0e48ec76290e7223a05c40c24734b5af108aa33899378d2df2885701495506e63bfe8c62aeeb1ec6612e702968dd1111e01035060201e682202dc0b9011756fc1584029e18ad1947adf17ea0a0a111f40b3aa4ef61684983d0b2aff7b9bd70b556ff2500e1addc6a899fea14ba4f797bcb3821fca6bfbcd51dbb9a13adb3e34a402ac9bd93667a07969f0e51923b0b45db4053b974924a546760a6cf7b0f82a3149379c9f163b1c4928b50fc07c0041187d21ab2f35fc80b435e82c3bcf6ed1d3a110ee531b40e68df8b995c48b0e17dda3df44de09fd5dc2d1bdba7e38ecdcf691c0b8a63aa8edf28971d62d2265b182d971081aa0fb176c1269c9a1bd0adf764a6447a650c1d47d6893d813e2c1adb757436f8269b71eb25ea276e6a887dea84e164a32644b5c7afb1427d06be15dee2bc1610bef1bce29c5a391376d141cdf0a96d8313782254109f0cf63cb997f69ab0e33c8f43f46b265b9f49afcae76b78e53779c5c28308cc3e456b9cdcf0b6689b3e1fea19fe5b67df5d7d5552dad55c4158173adc2822017c697646c1f2bd2fc560aea03b3762f432e637263a0dbcd09b25bdfd2355c5f53506f7226ddb3cd7a84d63883fbe51895354faaa5ce720fde35a0e124d02aa7a6de3a33ed2e33d20997a1454de271b3fbeafc6dae5847706a713641536be9233afd149551faf2be83a8a863bcfa7554a7c796803e76257d7855bb5935e8964d2762823c37b236627dc7234fd52bc08eb84853b9b64c63aca79194c54e8a7870d1606e39fc2074cf6788931110f0ec8bf803c931f11e14706465e8109119b31e46fc881077715995e4a4e27d200d050e82eca8eac4aa5591e3df30fc0b3df491b333e1facd47b691ec71150d4abf55c4d269b85472d2ffa2a77a33ea2d15430440faac464ac48e6497f5692c4b413393554ce3707d4a24fd71c8fd7918ffef67bfe18f6397eef99b178d802a6c052f093e2141f01fbb7999d70f5819cffa135ba8d2127035e532e8e43a5873055ac597c6dec6073f498a5df8aca7fc58782286d70ab57b13fd98e241c6704f9292265cae29ba938111700155d814923cc0ef5159086b7ed5d2b1d546a12d17a0e8d4d5a562565fe359092e9aa296746d364fb900619b88dc6e0a6db7f6b991bd88104307f4b4cba7cd2b074507fcd3a8773841e5d6755d885a8aefa51dc878bf1bd84c506b2e2e59c036be939aee53dca0adcfcb0584c34fdef13a3421f710cc170b44b914a4823c3f9745b503c031f8d87271e6f5c7fb0322c42037dd22c9cde1ea0ac8f83d4dbd2c2297ef0f63a5958cdecc12c741c0a77ce0d8e76456a42a6208a60922b3b544eebbfc991623577c3b54e2bd3802c9f2abe47ab90c0261e856ba3d4dc7b73171095cd6476c590c9cdaee212efbd5268387bdeb7f7c2dc44f661f733925adda463cb5b40f2ba639316030c5b29a717794d022344394951b8dac0667839ff78c6f92569b23375235149f571473697514ea057ed44b27ea395066135ea554cdf739a66aabf940c36e48e6f85734b4cbf7326ff00e9cb64d7b12338a48dee93e07a90e639195ddd16ad1ef6c28eed0169b7b0ae14d6e7d4792d388c276f52faa45255009cb9efb7139f86170537ea35c4b2fc5d76f0cda0d4c35addd319153aee4cc8e388d4b35cd099c3e6ec7a34c9d0865dce836d35ab2e2dad26616d16e2ba9c1dd53eb91e74cf1db3a9724b1639fcbe0d22a5b70f740496c382e941c4d5deaa12be054a1473f8eae2036ded0212ceecd5d05c5592cf065d04edc5f563cb787c19d184fbc2f290f84d4014da08d822398d50f08cc35142ecf4bc199981826d6f8b47c07580f174d53f3c51989d77da40f8049de5a097255c5b96b170ce1fdbc213498ab52da428c2088e40bbf19170964ddd20cffa95b9a62e31dffc408d8d95ca61b53e52b6c1708d3b0962969c98e02f6f71b2fff1dfaf407cae8f844ccf2bc99cabd89e25c5703a7772b6c786ad1a1f75931b053a17061f47bc2ee72ece0181b221005acf48fa82143dd658dd70f6f4ffeb7c96b4e547af0093eba81f9f42ede736e4e962de5d6b311e7f78c40dee3fdc0cf42baaaf29dbb82d98e4bf97285866088d928e14566d8d83b6edd7b39c71830ffdcc2107bf6a661f19fce833b344ce07326d6bbc945106ae0451ae342eab0b72079ca5b667cf59f3e741ad2c84287753ad1450bdc102e09fc87f4d3e9818bb4c64d8a8fe7c4b4e366fe7b5a2923ad8241d8b2c01177d4f1b277faea40e967a03370cc3f0bae441b26dd26e13d2c64728a4a7b3dece080301ad2e89180d8f3fa4d4ccd097d0c24ccc2892e6b477c5221da62e8c8c5e5c4aff52a9ba4a299879ffcd190fc5a5872433a2a28df1d2ee01fc4e055759ed63cfd863e51addd6626cad038ae58eff3d19b0f89661d1efdb725a90d504672713c4155ad1a379df76a49bf8a34a6adf14d38e299ec52ed5c4d939afe6a6b6e86d60e5cf8a1215d8d2ee320df86c7da05e7ad5574515b3cc0bd8178fae4381b7d701ddb7ffc43e32ed912210c015c870b8a4181370f6878bb22c75323ceff82b9ac37482e08defaf0ec56b3a4bf839c92182488bedf82487c7e4c13ba001df05c4862235288aafe962345d8ea640e853f14f0defd4ee0ff20b5bd5c3f7ebc1f1dd94a1447c2e7eb56735f45f7519acf52ad3f58f672501ae18d1f0dac94736fc49ddcedb5c81265f2746431c3593f012c2985d8f0733e5440ef9b16ea3f174cafe29776051b08afcc87f9635ca8bd3d1659cea91492483cd7961c589d1ef19c3fb2cf77762a7c0affd9fe37a5db649cb165b2099075673b4e114d2cf376b52a6d63df717bdc1958557f86d2204d92091b15071b09c0b7b1dae4617cc68adeefc5299a8802f8d41a1a2608ed9109d18277e6d1ab427201c6ce41f57c3488d190b99a078f5d864eaf213626a49e8c800bb6f67b7692b5cf3e740ca33e328814564e7d135ffc6e378b3cdce7411e410e596d77462bd56cb6571dc38198c23165cb2 Hey, password is required here.]]></content>
      <categories>
        <category>自动化测试</category>
        <category>测试理论</category>
      </categories>
      <tags>
        <tag>软件开发流程</tag>
        <tag>项目管理</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
</search>
